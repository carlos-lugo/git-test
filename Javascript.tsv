id	subject	question	answer	notes	tags
1	Introduction	Change HTML content	"```javascript
document.getElementById(“demo”).innerHTML = “hello javascript”;
```"		
2	Introduction	Change HTML styles (CSS)	"```javascript
document.getElementById(“demo”).style.display = “none”;
```"		
3	Where to (apply JS to the HTML)	External javascript files (load into the HTML)	<code>&lt;script src=”myScript1.js”&gt;&lt;/script&gt;</code>		
4	Output	Javascript display possibilities	"### Ways to Output JavaScript Content:

1. **Writing into an HTML element** using `innerHTML`:
   ```js
   document.getElementById(""demo"").innerHTML = ""asdf"";
   ```
   
2. **Writing into the HTML document** using `document.write()` (Note: This will overwrite all existing HTML if used after the document has loaded):
   ```js
   document.write(""asdf"");
   ```

3. **Displaying an alert box** using `window.alert()`:
   ```js
   window.alert(""asdf"");
   ```

4. **Logging output to the browser console** using `console.log()`:
   ```js
   console.log(""asdf"");
   ```"		
5	Output	ES6 variables in the string (no w3)	"### String Interpolation in JavaScript

In other languages, there are ways to embed variables within strings.  

#### **ES5 (Before Template Literals)**
We had to concatenate strings manually:  
```js
var name = 'Your name is ' + first + ' ' + last + '.';
var fourAgreements = 'You have the right to be you.\n\
  You can only be you when you do your best.';
```

#### **ES6 (Template Literals)**
With backticks (`` ` ``), we can embed variables using `${}`:  
```js
var name = `Your name is ${first} ${last}.`;
var fourAgreements = `You have the right to be you.
  You can only be you when you do your best.`;
```"		
6	Syntax	Fixed values and variable values	"### **Literals, Variables, and Expressions in JavaScript**  

- **Literals**: Fixed values.  
- **Variables**: Containers for storing values.  

#### **Example**  
```js
var x = ""asdf""; // Variable assigned a literal value
```

- **Expressions**: A combination of values, variables, and operators that evaluates to a value.  

#### **Example**  
```js
var result = x * 10;
```"		
7	Variables	Name terminology	All variables must be identified with unique names. These unique names are called <i><b>identifiers</b></i>.		
8	Variables	Declare variables	"### **JavaScript Variable Initialization and Scope**  

```js
var personName = ""pepe"";
```

- **Always initialize variables** when declaring them.  
- **Uninitialized variables** have the value `undefined`.  
- **Re-declaring a variable** does not reset its value.  
- **Assigning a value without declaring a variable** makes it **global**, even if it's inside a function.  

#### **Example**  
```js
function test() {
    newVariable = ""I'm global"";
}
test();
console.log(newVariable); // Accessible globally
```"		
9	Operators	String operators	"### **JavaScript Operators**  

#### **Arithmetic Operators**  
| Operator  | Description                      |
|-----------|----------------------------------|
| `+`       | Addition                         |
| `-`       | Subtraction                      |
| `*`       | Multiplication                   |
| `**`      | Exponentiation (ES2016)         |
| `/`       | Division                         |
| `%`       | Modulus (Division Remainder)     |
| `++`      | Increment                        |
| `--`      | Decrement                        |

#### **Assignment Operators**  
| Operator  | Example   | Same As              |
|-----------|----------|----------------------|
| `=`       | `x = y`  | `x = y`              |
| `+=`      | `x += y` | `x = x + y`          |
| `-=`      | `x -= y` | `x = x - y`          |
| `*=`      | `x *= y` | `x = x * y`          |
| `/=`      | `x /= y` | `x = x / y`          |
| `%=`      | `x %= y` | `x = x % y`          |
| `**=`     | `x **= y`| `x = x ** y`         |

#### **Comparison Operators**  
| Operator  | Description                                |
|-----------|--------------------------------------------|
| `==`      | Equal to                                  |
| `===`     | Equal value and equal type               |
| `!=`      | Not equal                                |
| `!==`     | Not equal value or not equal type        |
| `&gt;`       | Greater than                             |
| `&lt;`       | Less than                                |
| `&gt;=`      | Greater than or equal to                 |
| `&lt;=`      | Less than or equal to                    |
| `?`       | Ternary operator                         |

&gt; **Note:** Comparison operators also work on strings.

#### **String Concatenation with `+`**  
```js
let text1 = ""John"";
let text2 = ""Doe"";
let text3 = text1 + "" "" + text2; // ""John Doe""
```

#### **Logical Operators**  
| Operator  | Description   |
|-----------|--------------|
| `&amp;&amp;`      | Logical AND  |
| `||`      | Logical OR   |
| `!`       | Logical NOT  |

#### **Type and Object Operators**  
| Operator      | Description                                    |
|--------------|-----------------------------------------------|
| `typeof`     | Returns the type of a variable               |
| `instanceof` | Returns `true` if an object is an instance of a type |"		
10	Operators	The Spread/rest operator (no w3)	"### **The Spread (`...`) Operator in JavaScript (ES6)**  

The `...` operator simplifies code and allows for more flexible operations.  

#### **Expanding Arrays**  
```js
let first = ['foo', 'bar'];
let second = ['other foo', ...first, 'other bar']; 
// ['other foo', 'foo', 'bar', 'other bar']
```

#### **Merging Objects (Immutability-Friendly)**  
```js
let first = { foo: 'foo' };
let zeta = { ...first, bar: 'bar' }; 
// { foo: 'foo', bar: 'bar' }
```

#### **Rest Parameters in Functions**  
```js
function myFun(a, b, ...manyMoreArgs) {
  console.log(a);
  console.log(b);
  console.log(manyMoreArgs);
}
myFun('one', 'two', 'three', 'four');
// 'one'
// 'two'
// ['three', 'four']
```"		
11	Data types	Primitive data	"### **JavaScript Data Types**  

#### **Primitive Data Types**  
- `string`
- `number`
- `boolean`
- `undefined`  

All other types are **objects** or **functions**.

#### **Checking Data Types with `typeof`**  
The `typeof` operator returns the type of a value, but for arrays, it returns `""object""`.  

#### **Examples**  
```js
var x1 = {};         // Object
var x2 = """";         // Primitive string
var x3 = 0;          // Primitive number
var x4 = false;      // Primitive boolean
var x5 = [];         // Array (typeof returns ""object"")
var x6 = /()/;       // Regular expression object
var x7 = function(){}; // Function object
```"		
12	Functions (basic)	Syntax	"### **JavaScript Functions**  

#### **Defining and Calling a Function**  
```js
var x = myFunction(4, 3);

function myFunction(a, b) { 
  return a * b; 
}
```

- Calling a function with `()` executes it and returns a value.  
- Accessing a function **without `()`** returns the function definition, not the result.  

#### **Function Execution**  
A function executes when:  
1. **An event occurs** (e.g., button click).  
2. **It is called from JavaScript code.**  
3. **It self-invokes** (automatically executes).  

#### **Return Statement Behavior**  
- When JavaScript encounters a `return` statement, the function **stops execution**.  
- If the function was called from another statement, JavaScript **returns control** to that statement.  
- Functions often compute a value and **return it to the caller**.  

#### **Example: Returning a Value**  
```js
let x = myFunction(4, 3); 

function myFunction(a, b) {
  return a * b; // Function returns the product of a and b
}
```

#### **Using a Function as a Variable Value**  
```js
let text = ""The temperature is "" + toCelsius(77) + "" Celsius"";
```  
- The function `toCelsius(77)` executes first, and its return value is concatenated into the string."		
13	Functions (basic)	Local variables	Variables declared <b>within</b> a function, become <b>local</b> to the function.		
14	Events	Common HTML Events	"### **JavaScript Event Handlers**  

Event handlers allow JavaScript to execute code in response to user interactions.  

#### **Common Event Handlers:**  

| Event        | Description |
|-------------|------------|
| `onload`     | Fires when the page has fully loaded. |
| `onclick`    | Fires when an element is clicked. |
| `onmouseover` | Fires when the mouse hovers over an element. |
| `onmouseout`  | Fires when the mouse leaves an element. |
| `onkeydown`   | Fires when a key is pressed. |
| `onchange`    | Fires when the value of an input element changes. |

#### **Examples:**  
```js
// onload: Executes when the page loads
window.onload = function() {
  console.log(""Page has loaded"");
};

// onclick: Executes when a button is clicked
document.getElementById(""myButton"").onclick = function() {
  alert(""Button clicked!"");
};

// onmouseover &amp; onmouseout: Change color when hovering
let element = document.getElementById(""myElement"");
element.onmouseover = function() {
  this.style.color = ""red"";
};
element.onmouseout = function() {
  this.style.color = ""black"";
};

// onkeydown: Detects a key press
document.onkeydown = function(event) {
  console.log(""Key pressed: "" + event.key);
};

// onchange: Detects input value change
document.getElementById(""myInput"").onchange = function() {
  console.log(""New value: "" + this.value);
};
```"		
15	Events	Basic event listener (old)	"### **Basic Event Listeners in JavaScript**  

#### **Single Event Listener Example**
```html
<a href=""somewhere.html"" onclick=""doSomething()"">Click me</a>
```
- **Only one listener per event** when using inline event handlers.  

#### **Referencing an HTML Element in JavaScript with an Anonymous Function**
```js
document.getElementById('asdf').onclick = function () {
  this.style.visibility = 'hidden';
};
```
- **Directly assigns an event handler** to the element.  

#### **Adding Event Listeners to Multiple Elements**
```js
var x = document.getElementsByTagName('DIV');

for (var i = 0; i &lt; x.length; i++) {
  x[i].onmouseover = over;
  x[i].onmouseout = out;
}

function over() { 
  this.style.backgroundColor = '#cc0000'; 
}

function out() { 
  this.style.backgroundColor = '#ffffff'; 
}
```
- **Uses named functions** for event handling.  

#### **Using Anonymous Functions Instead**
```js
var x = document.getElementsByTagName('DIV');

for (var i = 0; i &lt; x.length; i++) {
  x[i].onmouseover = function () { 
    this.style.backgroundColor = '#cc0000'; 
  };
  x[i].onmouseout = function () { 
    this.style.backgroundColor = '#ffffff'; 
  };
}
```
- **Anonymous functions** are defined directly inside the loop.  

#### **Adding Multiple Functions to a Single Event**
```js
element.onclick = function () { 
  startDragDrop(); 
  spyOnUser(); 
};
```
- **Multiple actions in a single event listener**, but **cannot be removed individually**."		
16	Events	Modern listener	"### **Modern Event Handling with `addEventListener`**  

The `addEventListener` method allows multiple event listeners on the same element without overriding previous ones.  

#### **Basic Example**
```js
element.addEventListener('click', doSomething, false);
another_element.addEventListener('click', doSomething, false);

function doSomething() {
    this.style.backgroundColor = '#cc0000';
}
```
- Adds a **click event** that changes the background color.  
- The third parameter (`false`) specifies event bubbling (default behavior).  

#### **Using an Anonymous Function**
```js
element.addEventListener('click', function () {
    this.style.backgroundColor = '#cc0000';
}, false);
```
- The event handler is defined **directly inside `addEventListener`**.  

#### **Full Example**
```js
document.getElementById(""myBtn"").addEventListener(""click"", displayDate);

function displayDate() {
    console.log(new Date());
}
```
- Attaches an event listener to a button that logs the current date.  

#### **Removing Event Listeners**
```js
element.removeEventListener(""mousemove"", myFunction);
```
- Removes the specified event listener **only if the function reference matches**.  
- **Anonymous functions cannot be removed** because they don’t have a reference."		
17	Strings	Escape special characters	"### **Escape Characters in JavaScript**  

The **backslash (`\`)** is an escape character that allows special characters to be treated as part of a string.  

#### **Common Escape Sequences**  
| Escape Sequence | Meaning |
|----------------|---------|
| `\'`  | Single quote (`'`) inside a string |
| `\""`  | Double quote (`""`) inside a string |
| `\\`  | Backslash (`\`) itself |
| `\n`  | New line |
| `\t`  | Tab space |
| `\r`  | Carriage return |
| `\b`  | Backspace |
| `\f`  | Form feed |

#### **Examples**  
```js
let text1 = ""He said, \""Hello!\"""";  // Double quotes inside a string
let text2 = 'It\'s a nice day.';   // Single quote inside a string
let path = ""C:\\Users\\John"";      // Backslash in file paths
let multiline = ""Line 1\nLine 2"";  // New line
```
- The escape character (`\`) ensures special characters are **interpreted as part of the string** instead of code syntax."		
18	Strings	Other escape sequences	"### **Escape Sequences in JavaScript**  

The backslash (`\`) is used to escape special characters in strings.  

| Escape Sequence | Meaning |
|----------------|---------|
| `\b`  | Backspace |
| `\f`  | Form Feed |
| `\n`  | New Line |
| `\r`  | Carriage Return |
| `\t`  | Horizontal Tab (Tab Space) |
| `\v`  | Vertical Tab (Not widely supported) |

#### **Examples**  
```js
console.log(""Hello\bWorld"");   // Backspace: ""HellWorld""
console.log(""Line1\nLine2"");   // New Line
console.log(""Carriage\rReturn""); // Carriage return
console.log(""Tab\tSpace"");     // Horizontal Tab
console.log(""Form\fFeed"");     // Form Feed (rarely used)
console.log(""Vertical\vTab"");  // Vertical Tab (limited support)
```  
- These escape sequences **format text within strings**."		
19	String methods	Most common methods	"### **JavaScript String Methods**  

| Method | Description |
|--------|-------------|
| `length` | Returns the length of a string. |
| `charAt(index)` | Returns the character at the specified position. |
| `concat(str1, str2, ...)` | Joins two or more strings and returns a new string. |
| `endsWith(searchString)` | Checks if a string ends with the specified value. |
| `includes(searchString)` | Checks if a string contains a specified value. |
| `indexOf(searchValue)` | Returns the position of the first occurrence of a specified value. |
| `lastIndexOf(searchValue)` | Returns the position of the last occurrence of a specified value. |
| `match(regex)` | Searches a string for matches based on a regular expression. |
| `replace(searchValue, newValue)` | Replaces occurrences of a value with a new value. |
| `search(regex)` | Searches a string for a match and returns the index. |
| `slice(start, end)` | Extracts a part of a string and returns a new string. |
| `split(separator)` | Splits a string into an array based on a separator. |
| `startsWith(searchString)` | Checks if a string starts with the specified value. |
| `substr(start, length)` | Extracts characters from a string, starting at `start`, for `length` characters. |
| `substring(start, end)` | Extracts characters between two indices. |
| `toLowerCase()` | Converts a string to lowercase. |
| `toString()` | Returns the string representation of an object. |
| `toUpperCase()` | Converts a string to uppercase. |
| `trim()` | Removes whitespace from both ends of a string. |

#### **Examples**  
```js
let text = ""Hello, JavaScript!"";

console.log(text.length);             // 18
console.log(text.charAt(0));          // 'H'
console.log(text.concat("" Rocks!""));  // ""Hello, JavaScript! Rocks!""
console.log(text.endsWith(""!""));      // true
console.log(text.includes(""Java""));   // true
console.log(text.indexOf(""o""));       // 4
console.log(text.lastIndexOf(""o""));   // 7
console.log(text.match(/Java/));      // [""Java""]
console.log(text.replace(""Hello"", ""Hi"")); // ""Hi, JavaScript!""
console.log(text.search(""Java""));     // 7
console.log(text.slice(0, 5));        // ""Hello""
console.log(text.split("", ""));        // [""Hello"", ""JavaScript!""]
console.log(text.startsWith(""Hello""));// true
console.log(text.substr(7, 10));      // ""JavaScript""
console.log(text.substring(7, 17));   // ""JavaScript""
console.log(text.toLowerCase());      // ""hello, javascript!""
console.log(text.toUpperCase());      // ""HELLO, JAVASCRIPT!""
console.log(text.trim());             // Removes whitespace from both ends
```"		
20	Numbers	Bug	"### **Floating Point Precision in JavaScript**  

JavaScript uses **64-bit floating-point arithmetic (IEEE 754)**, which can cause precision errors in decimal calculations.

#### **Example of Precision Error**  
```js
var x = 0.2 + 0.1;
console.log(x); // 0.30000000000000004
```
- The expected result (`0.3`) is slightly off due to how floating-point numbers are represented in binary.

#### **Fixing the Precision Issue**  

##### **1. Using `toFixed(n)` (Rounds and returns a string)**
```js
var x = (0.2 + 0.1).toFixed(2);
console.log(x); // ""0.30""
```
- Converts the result to a string with `n` decimal places.

##### **2. Using `toPrecision(n)` (Rounds to total significant digits)**
```js
var x = (0.2 + 0.1).toPrecision(2);
console.log(x); // ""0.30""
```

##### **3. Using Multiplication and Division (Avoids Floating-Point Arithmetic)**
```js
var x = (0.2 * 10 + 0.1 * 10) / 10;
console.log(x); // 0.3
```
- Converts numbers to integers before performing calculations, avoiding precision errors.

#### **Key Takeaway**  
- Floating-point math is **not always precise**.  
- Use **rounding methods** or **integer math** for accurate results."		
21	Number methods	Number properties	"### **JavaScript Number Constants**  

| Constant             | Description |
|----------------------|-------------|
| `Number.MAX_VALUE`  | The largest possible number in JavaScript (`1.7976931348623157e+308`). |
| `Number.MIN_VALUE`  | The smallest positive number greater than zero (`5e-324`). |
| `Number.NEGATIVE_INFINITY` | Represents negative infinity (`-Infinity`), returned on overflow. |
| `Number.NaN` | Represents ""Not-a-Number"" (e.g., result of invalid mathematical operations). |
| `Number.POSITIVE_INFINITY` | Represents positive infinity (`Infinity`), returned on overflow. |

#### **Examples**  
```js
console.log(Number.MAX_VALUE);       // 1.7976931348623157e+308
console.log(Number.MIN_VALUE);       // 5e-324
console.log(Number.NEGATIVE_INFINITY); // -Infinity
console.log(Number.POSITIVE_INFINITY); // Infinity
console.log(10 / 0);                 // Infinity
console.log(-10 / 0);                // -Infinity
console.log(Number.NaN);             // NaN
console.log(0 / 0);                  // NaN
console.log(""abc"" * 5);              // NaN
console.log(isNaN(""abc"" * 5));       // true
```

#### **Key Notes**  
- `Infinity` and `-Infinity` result from division by zero.  
- `NaN` appears when a mathematical operation fails (e.g., `""abc"" * 5`).  
- Use `isNaN(value)` to check if a value is **NaN**."		
22	Number methods	Number methods	"### **JavaScript Number Methods**  

| Method | Description |
|--------|-------------|
| `Number.isFinite(value)` | Checks if a value is a **finite number** (not `Infinity`, `-Infinity`, or `NaN`). |
| `Number.isInteger(value)` | Checks if a value is an **integer**. |
| `Number.isNaN(value)` | Checks if a value is **NaN** (`Number.NaN`). |
| `Number.isSafeInteger(value)` | Checks if a value is a **safe integer** (`-(2^53 - 1)` to `2^53 - 1`). |
| `toExponential(x)` | Converts a number to **exponential notation** with `x` decimal places. |
| `toFixed(x)` | Formats a number with `x` **decimal places** (returns a string). |
| `toPrecision(x)` | Formats a number to a **total length** of `x` digits. |
| `toString()` | Converts a number to a **string**. |
| `valueOf()` | Returns the **primitive value** of a number. |

#### **Examples**  

```js
console.log(Number.isFinite(10));        // true
console.log(Number.isFinite(Infinity));  // false
console.log(Number.isInteger(5.5));      // false
console.log(Number.isNaN(NaN));          // true
console.log(Number.isSafeInteger(9007199254740991)); // true
console.log(Number.isSafeInteger(9007199254740992)); // false

let num = 123.456;

console.log(num.toExponential(2));   // ""1.23e+2""
console.log(num.toFixed(2));         // ""123.46""
console.log(num.toPrecision(4));     // ""123.5""
console.log(num.toString());         // ""123.456""
console.log(num.valueOf());          // 123.456
```

#### **Key Notes**  
- **`toFixed(x)` vs. `toPrecision(x)`**  
  - `toFixed(x)`: Controls **decimal places** (e.g., `""123.46""` for `x = 2`).  
  - `toPrecision(x)`: Controls **total digits** (e.g., `""123.5""` for `x = 4`).  
- `valueOf()` returns the **raw number value** without converting to a string."		
23	Arrays	Literal declaration	"### **Array Literal Declaration in JavaScript**  

A **literal declaration** is the simplest way to create an array in JavaScript.  

#### **Syntax**  
```js
var array_name = [item1, item2, item3, ...];
```

#### **Example**  
```js
var fruits = [""Apple"", ""Banana"", ""Cherry""];
console.log(fruits); // [""Apple"", ""Banana"", ""Cherry""]
```

#### **Key Notes**  
- Uses square brackets `[]` to define the array.  
- Elements inside the array can be **strings, numbers, objects, or other arrays**.  
- The array size is **dynamic**, meaning it can grow or shrink.  

#### **Accessing Elements**  
```js
console.log(fruits[0]); // ""Apple""
console.log(fruits[1]); // ""Banana""
```

#### **Modifying Elements**  
```js
fruits[1] = ""Mango"";
console.log(fruits); // [""Apple"", ""Mango"", ""Cherry""]
```"		
24	Arrays	Constructor declaration	"### **Array Constructor Declaration (Avoid This Approach)**  

The `new Array()` constructor can be used to create arrays, but **it is not recommended** due to unexpected behavior.  

#### **Syntax**  
```js
var array_name = new Array('item1', 'item2');
```

#### **Example**  
```js
var fruits = new Array('Apple', 'Banana', 'Cherry');
console.log(fruits); // [""Apple"", ""Banana"", ""Cherry""]
```

#### **Why Should You Avoid `new Array()`?**  
1. **Inconsistent behavior with a single numeric argument**  
   ```js
   var arr = new Array(5);
   console.log(arr); // Creates an empty array with a length of 5, NOT an array containing [5]
   ```
   - If a **single number** is passed, JavaScript interprets it as an array **length**, not an element.

2. **More readable and safer to use array literals**  
   ```js
   var fruits = ['Apple', 'Banana', 'Cherry']; // ✅ Preferred approach
   ```
   - This avoids confusion and works consistently.

#### **Conclusion**  
✅ **Use array literals (`[]`) instead of `new Array()`** for simplicity, readability, and predictable behavior."		
25	Arrays	Access the elements of an array	"### **Accessing Elements of an Array in JavaScript**  

You can access array elements using **index notation** (`array_name[index]`).  

#### **Syntax**  
```js
var x = array_name[0]; // Accesses the first element
```

#### **Example**  
```js
var fruits = [""Apple"", ""Banana"", ""Cherry""];

console.log(fruits[0]); // ""Apple""
console.log(fruits[1]); // ""Banana""
console.log(fruits[2]); // ""Cherry""
```

#### **Key Notes**  
- **Indexes start at `0`**, so `array_name[0]` is the first element.  
- If you access an **index that does not exist**, it returns `undefined`.  
  ```js
  console.log(fruits[5]); // undefined
  ```
- **Arrays are mutable**, so elements can be reassigned:  
  ```js
  fruits[1] = ""Mango"";
  console.log(fruits); // [""Apple"", ""Mango"", ""Cherry""]
  ```
- You can also access the **last element** using `.length - 1`:  
  ```js
  console.log(fruits[fruits.length - 1]); // ""Cherry""
  ```"		
26	Arrays	Looping array elements	"### **Looping Through Array Elements in JavaScript**  

You can loop through an array using different methods:  

---

### **1️⃣ Using a `for` Loop (Traditional Approach)**
```js
for (let i = 0; i &lt; array_asdf.length; i++) {
  console.log(array_asdf[i]); // Access each element
}
```
- Iterates through the array **using an index**.  
- `array_asdf.length` ensures the loop runs for all elements.  

#### **Example**
```js
var fruits = [""Apple"", ""Banana"", ""Cherry""];

for (let i = 0; i &lt; fruits.length; i++) {
  console.log(fruits[i]);
}
```

---

### **2️⃣ Using `forEach()` (Modern Approach)**
```js
array_asdf.forEach(myFunction);

function myFunction(value) {
  console.log(value); // Do something with each value
}
```
- **Iterates directly over values**, no need for an index.  
- **More readable and cleaner** than a `for` loop.  

#### **Example**
```js
var fruits = [""Apple"", ""Banana"", ""Cherry""];

fruits.forEach(function(value) {
  console.log(value);
});
```
- You can also use an **arrow function**:  
  ```js
  fruits.forEach(value =&gt; console.log(value));
  ```

---

### **3️⃣ Using `for...of` (Recommended for Arrays)**
```js
for (let value of array_asdf) {
  console.log(value);
}
```
- **Directly iterates over values**, like `forEach()`, but works inside loops naturally.  

#### **Example**
```js
var fruits = [""Apple"", ""Banana"", ""Cherry""];

for (let fruit of fruits) {
  console.log(fruit);
}
```

---

### **4️⃣ Using `map()` (For Transforming Arrays)**
If you want to create a **new array** based on modifications:
```js
let upperCaseFruits = fruits.map(fruit =&gt; fruit.toUpperCase());
console.log(upperCaseFruits); // [""APPLE"", ""BANANA"", ""CHERRY""]
```
- `map()` **modifies each element** and returns a new array.  

---

### **Key Takeaways**
✅ **Use `forEach()`** for readability when processing elements.  
✅ **Use `for...of`** for simple iteration over array values.  
✅ **Use `map()`** when you need to **return a modified array**.  
✅ **Use a `for` loop** if you need an **index** or to **modify elements directly**."		
27	Arrays	Looping object elements. (no w3)	"### **Looping Through Object Properties in JavaScript**  

When working with objects, you can iterate through their properties using different methods.

---

### **1️⃣ Using `for...in` (Best for Objects)**  
```js
for (let key in person) {
  console.log(key + "": "" + person[key]);
}
```
- Iterates through **all enumerable properties** of an object.  
- `key` holds the **property name**.  
- `person[key]` gives the **property value**.  

#### **Example**
```js
var person = { name: ""John"", age: 30, city: ""New York"" };

for (let key in person) {
  console.log(key + "": "" + person[key]);
}
// Output:
// name: John
// age: 30
// city: New York
```

---

### **2️⃣ Using `Object.keys()` (Returns an Array of Keys)**
```js
Object.keys(person).forEach(key =&gt; {
  console.log(key + "": "" + person[key]);
});
```
- `Object.keys(person)` returns an **array** of all keys.  
- `.forEach()` iterates over the keys to access values.  

#### **Example**
```js
var person = { name: ""John"", age: 30, city: ""New York"" };

Object.keys(person).forEach(key =&gt; {
  console.log(key + "": "" + person[key]);
});
```

---

### **3️⃣ Using `Object.values()` (Returns an Array of Values)**
```js
Object.values(person).forEach(value =&gt; {
  console.log(value);
});
```
- `Object.values(person)` returns an **array of values** (ignores keys).  

#### **Example**
```js
var person = { name: ""John"", age: 30, city: ""New York"" };

Object.values(person).forEach(value =&gt; {
  console.log(value);
});
// Output:
// John
// 30
// New York
```

---

### **4️⃣ Using `Object.entries()` (Key-Value Pairs as Arrays)**
```js
Object.entries(person).forEach(([key, value]) =&gt; {
  console.log(key + "": "" + value);
});
```
- `Object.entries(person)` returns an **array of `[key, value]` pairs**.  
- Destructures key-value pairs inside `.forEach()`.  

#### **Example**
```js
var person = { name: ""John"", age: 30, city: ""New York"" };

Object.entries(person).forEach(([key, value]) =&gt; {
  console.log(key + "": "" + value);
});
```

---

### **Key Takeaways**  
✅ **Use `for...in`** to iterate **object properties** directly.  
✅ **Use `Object.keys()`** if you need an **array of keys**.  
✅ **Use `Object.values()`** if you only need an **array of values**.  
✅ **Use `Object.entries()`** if you need **both keys and values**."		
28	Arrays	Asociative arrays	"### **JavaScript Does Not Support Arrays with Named Indexes**  

JavaScript **arrays** are **indexed with numbers**, not strings. If you use **named indexes**, JavaScript treats it as a **regular object** instead of an array.

---

### **❌ Incorrect: Using Named Indexes in an Array**
```js
var person = [];
person[""name""] = ""John"";
person[""age""] = 30;

console.log(person.length); // 0 (Array length is still 0)
console.log(person[0]);     // undefined
console.log(person[""name""]); // ""John"" (But this is NOT an array)
```
- Here, `person` is **not acting as an array**, but as an **object**.  
- **Array length remains `0`**, meaning it's not storing elements properly.  

---

### **✅ Correct: Using an Object for Named Properties**
```js
var person = {
  name: ""John"",
  age: 30
};

console.log(person.name); // ""John""
console.log(person[""age""]); // 30
```
- **Use an object (`{}`) when property names are strings**.  
- **Objects are key-value pairs**, allowing named properties.  

---

### **✅ Correct: Using an Array for Numeric Indexes**
```js
var fruits = [""Apple"", ""Banana"", ""Cherry""];

console.log(fruits[0]); // ""Apple""
console.log(fruits.length); // 3
```
- **Use an array (`[]`) when elements are indexed numerically**.  

---

### **💡 Key Takeaways**
✔ **Use objects (`{}`) when keys are strings** (e.g., `person.name`).  
✔ **Use arrays (`[]`) when elements are accessed by numeric indexes** (e.g., `fruits[0]`).  
✔ **JavaScript does not support associative arrays** (arrays with named indexes).  
✔ **Using named indexes on an array makes it behave like an object**, and `length` won’t work correctly."		
29	Array methods	Common properties and methods	"### **JavaScript Array Properties &amp; Methods**  

---

### **📌 Common Property**  
| Property  | Description |
|-----------|-------------|
| `length`  | Returns or sets the number of elements in an array. |

#### **Example**  
```js
let fruits = [""Apple"", ""Banana"", ""Cherry""];
console.log(fruits.length); // 3
```

---

### **📌 Common Array Methods**  

#### **🔹 Adding &amp; Removing Elements**  
| Method | Description |
|--------|-------------|
| `push(value)` | Adds an element to the **end** of the array, returns new length. |
| `pop()` | Removes the **last** element, returns the removed element. |
| `unshift(value)` | Adds an element to the **beginning**, returns new length. |
| `shift()` | Removes the **first** element, returns the removed element. |
| `splice(index, count, items...)` | **Adds/Removes elements** at a specific position. |

##### **Example**
```js
let numbers = [1, 2, 3];

numbers.push(4);     // [1, 2, 3, 4]
numbers.pop();       // [1, 2, 3]
numbers.unshift(0);  // [0, 1, 2, 3]
numbers.shift();     // [1, 2, 3]

numbers.splice(1, 1, 99); // [1, 99, 3] (Removes 1 element at index 1, adds 99)
```

---

#### **🔹 Searching &amp; Checking Elements**  
| Method | Description |
|--------|-------------|
| `includes(value)` | Checks if the array contains a value (returns `true`/`false`). |
| `indexOf(value)` | Returns the **first** index of a value (-1 if not found). |
| `lastIndexOf(value)` | Returns the **last** index of a value. |
| `isArray(value)` | Checks if a variable is an array (`true`/`false`). |
| `find(testFunction)` | Returns the **first** matching element. |
| `findIndex(testFunction)` | Returns the **first** matching index. |

##### **Example**
```js
let items = [""apple"", ""banana"", ""cherry""];

console.log(items.includes(""banana"")); // true
console.log(items.indexOf(""banana""));  // 1
console.log(items.lastIndexOf(""banana"")); // 1
console.log(Array.isArray(items)); // true

let numbers = [5, 12, 8, 130, 44];
console.log(numbers.find(n =&gt; n &gt; 10)); // 12
console.log(numbers.findIndex(n =&gt; n &gt; 10)); // 1
```

---

#### **🔹 Transforming Arrays**  
| Method | Description |
|--------|-------------|
| `map(testFunction)` | Creates a **new array** by applying a function to each element. |
| `filter(testFunction)` | Creates a **new array** with elements that pass a test. |
| `reduce(testFunction)` | Reduces an array to a **single value** (left-to-right). |
| `reduceRight(testFunction)` | Same as `reduce()`, but **right-to-left**. |

##### **Example**
```js
let numbers = [1, 2, 3, 4];

let doubled = numbers.map(n =&gt; n * 2); // [2, 4, 6, 8]
let evens = numbers.filter(n =&gt; n % 2 === 0); // [2, 4]
let sum = numbers.reduce((acc, n) =&gt; acc + n, 0); // 10
```

---

#### **🔹 Sorting &amp; Reversing**  
| Method | Description |
|--------|-------------|
| `sort()` | Sorts an array **(by default, converts values to strings first!).** |
| `reverse()` | Reverses the array order. |

##### **Example**
```js
let numbers = [4, 2, 10, 1];

numbers.sort(); // [1, 10, 2, 4] (wrong for numbers!)
numbers.sort((a, b) =&gt; a - b); // [1, 2, 4, 10] (correct sorting)
numbers.reverse(); // [10, 4, 2, 1]
```

---

#### **🔹 Extracting &amp; Joining Elements**  
| Method | Description |
|--------|-------------|
| `slice(start, end)` | Extracts a **portion** of an array. |
| `concat(array)` | Merges arrays into a **new** array. |
| `join(separator)` | Joins array elements into a **string**. |
| `toString()` | Converts an array into a **comma-separated string**. |

##### **Example**
```js
let fruits = [""Apple"", ""Banana"", ""Cherry"", ""Mango""];

let sliced = fruits.slice(1, 3); // [""Banana"", ""Cherry""]
let merged = fruits.concat([""Orange"", ""Grapes""]); // [""Apple"", ""Banana"", ""Cherry"", ""Mango"", ""Orange"", ""Grapes""]
let joined = fruits.join("" - ""); // ""Apple - Banana - Cherry - Mango""
let stringVersion = fruits.toString(); // ""Apple,Banana,Cherry,Mango""
```

---

#### **🔹 Iterating Over Elements**  
| Method | Description |
|--------|-------------|
| `forEach(testFunction)` | Calls a function for each element. |
| `some(testFunction)` | Returns `true` if **at least one** element passes a test. |
| `every(testFunction)` | Returns `true` if **all** elements pass a test. |

##### **Example**
```js
let numbers = [10, 20, 30, 40];

numbers.forEach(n =&gt; console.log(n)); // Logs all numbers

console.log(numbers.some(n =&gt; n &gt; 25)); // true (at least one number is &gt; 25)
console.log(numbers.every(n =&gt; n &gt; 5)); // true (all numbers are &gt; 5)
```

---

#### **🔹 Working with Iterators**  
| Method | Description |
|--------|-------------|
| `entries()` | Returns an **iterator** with `[index, value]` pairs. |
| `keys()` | Returns an **iterator** with **keys** (indexes). |
| `values()` | Returns an **iterator** with values. |

##### **Example**
```js
let fruits = [""Apple"", ""Banana"", ""Cherry""];

for (let [index, value] of fruits.entries()) {
  console.log(index, value);
}
// 0 ""Apple""
// 1 ""Banana""
// 2 ""Cherry""

for (let key of fruits.keys()) {
  console.log(key);
}
// 0, 1, 2

for (let value of fruits.values()) {
  console.log(value);
}
// ""Apple"", ""Banana"", ""Cherry""
```

---

### **📌 Key Takeaways**
✔ Use **`push()` / `pop()`** for adding/removing from the **end**.  
✔ Use **`unshift()` / `shift()`** for adding/removing from the **start**.  
✔ Use **`map()`** for **transforming** an array.  
✔ Use **`filter()`** for **selecting** elements.  
✔ Use **`reduce()`** to reduce to a **single value**.  
✔ Use **`sort()` with `(a, b) =&gt; a - b`** for **numeric sorting**.  
✔ Use **`slice()`** for extracting, and **`splice()`** for modifying elements.  
✔ Use **`forEach()` / `some()` / `every()`** for **iterating and testing** elements.  
✔ Use **`entries()` / `keys()` / `values()`** for **iterating key-value pairs**.

---

💡 **Arrays are one of JavaScript's most powerful data structures. Mastering these methods will help write cleaner and more efficient code! 🚀**"		
30	Array methods	The Spread Syntax	"### **The Spread (`...`) and Rest (`...`) Operator in JavaScript (ES6)**  

The `...` operator, introduced in ES6, allows for **cleaner code** and **simplifies** various operations.

---

### **1️⃣ Expanding Arrays with `...` (Spread Operator)**  
You can use `...` to **spread elements** from one array into another.

#### **Example: Merging Arrays**
```js
let first = ['foo', 'bar'];
let second = ['other foo', ...first, 'other bar'];

console.log(second); 
// [""other foo"", ""foo"", ""bar"", ""other bar""]
```
- The `...first` expands the elements of `first` into `second`.

---

### **2️⃣ Creating Immutable Objects Easily**  
The spread operator helps **copy and merge objects** while keeping them immutable.

#### **Example: Merging Objects**
```js
let first = { foo: 'foo' };
let zeta = { ...first, bar: 'bar' };

console.log(zeta); 
// { foo: ""foo"", bar: ""bar"" }
```
- `...first` copies properties from `first` into `zeta`, and then `bar` is added.

---

### **3️⃣ Function Arguments with `...` (Rest Operator)**  
When used in a **function parameter**, `...` is called the **rest operator**. It collects remaining arguments into an array.

#### **Example: Handling Multiple Arguments**
```js
function myFun(a, b, ...manyMoreArgs) {
  console.log(a); // ""one""
  console.log(b); // ""two""
  console.log(manyMoreArgs); // [""three"", ""four""]
}

myFun('one', 'two', 'three', 'four');
```
- `a` gets `""one""`, `b` gets `""two""`, and the rest go into `manyMoreArgs` as an array.

---

### **📌 Key Takeaways**
✔ **Use `...` to expand arrays** into new arrays.  
✔ **Use `...` to merge or copy objects** while keeping them immutable.  
✔ **Use `...` in function parameters** to gather multiple arguments as an array.  

This makes JavaScript **more flexible and cleaner**! 🚀"		
31	Array sort	Find the Highest (or Lowest) Array Value	"### **Finding the Highest and Lowest Values in an Array**  

Sorting an array **numerically** in **ascending or descending order** allows you to find the highest and lowest values.

---

### **1️⃣ Sorting to Find the Lowest &amp; Highest Value**  
```js
let points = [40, 100, 1, 5, 25, 10];

// Sort in ascending order (smallest to largest)
points.sort(function(a, b) { return a - b; });

console.log(""Lowest:"", points[0]); // 1
console.log(""Highest:"", points[points.length - 1]); // 100
```
- `sort(a, b) → a - b` ensures **numerical** sorting (default `sort()` sorts **as strings**).  

---

### **2️⃣ Sorting to Find the Highest Value**  
```js
points.sort(function(a, b) { return b - a; });

console.log(""Highest:"", points[0]); // 100
console.log(""Lowest:"", points[points.length - 1]); // 1
```
- `sort(b, a) → b - a` sorts **in descending order**.

---

### **3️⃣ Using `Math.max()` and `Math.min()` (Recommended for Performance)**  
Sorting is unnecessary for just finding min/max values. Instead, use `Math.max.apply()` or the **spread operator** (`...`).

```js
let points = [40, 100, 1, 5, 25, 10];

let max = Math.max(...points); // 100
let min = Math.min(...points); // 1

console.log(""Highest:"", max);
console.log(""Lowest:"", min);
```
- **Faster** than sorting, especially for large arrays.  

---

### **📌 Key Takeaways**
✔ **Use `Math.max(...array)` and `Math.min(...array)` for best performance.**  
✔ **Use `.sort((a, b) =&gt; a - b)` to sort numerically** (default `sort()` sorts lexicographically).  
✔ **Sorting is useful if you need a sorted array, but `Math.max()` is better for just finding the highest value.** 🚀"		
32	Comparisons	Comparison operators	"### **Comparison Operators in JavaScript**  

Comparison operators are used to compare values and return `true` or `false`.

| Operator  | Description |
|-----------|------------|
| `==`  | Equal to (compares **values**, but not types) |
| `===` | Strictly equal to (compares **both value and type**) |
| `!=`  | Not equal to (compares **values**, but not types) |
| `!==` | Strictly not equal (compares **both value and type**) |
| `&gt;`   | Greater than |
| `&lt;`   | Less than |
| `&gt;=`  | Greater than or equal to |
| `&lt;=`  | Less than or equal to |

---

### **1️⃣ `==` vs. `===` (Loose vs. Strict Equality)**  
```js
console.log(5 == ""5"");  // true  (loose equality, converts types)
console.log(5 === ""5""); // false (strict equality, different types)
```
- `==` allows **type coercion**, converting `""5""` to `5` before comparing.  
- `===` **does not allow type coercion**—values **must be identical** in both type and value.

---

### **2️⃣ `!=` vs. `!==` (Loose vs. Strict Inequality)**  
```js
console.log(5 != ""5"");  // false (loose inequality, values are equal)
console.log(5 !== ""5""); // true  (strict inequality, different types)
```
- `!=` converts `""5""` to `5`, so the comparison is `false`.  
- `!==` checks both type and value, so `""5""` and `5` are **not the same**.

---

### **3️⃣ Greater and Less Than Comparisons**  
```js
console.log(10 &gt; 5);   // true
console.log(10 &lt; 5);   // false
console.log(10 &gt;= 10); // true
console.log(10 &lt;= 9);  // false
```

---

### **📌 Key Takeaways**
✔ **Use `===` and `!==` for precise comparisons** (avoid unexpected type coercion).  
✔ **Use `==` and `!=` only when intentional type conversion is needed**.  
✔ **Use `&lt;`, `&gt;`, `&lt;=`, `&gt;=` for numerical comparisons**."		
33	Comparisons	Logical operators	"### **Logical Operators in JavaScript**  

Logical operators are used to combine or modify boolean values (`true` or `false`).  

| Operator  | Description |
|-----------|-------------|
| `&amp;&amp;` (AND) | Returns `true` if **both** conditions are `true`. |
| `||` (OR)  | Returns `true` if **at least one** condition is `true`. |
| `!` (NOT)  | Reverses the boolean value (`true` → `false`, `false` → `true`). |

---

### **1️⃣ `&amp;&amp;` (Logical AND)**
```js
console.log(true &amp;&amp; true);  // true
console.log(true &amp;&amp; false); // false
console.log(5 &gt; 3 &amp;&amp; 10 &lt; 20); // true (both conditions are true)
console.log(5 &gt; 3 &amp;&amp; 10 &gt; 20); // false (one condition is false)
```
- `&amp;&amp;` returns `true` **only if all conditions are true**.  
- If **one condition is false**, the whole expression is `false`.

---

### **2️⃣ `||` (Logical OR)**
```js
console.log(true || false);  // true
console.log(false || false); // false
console.log(5 &gt; 3 || 10 &gt; 20); // true (at least one condition is true)
console.log(5 &lt; 3 || 10 &gt; 20); // false (both conditions are false)
```
- `||` returns `true` **if at least one condition is true**.  
- It only returns `false` if **all conditions are false**.

---

### **3️⃣ `!` (Logical NOT)**
```js
console.log(!true);  // false
console.log(!false); // true
console.log(!(5 &gt; 3)); // false (negates `true`)
console.log(!(5 &lt; 3)); // true (negates `false`)
```
- `!` **flips** a boolean value (`true` → `false`, `false` → `true`).  

---

### **📌 Key Takeaways**
✔ **Use `&amp;&amp;` when all conditions must be `true`**.  
✔ **Use `||` when at least one condition should be `true`**.  
✔ **Use `!` to invert boolean values**."		
34	Comparisons	Conditional (ternary) operator (if...else)	"### **Ternary Operator (`? :`) in JavaScript**  

The **ternary operator** is a shorthand for `if...else` statements.  

#### **Syntax**  
```js
variable = (condition) ? value1 : value2;
```
- If **`condition` is true**, `variable` gets `value1`.  
- If **`condition` is false**, `variable` gets `value2`.  

---

### **Example 1: Basic Usage**
```js
let age = 20;
let canVote = (age &gt;= 18) ? ""Yes"" : ""No"";

console.log(canVote); // ""Yes""
```
- Since `age &gt;= 18` is `true`, `canVote` is assigned `""Yes""`.

---

### **Example 2: Nested Ternary**
```js
let score = 85;
let grade = (score &gt;= 90) ? ""A"" : 
            (score &gt;= 80) ? ""B"" : 
            (score &gt;= 70) ? ""C"" : ""F"";

console.log(grade); // ""B""
```
- Ternary operators can be **chained** for multiple conditions.

---

### **Example 3: Assigning Values Based on a Condition**
```js
let isMember = true;
let discount = isMember ? 10 : 0;

console.log(discount); // 10
```
- If `isMember` is `true`, `discount = 10`, otherwise `discount = 0`.

---

### **📌 Key Takeaways**  
✔ **Use the ternary operator for concise conditional expressions.**  
✔ **Use `if...else` for complex logic or multiple conditions.**  
✔ **Nested ternaries work but can reduce readability—use with caution.**"		
35	Conditions	The else...if statement	"### **`if...else if...else` Statement in JavaScript**  

The `if...else if...else` statement **executes different code blocks** based on multiple conditions.

---

### **📌 Syntax**
```js
if (condition1) {
    // Executes if condition1 is true
} else if (condition2) {
    // Executes if condition1 is false and condition2 is true
} else {
    // Executes if both condition1 and condition2 are false
}
```

---

### **🔹 Example 1: Checking Grades**
```js
let score = 75;

if (score &gt;= 90) {
    console.log(""Grade: A"");
} else if (score &gt;= 80) {
    console.log(""Grade: B"");
} else if (score &gt;= 70) {
    console.log(""Grade: C"");
} else {
    console.log(""Grade: F"");
}
```
**Output:** `""Grade: C""`

- The program **checks conditions in order**.  
- If `score &gt;= 90` is false, it moves to `score &gt;= 80`, and so on.

---

### **🔹 Example 2: Checking Age for Driving Eligibility**
```js
let age = 16;

if (age &gt;= 18) {
    console.log(""You can drive."");
} else if (age === 17) {
    console.log(""Almost there! Just one more year."");
} else {
    console.log(""You are too young to drive."");
}
```
**Output:** `""You are too young to drive.""`

---

### **📌 Key Takeaways**  
✔ **Use `if...else if...else` for multiple conditions.**  
✔ **Conditions are checked in order—once a condition is `true`, the rest are skipped.**  
✔ **The `else` block (optional) runs only if none of the conditions are met.**"		
36	Conditions	Conditional (ternary) operator (if...else)	"### **Ternary Operator (`? :`) in JavaScript**  

The **ternary operator** is a concise way to write `if...else` statements.

---

### **📌 Syntax**  
```js
variable = (condition) ? value1 : value2;
```
- If **`condition` is true**, `variable` is assigned `value1`.  
- If **`condition` is false**, `variable` is assigned `value2`.  

---

### **🔹 Example 1: Checking Voting Eligibility**  
```js
let age = 20;
let canVote = (age &gt;= 18) ? ""Yes"" : ""No"";

console.log(canVote); // ""Yes""
```
- If `age &gt;= 18` is **true**, `canVote` is `""Yes""`.  
- If `age &gt;= 18` is **false**, `canVote` is `""No""`.  

---

### **🔹 Example 2: Nested Ternary Operator**  
```js
let score = 85;
let grade = (score &gt;= 90) ? ""A"" : 
            (score &gt;= 80) ? ""B"" : 
            (score &gt;= 70) ? ""C"" : ""F"";

console.log(grade); // ""B""
```
- Works like multiple `if...else if...else` statements, but **less readable**.  

---

### **🔹 Example 3: Assigning Values Conditionally**  
```js
let isMember = true;
let discount = isMember ? 10 : 0;

console.log(discount); // 10
```
- If `isMember` is `true`, `discount = 10`.  
- If `isMember` is `false`, `discount = 0`.  

---

### **📌 Key Takeaways**  
✔ **Use the ternary operator for short conditional assignments.**  
✔ **For multiple conditions, `if...else` is more readable.**  
✔ **Nested ternaries work but can make code harder to understand.** 🚀"		
37	Switch	Switch example	"### **`switch` Statement in JavaScript**  

The `switch` statement is used to execute different blocks of code based on a variable's value.

---

### **📌 Syntax**
```js
switch (expression) {
    case value1:
        // Code block if expression === value1
        break;
    case value2:
        // Code block if expression === value2
        break;
    default:
        // Code block if none of the cases match
}
```
- The `break` statement **prevents fall-through** to the next case.
- The `default` case **executes if no cases match** (optional).

---

### **🔹 Example: Checking the Day of the Week**
```js
switch (new Date().getDay()) {
    case 4: // Thursday
    case 5: // Friday
        text = ""Soon it is Weekend"";
        break;
    case 0: // Sunday
    case 6: // Saturday
        text = ""It is Weekend"";
        break;
    default:
        text = ""Looking forward to the Weekend"";
}

console.log(text);
```
- If today is **Thursday (4) or Friday (5)** → `""Soon it is Weekend""`.  
- If today is **Saturday (6) or Sunday (0)** → `""It is Weekend""`.  
- Any other day → `""Looking forward to the Weekend""`.  

---

### **🔹 Example: Checking User Role**
```js
let role = ""admin"";

switch (role) {
    case ""admin"":
        console.log(""You have full access."");
        break;
    case ""editor"":
        console.log(""You can edit content."");
        break;
    case ""viewer"":
        console.log(""You can only view content."");
        break;
    default:
        console.log(""Invalid role."");
}
```
- `""admin""` → `""You have full access.""`  
- `""editor""` → `""You can edit content.""`  
- `""viewer""` → `""You can only view content.""`  
- Anything else → `""Invalid role.""`  

---

### **📌 Key Takeaways**  
✔ **Use `switch` when checking a variable against multiple exact values.**  
✔ **Use `break` to prevent fall-through (unless intended).**  
✔ **Use `default` for a fallback case.**  
✔ **For complex conditions, `if...else` is often more flexible.** 🚀"		
38	Loop for	Different kinds of loops	"### **JavaScript Looping Statements**  

Loops allow you to execute a block of code **multiple times**.

---

## **📌 1. `for` Loop (Fixed Repetitions)**
Loops through a block of code **a specific number of times**.

#### **Syntax:**
```js
for (initialization; condition; increment) {
    // Code to execute
}
```

#### **Example: Counting from 1 to 5**
```js
for (let i = 1; i &lt;= 5; i++) {
    console.log(i);
}
// Output: 1, 2, 3, 4, 5
```

---

## **📌 2. `for...in` Loop (Iterate Over Object Properties)**
Loops through the **properties (keys)** of an **object**.

#### **Syntax:**
```js
for (let key in object) {
    // Code to execute
}
```

#### **Example: Iterating Over Object Properties**
```js
let person = { name: ""Alice"", age: 25, city: ""New York"" };

for (let key in person) {
    console.log(key + "": "" + person[key]);
}
// Output:
// name: Alice
// age: 25
// city: New York
```
✅ **Best for iterating objects.**  

---

## **📌 3. `for...of` Loop (Iterate Over Values of Iterables)**
Loops through **values** of **iterable objects** (arrays, strings, maps, NodeLists, etc.).

#### **Syntax:**
```js
for (let value of iterable) {
    // Code to execute
}
```

#### **Example: Iterating Over an Array**
```js
let fruits = [""Apple"", ""Banana"", ""Cherry""];

for (let fruit of fruits) {
    console.log(fruit);
}
// Output:
// Apple
// Banana
// Cherry
```

#### **Example: Iterating Over a String**
```js
let word = ""Hello"";

for (let letter of word) {
    console.log(letter);
}
// Output: H, e, l, l, o
```
✅ **Best for iterating over arrays and strings.**  

---

## **📌 4. `while` Loop (Condition-Based Execution)**
Executes a block of code **while the condition is true**.

#### **Syntax:**
```js
while (condition) {
    // Code to execute
}
```

#### **Example: Counting Down from 5**
```js
let count = 5;

while (count &gt; 0) {
    console.log(count);
    count--;
}
// Output: 5, 4, 3, 2, 1
```
✅ **Useful when the number of iterations is unknown.**  

---

## **📌 5. `do...while` Loop (Executes at Least Once)**
Similar to `while`, but **always executes at least once**, even if the condition is false.

#### **Syntax:**
```js
do {
    // Code to execute
} while (condition);
```

#### **Example: Executing at Least Once**
```js
let num = 0;

do {
    console.log(""This runs at least once!"");
    num++;
} while (num &lt; 0);
```
**Output:** `""This runs at least once!""`  
✅ **Best when you want to ensure execution at least once.**  

---

### **📌 Summary of Loops**
| Loop | Best For |
|------|----------|
| `for` | Running a block **a set number of times** |
| `for...in` | Iterating over **object properties (keys)** |
| `for...of` | Iterating over **array values, strings, maps, NodeLists, etc.** |
| `while` | Repeating **while a condition is true** (unknown repetitions) |
| `do...while` | Running **at least once**, then while condition is true |

---

💡 **Choose the right loop based on your needs for better performance and readability! 🚀**"		
39	Loop while	Regular while	"### **`while` Loop in JavaScript**  

The `while` loop **executes a block of code repeatedly** **as long as a specified condition is `true`**.

---

### **📌 Syntax**
```js
while (condition) {
    // Code to execute
}
```
- **Before each iteration, the condition is checked.**
- If the condition is `true`, the code inside the block **executes**.
- If the condition is `false`, the loop **stops**.

---

### **🔹 Example 1: Counting from 1 to 5**
```js
let count = 1;

while (count &lt;= 5) {
    console.log(count);
    count++; // Increment to avoid infinite loop
}
```
**Output:**
```
1
2
3
4
5
```
- The loop runs while `count &lt;= 5`.
- **Each iteration increases `count`** to prevent an infinite loop.

---

### **🔹 Example 2: Loop Until User Input is Valid**
```js
let userInput;

while (!userInput) {
    userInput = prompt(""Enter something:""); // Keeps asking until input is not empty
}
console.log(""You entered:"", userInput);
```
- **Keeps asking for input until a non-empty value is entered**.

---

### **🔹 Example 3: Removing Array Elements**
```js
let fruits = [""Apple"", ""Banana"", ""Cherry""];

while (fruits.length &gt; 0) {
    console.log(fruits.pop()); // Removes and prints each fruit
}
```
**Output:**
```
Cherry
Banana
Apple
```
- Removes elements **one by one** until the array is empty.

---

### **📌 Key Takeaways**
✔ **Use `while` when the number of iterations is unknown**.  
✔ **Always modify the condition inside the loop** to prevent infinite loops.  
✔ **`while` is best for loops that depend on dynamic conditions** (e.g., user input, database queries, game logic). 🚀"		
40	Loop while	The do/while loop	"### **`while` Loop in JavaScript**  

The `while` loop **executes a block of code repeatedly** **as long as a specified condition is `true`**.

---

### **📌 Syntax**
```js
while (condition) {
    // Code block to execute
}
```
- The loop **evaluates the condition before each iteration**.  
- If the condition is **true**, the code inside the loop **executes**.  
- If the condition is **false**, the loop **stops**.  

---

### **🔹 Example 1: Counting from 1 to 5**
```js
let count = 1;

while (count &lt;= 5) {
    console.log(count);
    count++; // Increment to avoid an infinite loop
}
```
**Output:**
```
1
2
3
4
5
```
- The loop **keeps running while** `count &lt;= 5`.  
- `count++` **updates the variable**, preventing an **infinite loop**.  

---

### **🔹 Example 2: Keep Asking Until a Valid Input is Given**
```js
let userInput = """";

while (!userInput) {
    userInput = prompt(""Enter something:""); // Asks the user for input
}
console.log(""You entered:"", userInput);
```
- **Continues asking** until the user provides **non-empty input**.  

---

### **🔹 Example 3: Removing Elements from an Array**
```js
let tasks = [""Task 1"", ""Task 2"", ""Task 3""];

while (tasks.length &gt; 0) {
    console.log(""Processing:"", tasks.pop()); // Removes the last item
}
```
**Output:**
```
Processing: Task 3
Processing: Task 2
Processing: Task 1
```
- **Keeps removing elements** until the array is empty.  

---

### **📌 Key Takeaways**
✔ **Use `while` when the number of iterations is unknown**.  
✔ **Ensure the condition eventually becomes `false`** to avoid infinite loops.  
✔ **Best for loops that depend on user input, database queries, or changing conditions dynamically.** 🚀"		
41	Break and continue	Definition	"### **`break` and `continue` Statements in JavaScript**  

Both `break` and `continue` are **loop control statements** used to alter the flow of loops.

---

### **📌 `break` Statement (Exit the Loop)**
- The `break` statement **immediately stops** the loop and exits.
- Useful when you need to **stop execution based on a condition**.

#### **🔹 Example: Stop Looping When a Certain Value is Found**
```js
for (let i = 1; i &lt;= 10; i++) {
    if (i === 5) {
        break; // Stops loop when i = 5
    }
    console.log(i);
}
```
**Output:**
```
1
2
3
4
```
- When `i === 5`, the `break` statement **exits the loop completely**.

---

### **📌 `continue` Statement (Skip to Next Iteration)**
- The `continue` statement **skips the rest of the current iteration** and jumps to the next loop iteration.
- Useful when **certain conditions should be ignored** without stopping the loop.

#### **🔹 Example: Skip Even Numbers**
```js
for (let i = 1; i &lt;= 5; i++) {
    if (i % 2 === 0) {
        continue; // Skip even numbers
    }
    console.log(i);
}
```
**Output:**
```
1
3
5
```
- **When `i` is even (`2, 4`), `continue` skips that iteration.**

---

### **📌 Example: Using `break` and `continue` Together**
```js
for (let i = 1; i &lt;= 10; i++) {
    if (i === 8) {
        break; // Stop loop when i = 8
    }
    if (i % 2 === 0) {
        continue; // Skip even numbers
    }
    console.log(i);
}
```
**Output:**
```
1
3
5
7
```
- **`continue` skips even numbers (`2, 4, 6`).**
- **`break` stops execution completely when `i === 8`.**

---

### **📌 Key Takeaways**
✔ **Use `break` to completely exit a loop.**  
✔ **Use `continue` to skip a specific iteration and move to the next one.**  
✔ **Be careful when using `continue` in `while` loops**—ensure the loop variable still updates to avoid infinite loops. 🚀"		
42	Break and continue	Labels	"### **`break` and `continue` with Labels in JavaScript**  

JavaScript allows **labeled statements** with `break` and `continue`, which can be useful for controlling complex loops or code blocks.

---

## **📌 `continue` Statement**
- `continue` **can only skip one iteration** of a loop.
- It **cannot exit the entire loop** or skip multiple iterations at once.
- It **does not work** outside of loops.

#### **Example: Skipping Even Numbers**
```js
for (let i = 1; i &lt;= 5; i++) {
    if (i % 2 === 0) {
        continue; // Skip even numbers
    }
    console.log(i);
}
```
**Output:**
```
1
3
5
```
---

## **📌 `break` Statement (Without Label)**
- `break` **exits the nearest loop or `switch` statement**.
- It **does not** work outside of loops or `switch` blocks.

#### **Example: Stop Loop at 3**
```js
for (let i = 1; i &lt;= 5; i++) {
    if (i === 3) {
        break; // Stops the loop completely
    }
    console.log(i);
}
```
**Output:**
```
1
2
```
---

## **📌 `break` Statement (With Label)**
- A **labeled `break`** allows you to exit **any code block**, not just loops.
- It **can exit nested loops** or even **non-loop blocks**.

#### **Example: Breaking Out of a Labeled Code Block**
```js
var cars = [""BMW"", ""Volvo"", ""Saab"", ""Ford""];
let text = """";

list: {
    text += cars[0] + ""<br>""; // ""BMW""
    text += cars[1] + ""<br>""; // ""Volvo""
    break list; // Exits the labeled block immediately
    text += cars[2] + ""<br>""; // Skipped
    text += cars[3] + ""<br>""; // Skipped
}

console.log(text);
```
**Output:**
```
BMW
Volvo
```
- The **`break list;` statement exits the `list:` block**, so `""Saab""` and `""Ford""` are never added.  

---

## **📌 Using `break` with Nested Loops**
```js
outerLoop: for (let i = 1; i &lt;= 3; i++) {
    for (let j = 1; j &lt;= 3; j++) {
        if (i === 2 &amp;&amp; j === 2) {
            break outerLoop; // Exits BOTH loops
        }
        console.log(`i=${i}, j=${j}`);
    }
}
```
**Output:**
```
i=1, j=1
i=1, j=2
i=1, j=3
i=2, j=1
```
- **`break outerLoop;` exits the entire `outerLoop`, not just the inner loop.**

---

## **📌 Key Takeaways**
✔ **`continue` skips only one iteration of a loop** and **cannot be used outside of loops**.  
✔ **`break` exits only the nearest loop or `switch` by default**.  
✔ **Labeled `break` can exit nested loops or code blocks** for better control.  
✔ **Use `break labelName;` to exit a specific block or loop.** 🚀"		
43	Errors	Try and catch	"### **`try...catch` Statement in JavaScript**  

The `try...catch` statement is used to **handle errors** gracefully in JavaScript **without stopping script execution**.

---

### **📌 Syntax**
```js
try {
    // Code that may throw an error
} catch (err) {
    // Code to handle the error
}
```
- The **`try` block** contains code that **might cause an error**.  
- If an error occurs, execution jumps to the **`catch` block**.  
- The `catch` block **receives the error object (`err`)**, which provides information about the error.  

---

### **🔹 Example 1: Handling an Undefined Variable Error**
```js
try {
    console.log(x); // x is not defined (ReferenceError)
} catch (err) {
    console.log(""An error occurred:"", err.message);
}
```
**Output:**
```
An error occurred: x is not defined
```
- Without `try...catch`, JavaScript **would stop execution** due to the error.  
- The `catch` block **handles the error gracefully**, so the script continues.  

---

### **🔹 Example 2: Handling JSON Parsing Errors**
```js
let json = '{ ""name"": ""John"", ""age"": 30 }';

try {
    let user = JSON.parse(json);
    console.log(user.name); // ""John""
} catch (err) {
    console.log(""Invalid JSON format:"", err.message);
}
```
- If the JSON string is invalid (e.g., missing quotes), `JSON.parse()` throws an error.
- `catch` handles the error without crashing the program.

---

### **🔹 Example 3: Using `finally` (Optional)**
```js
try {
    let num = 10;
    console.log(num.toUpperCase()); // TypeError
} catch (err) {
    console.log(""Error:"", err.message);
} finally {
    console.log(""This runs no matter what."");
}
```
**Output:**
```
Error: num.toUpperCase is not a function
This runs no matter what.
```
- The **`finally` block always executes**, whether an error occurs or not.
- Useful for **cleanup actions** (e.g., closing a connection, resetting values).

---

### **📌 Key Takeaways**
✔ **Use `try...catch` to handle runtime errors without stopping execution.**  
✔ **The `catch` block receives an `error` object with details (`name`, `message`).**  
✔ **Use `finally` to run code regardless of whether an error occurs.**  
✔ **Essential for handling unpredictable errors, like API failures, JSON parsing, or user input issues.** 🚀"		
44	Errors	Throw	"### **`throw` and `finally` Statements in JavaScript**  

The `throw` statement allows you to **manually generate errors**, while the `finally` statement ensures that a block of code **always executes** regardless of an error.

---

## **📌 `throw` Statement (Custom Errors)**  

The `throw` statement is used to **manually throw exceptions** in JavaScript.  

#### **🔹 Syntax**  
```js
throw expression;
```
- The `expression` can be **a string, number, boolean, or an object**.  
- Usually combined with `try...catch` to **handle the thrown error**.

#### **🔹 Example: Throwing a String Error**
```js
function checkAge(age) {
    if (age &lt; 18) {
        throw ""Too young!""; // Throws a custom error
    }
    return ""Access granted"";
}

try {
    console.log(checkAge(16)); // This will throw an error
} catch (err) {
    console.log(""Error:"", err);
}
```
**Output:**  
```
Error: Too young!
```
✅ **Use `throw` to create custom validation errors.**

---

## **📌 Throwing an Object as an Error (`Error` Object)**
It’s best practice to use the built-in `Error` object instead of raw strings/numbers.

#### **🔹 Example: Throwing an `Error` Object**
```js
function divide(a, b) {
    if (b === 0) {
        throw new Error(""Cannot divide by zero"");
    }
    return a / b;
}

try {
    console.log(divide(10, 0)); // Throws an error
} catch (err) {
    console.log(""Error:"", err.message); // ""Cannot divide by zero""
}
```
✅ **The `Error` object provides better debugging support (`name`, `message`, `stack`).**

---

## **📌 `finally` Statement (Always Executes)**
The `finally` block runs **after `try...catch`** **whether an error occurs or not**.  

#### **🔹 Syntax**
```js
try {
    // Code that may throw an error
} catch (err) {
    // Handle error
} finally {
    // This block always runs
}
```

#### **🔹 Example: Cleaning Up Resources**
```js
try {
    console.log(""Trying..."");
    throw new Error(""Something went wrong!"");
} catch (err) {
    console.log(""Error:"", err.message);
} finally {
    console.log(""This always runs."");
}
```
**Output:**  
```
Trying...
Error: Something went wrong!
This always runs.
```
✅ **Use `finally` for cleanup tasks** like closing connections, resetting variables, or freeing memory.

---

## **📌 Key Takeaways**
✔ **Use `throw` to create custom errors.**  
✔ **Prefer `Error` objects (`new Error()`) for better debugging.**  
✔ **Use `finally` to run cleanup code, regardless of success or failure.**  
✔ **`finally` ensures critical code executes, even if an error occurs.** 🚀"		
45	Errors	Error object properties	"### **JavaScript `Error` Object Properties**  

The `Error` object provides useful properties for debugging and handling errors.

---

### **📌 Properties of the `Error` Object**  

| Property   | Description |
|------------|-------------|
| `name`     | Returns the error type (e.g., `""ReferenceError""`, `""TypeError""`). |
| `message`  | Returns a custom error message (a string). |

---

### **🔹 Example: Using `name` and `message`**
```js
try {
    let num = undefined;
    num.toUpperCase(); // This will cause a TypeError
} catch (err) {
    console.log(""Error Name:"", err.name);     // ""TypeError""
    console.log(""Error Message:"", err.message); // ""Cannot read properties of undefined""
}
```
**Output:**
```
Error Name: TypeError
Error Message: Cannot read properties of undefined
```
✅ **`err.name` tells the type of error.**  
✅ **`err.message` provides details about the error.**

---

### **🔹 Example: Throwing a Custom Error**
```js
function checkNumber(n) {
    if (n &lt; 0) {
        throw new Error(""Number must be positive"");
    }
    return Math.sqrt(n);
}

try {
    console.log(checkNumber(-5)); // Throws error
} catch (err) {
    console.log(`Error: ${err.name} - ${err.message}`);
}
```
**Output:**
```
Error: Error - Number must be positive
```
✅ **Using `new Error()` gives better debugging support.**

---

### **📌 Common Error Types in JavaScript**
| Error Type        | Description |
|-------------------|-------------|
| `Error`          | General error (base type). |
| `TypeError`      | Occurs when a value is not of the expected type. |
| `ReferenceError` | Occurs when trying to access an undefined variable. |
| `SyntaxError`    | Occurs when there's a syntax mistake in the code. |
| `RangeError`     | Occurs when a number is out of valid range. |

#### **🔹 Example: Different Error Types**
```js
try {
    nonExistentFunction(); // ReferenceError
} catch (err) {
    console.log(err.name); // ""ReferenceError""
}

try {
    JSON.parse(""{ invalid json }""); // SyntaxError
} catch (err) {
    console.log(err.name); // ""SyntaxError""
}
```

---

### **📌 Key Takeaways**
✔ **Use `err.name` to identify the error type.**  
✔ **Use `err.message` for a readable error description.**  
✔ **Use `throw new Error(""Custom message"")` for meaningful error handling.** 🚀"		
46	Errors	Error name values	"### **JavaScript Built-in Error Types**  

JavaScript provides several built-in error types, each representing a specific kind of error.

---

## **📌 List of JavaScript Error Types**  

| Error Type        | Description |
|-------------------|-------------|
| **`EvalError`**   | Occurs when there is an issue with the `eval()` function (**Deprecated** in modern JavaScript). |
| **`RangeError`**  | Occurs when a number is **outside the valid range** (e.g., calling a function with a bad parameter). |
| **`ReferenceError`** | Occurs when **a variable or function does not exist** in the current scope. |
| **`SyntaxError`** | Occurs when **JavaScript code has incorrect syntax** (e.g., missing brackets, quotes, etc.). |
| **`TypeError`**   | Occurs when a value is **not of the expected type** (e.g., calling a non-function as a function). |
| **`URIError`**    | Occurs when **`encodeURI()` or `decodeURI()`** functions are used incorrectly. |

---

## **🔹 Examples of Each Error Type**  

### **1️⃣ `EvalError` (Deprecated in Modern JavaScript)**
- `EvalError` is **rare** because `eval()` is not recommended.
- Modern JavaScript does **not** throw `EvalError` anymore.

#### **Example (Unlikely to Occur)**
```js
try {
    throw new EvalError(""Eval function error"");
} catch (err) {
    console.log(err.name + "": "" + err.message);
}
```

---

### **2️⃣ `RangeError` (Number Out of Range)**
Occurs when a number is **too large** or an **invalid argument** is used in a function.

#### **Example: Exceeding Maximum Call Stack**
```js
function recursive() {
    recursive(); // Infinite recursion
}

try {
    recursive();
} catch (err) {
    console.log(err.name + "": "" + err.message);
}
```
**Output:**  
```
RangeError: Maximum call stack size exceeded
```
✅ **Occurs when recursion runs indefinitely or when an invalid range is used (e.g., `new Array(-1)`).**

---

### **3️⃣ `ReferenceError` (Undefined Variable)**
Occurs when a variable or function is **not defined**.

#### **Example: Accessing an Undefined Variable**
```js
try {
    console.log(undeclaredVar); // Variable is not declared
} catch (err) {
    console.log(err.name + "": "" + err.message);
}
```
**Output:**  
```
ReferenceError: undeclaredVar is not defined
```
✅ **Occurs when trying to use a variable that does not exist.**

---

### **4️⃣ `SyntaxError` (Invalid Code Structure)**
Occurs when JavaScript **fails to parse** due to incorrect syntax.

#### **Example: Missing Parenthesis**
```js
try {
    eval(""console.log('Hello' ""); // Syntax error due to missing parenthesis
} catch (err) {
    console.log(err.name + "": "" + err.message);
}
```
**Output:**  
```
SyntaxError: Unexpected end of input
```
✅ **Occurs when there is an issue in the JavaScript syntax.**

---

### **5️⃣ `TypeError` (Wrong Data Type)**
Occurs when an **operation is performed on the wrong data type**.

#### **Example: Calling a Non-Function**
```js
try {
    let num = 5;
    num(); // Trying to call a number as a function
} catch (err) {
    console.log(err.name + "": "" + err.message);
}
```
**Output:**  
```
TypeError: num is not a function
```
✅ **Occurs when trying to access a property of `undefined`, calling a number as a function, etc.**

---

### **6️⃣ `URIError` (Invalid `encodeURI()` or `decodeURI()` Use)**
Occurs when **`encodeURI()` or `decodeURI()`** is used incorrectly.

#### **Example: Invalid URI Encoding**
```js
try {
    decodeURI(""%""); // % is an invalid URI component
} catch (err) {
    console.log(err.name + "": "" + err.message);
}
```
**Output:**  
```
URIError: URI malformed
```
✅ **Occurs when encoding or decoding a malformed URI.**

---

## **📌 Key Takeaways**
✔ **Use `try...catch` to handle errors gracefully.**  
✔ **Each error type has a specific cause and solution.**  
✔ **Avoid `eval()`, as `EvalError` is no longer used in modern JavaScript.**  
✔ **Use `typeof` and `try...catch` to prevent `ReferenceError` and `TypeError`.** 🚀"		
47	Scope	Variable scope	"### **JavaScript Local Scope (Function Scope)**  

- **Variables declared inside a function are local** to that function.
- **They cannot be accessed from outside the function.**

---

### **📌 Example: Local Scope**
```js
function myFunction() {
    var carName = ""Volvo""; // Local variable
    console.log(carName); // ✅ Accessible inside the function
}

myFunction();
console.log(carName); // ❌ Error: carName is not defined
```
**Output:**  
```
Volvo
Uncaught ReferenceError: carName is not defined
```
✅ **`carName` is accessible inside `myFunction()`, but not outside.**  
❌ **Trying to access it outside results in an error.**

---

### **📌 Local Scope with `let` and `const`**
- `var`, `let`, and `const` all have **local function scope** when declared inside a function.
- `let` and `const` also have **block scope**, meaning they are limited to `{}` blocks.

#### **Example: Using `let` and `const`**
```js
function anotherFunction() {
    let model = ""Tesla""; 
    const year = 2023; 
    console.log(model, year); // ✅ Accessible inside function
}

anotherFunction();
console.log(model); // ❌ Error: model is not defined
console.log(year);  // ❌ Error: year is not defined
```
✅ **`let` and `const` also follow local function scope rules.**

---

### **📌 Key Takeaways**
✔ **Variables inside a function are local and cannot be accessed outside.**  
✔ **`var`, `let`, and `const` follow function scope rules inside functions.**  
✔ **Use `let` or `const` instead of `var` for better scoping control.** 🚀"		
48	Scope	Automatically global	"### **JavaScript Global Variable Created Implicitly**  

- **If you assign a value to an undeclared variable, it automatically becomes global** (even if assigned inside a function).  
- This is **considered bad practice** because it can lead to **unintended global variables** and potential conflicts.  

---

### **📌 Example: Implicit Global Variable**
```js
function myFunction() {
    carName = ""Volvo""; // ❌ No `var`, `let`, or `const` → Becomes GLOBAL
}

myFunction();
console.log(carName); // ✅ ""Volvo"" (Accessible globally)
```
**Output:**  
```
Volvo
```
✅ **Even though `carName` was assigned inside the function, it became global.**  
❌ **This can cause unexpected behavior in large programs.**

---

### **📌 Preventing Implicit Global Variables**
#### **🔹 Use `use strict` to Avoid Accidental Globals**
```js
""use strict"";
function myFunction() {
    carName = ""Volvo""; // ❌ Error: carName is not defined
}

myFunction();
```
**Output:**
```
Uncaught ReferenceError: carName is not defined
```
✅ **`""use strict""` forces variable declarations (`let`, `const`, or `var`).**  
✅ **Prevents accidental global variables.**

---

### **📌 Correct Way to Declare Global Variables**
If you **intend** to create a global variable, declare it **properly**:

#### **🔹 Using `var` (Global Scope in `window` Object)**
```js
var carName = ""Volvo""; // Global variable
function myFunction() {
    console.log(carName); // ✅ Accessible inside function
}
myFunction();
console.log(carName); // ✅ Accessible globally
```

#### **🔹 Using `let` or `const` (Better Practice)**
```js
let carName = ""Volvo""; // Global variable (but not attached to `window`)
function myFunction() {
    console.log(carName);
}
myFunction();
console.log(carName);
```
✅ **`let` and `const` do not attach variables to the `window` object**, reducing the risk of accidental overrides.

---

### **📌 Key Takeaways**
✔ **Assigning a value to an undeclared variable creates a global variable (bad practice).**  
✔ **Use `""use strict""` to prevent accidental globals.**  
✔ **Always declare variables explicitly with `let`, `const`, or `var`.** 🚀"		
49	Scope	Strict mode	"### **Strict Mode Prevents Implicit Global Variables**  

In **Strict Mode (`""use strict""`)**, **JavaScript does not allow assigning a value to an undeclared variable**, preventing **accidental global variables**.

---

### **📌 Example: Implicit Global Variable (Without Strict Mode)**
```js
function myFunction() {
    carName = ""Volvo""; // ❌ No `var`, `let`, or `const` → Becomes GLOBAL
}

myFunction();
console.log(carName); // ✅ ""Volvo"" (Global Variable)
```
**Output:**
```
Volvo
```
❌ **`carName` was automatically created as a global variable, even inside the function.**  
⚠ **This can lead to unintended global variables and difficult-to-debug issues.**  

---

### **📌 Example: Preventing Implicit Globals with `""use strict""`**
```js
""use strict"";

function myFunction() {
    carName = ""Volvo""; // ❌ ERROR: carName is not declared
}

myFunction();
```
**Output:**
```
Uncaught ReferenceError: carName is not defined
```
✅ **JavaScript throws an error because `carName` was not declared explicitly.**  
✅ **Prevents accidental global variables.**  

---

### **📌 Correct Way to Declare Global Variables in Strict Mode**
If you **want a global variable**, explicitly declare it using `var`, `let`, or `const`.

#### **🔹 Using `var` (Attaches to `window` in browsers)**
```js
""use strict"";
var carName = ""Volvo""; // ✅ Properly declared global variable

function myFunction() {
    console.log(carName); // ✅ Accessible inside function
}
myFunction();
console.log(carName); // ✅ Accessible globally
```

#### **🔹 Using `let` or `const` (Better Practice)**
```js
""use strict"";
let carName = ""Volvo""; // ✅ Properly declared global variable

function myFunction() {
    console.log(carName);
}
myFunction();
console.log(carName);
```
✅ **`let` and `const` create a global variable, but do not attach it to `window`**, reducing accidental overrides.  

---

### **📌 Key Takeaways**
✔ **Strict Mode (`""use strict""`) prevents implicit global variables.**  
✔ **Assigning a value to an undeclared variable throws an error in strict mode.**  
✔ **Always declare variables explicitly with `let`, `const`, or `var`.**  
✔ **Use `""use strict""` at the beginning of your script for safer JavaScript execution.** 🚀"		
50	Scope	Function arguments	"### **Function Arguments (Parameters) are Local Variables**  

- **Function parameters behave like local variables** inside the function.  
- **They are only accessible within the function scope**.  

---

### **📌 Example: Function Parameters as Local Variables**
```js
function greet(name) {
    console.log(""Hello, "" + name); // `name` is a local variable
}

greet(""Alice""); // ✅ Works inside function
console.log(name); // ❌ Error: name is not defined
```
**Output:**
```
Hello, Alice
Uncaught ReferenceError: name is not defined
```
✅ **`name` is accessible inside `greet()` but not outside**.  

---

### **📌 Example: Function Parameters Do Not Affect Global Variables**
```js
let user = ""John"";

function changeUser(user) {
    user = ""Alice""; // This only changes the local `user` variable, not the global one
    console.log(""Inside function:"", user);
}

changeUser(user);
console.log(""Outside function:"", user);
```
**Output:**
```
Inside function: Alice
Outside function: John
```
✅ **Changes inside the function do not affect the global variable `user`**.

---

### **📌 Example: Multiple Parameters**
```js
function sum(a, b) {
    return a + b; // `a` and `b` are local variables
}

console.log(sum(5, 3)); // ✅ 8
console.log(a); // ❌ Error: a is not defined
```
**Output:**
```
8
Uncaught ReferenceError: a is not defined
```
✅ **`a` and `b` exist only inside `sum()` and cannot be used outside.**  

---

### **📌 Key Takeaways**
✔ **Function parameters are local variables, accessible only inside the function.**  
✔ **Modifying a parameter inside a function does not affect global variables.**  
✔ **Trying to access parameters outside the function results in an error.** 🚀"		
51	Hoisting	Definition	"### **Always Declare Variables at the Top (Hoisting in JavaScript)**  

#### **📌 What is Hoisting?**  
- **Hoisting is JavaScript’s default behavior** where **declarations** (`var` functions) are moved to the **top of their scope**.  
- However, **only declarations are hoisted, not initializations**.  
- **`let` and `const` are NOT hoisted the same way as `var`.**  

---

## **1️⃣ Example of `var` Hoisting**
```js
x = 5;  // ✅ Works because `var x;` is hoisted
console.log(x); // Output: 5
var x;
```
✅ **JavaScript hoists `var x;` to the top, so this works.**  

---

## **2️⃣ Hoisting Moves Declarations, NOT Assignments**
```js
console.log(y); // ❌ Output: undefined
var y = 10;
console.log(y); // ✅ Output: 10
```
**What happens under the hood:**
```js
var y;      // Hoisted to the top
console.log(y); // undefined
y = 10;     // Initialization happens here
console.log(y); // 10
```
❌ **Only the declaration (`var y;`) is hoisted, but `y = 10;` stays where it is.**  

---

## **3️⃣ `let` and `const` are NOT Hoisted Like `var`**
```js
console.log(z); // ❌ ReferenceError: Cannot access 'z' before initialization
let z = 20;
```
❌ **`let` and `const` do not allow access before declaration!**  

**What happens under the hood:**
```js
// ❌ Variables declared with `let` and `const` exist in a ""Temporal Dead Zone"" until they are initialized.
let z; // Not accessible before this line
console.log(z); // ReferenceError
z = 20;
```
✅ **Always declare `let` and `const` before using them!**  

---

## **4️⃣ Function Hoisting**
Functions **declared with `function`** are hoisted, meaning you can call them **before they are declared**.

```js
hello(); // ✅ Works even before declaration

function hello() {
    console.log(""Hello, world!"");
}
```
✅ **Functions are fully hoisted, including their body.**

❌ **Function Expressions are NOT hoisted!**
```js
greet(); // ❌ ReferenceError: Cannot access 'greet' before initialization
const greet = function() {
    console.log(""Hello!"");
};
```
✅ **Only function declarations (`function name() {}`) are hoisted, not function expressions (`const name = function() {}`)**.

---

## **📌 Key Takeaways**
✔ **Declare all variables (`var`, `let`, `const`) at the top of their scope.**  
✔ **Only `var` is hoisted with `undefined`, not `let` or `const`.**  
✔ **Function declarations (`function name() {}`) are hoisted completely.**  
✔ **Function expressions (`const name = function() {}`) are NOT hoisted.** 🚀"		
52	Hoisting	JavaScript Initializations and hoisting	"### **JavaScript Only Hoists Declarations, Not Initializations**  

- **Hoisting** is JavaScript's default behavior of moving **declarations** to the top of their scope.  
- **Only variable/function declarations are hoisted, NOT their initializations.**  

---

### **📌 Example 1: `var` Hoisting (Declaration Moves Up, Initialization Stays in Place)**
```js
console.log(x); // ❌ Output: undefined (x is hoisted but not assigned yet)
var x = 10;
console.log(x); // ✅ Output: 10
```
✅ **What happens under the hood:**
```js
var x;       // Hoisted to the top with an initial value of `undefined`
console.log(x); // `undefined`
x = 10;      // Initialization happens here
console.log(x); // `10`
```
- **`var x;` is hoisted, but `x = 10;` is not!**
- **Accessing `x` before initialization returns `undefined`.**

---

### **📌 Example 2: `let` and `const` Do NOT Hoist Like `var`**
```js
console.log(y); // ❌ ReferenceError: Cannot access 'y' before initialization
let y = 20;
console.log(y);
```
✅ **What happens under the hood:**
```js
// `let` exists in the ""Temporal Dead Zone"" until it is initialized
let y; // Declared here but NOT hoisted in the same way as `var`
console.log(y); // ❌ Error
y = 20;
console.log(y);
```
- **Unlike `var`, accessing `let` or `const` before declaration throws an error!**  
- This behavior prevents **bugs caused by using variables before they are properly defined**.  

---

### **📌 Example 3: Function Declarations are Fully Hoisted**
```js
greet(); // ✅ Works before declaration

function greet() {
    console.log(""Hello!"");
}
```
✅ **Function declarations are completely hoisted, including their body!**  

---

### **📌 Example 4: Function Expressions are NOT Hoisted**
```js
sayHello(); // ❌ ReferenceError: Cannot access 'sayHello' before initialization

const sayHello = function() {
    console.log(""Hello!"");
};
```
- Function expressions (`const func = function() {}`) **are NOT hoisted**.
- **Only function declarations (`function func() {}`) are hoisted**.

---

## **📌 Key Takeaways**
✔ **JavaScript only hoists variable declarations (`var x;`), NOT their assignments (`x = 10;`).**  
✔ **`var` variables are hoisted with an initial value of `undefined`.**  
✔ **`let` and `const` do not allow access before declaration (Temporal Dead Zone).**  
✔ **Function declarations are fully hoisted, but function expressions are NOT.** 🚀"		
53	Hoisting	Hoisting and the let and const variable declaration	"### **Variables Declared with `let` and `const` are Not Hoisted the Same Way as `var`**  

#### **📌 Key Differences:**
| Variable Type | Hoisted? | Accessible Before Declaration? | Initial Value Before Declaration? |
|--------------|---------|-------------------------------|-----------------------------------|
| `var`        | ✅ Yes  | ✅ Yes (but `undefined`)      | `undefined`                      |
| `let`        | ⚠️ Partially | ❌ No (Throws an error)  | ❌ No initial value (Temporal Dead Zone) |
| `const`      | ⚠️ Partially | ❌ No (Throws an error)  | ❌ No initial value (Temporal Dead Zone) |

---

## **1️⃣ `var` is Hoisted with `undefined`**
```js
console.log(a); // ✅ Output: undefined (Hoisted)
var a = 5;
console.log(a); // ✅ Output: 5
```
✅ **`var` is hoisted, but only its declaration (`var a;`), not the assignment (`a = 5;`).**  
✅ **Accessing `a` before initialization returns `undefined`.**

---

## **2️⃣ `let` and `const` are in the ""Temporal Dead Zone"" (TDZ)**
```js
console.log(b); // ❌ ReferenceError: Cannot access 'b' before initialization
let b = 10;
console.log(b);
```
❌ **Unlike `var`, `let` does NOT allow access before declaration.**  
❌ **Accessing `b` before declaration throws a `ReferenceError`.**  

✅ **This behavior is called the *Temporal Dead Zone (TDZ)*—the variable exists but is inaccessible until initialized.**  

---

## **3️⃣ `const` Works the Same Way as `let`, But Requires Initialization**
```js
console.log(c); // ❌ ReferenceError: Cannot access 'c' before initialization
const c = 20;
console.log(c);
```
❌ **`const` variables must be initialized at the time of declaration.**  
❌ **Just like `let`, it is in the ""Temporal Dead Zone"" until it's declared.**  

✅ **Unlike `let`, `const` cannot be reassigned after initialization.**

---

## **4️⃣ Function Declarations are Fully Hoisted**
```js
hello(); // ✅ Works before declaration

function hello() {
    console.log(""Hello!"");
}
```
✅ **Function declarations are fully hoisted, including their body.**

---

## **5️⃣ Function Expressions are NOT Hoisted**
```js
greet(); // ❌ ReferenceError: Cannot access 'greet' before initialization

const greet = function() {
    console.log(""Hi!"");
};
```
❌ **Function expressions (`const func = function() {}`) follow the same hoisting rules as `let` and `const`.**  

---

### **📌 Key Takeaways**
✔ **`let` and `const` are NOT hoisted like `var`.**  
✔ **They exist in the ""Temporal Dead Zone"" until the declaration line is reached.**  
✔ **Accessing them before declaration throws a `ReferenceError`.**  
✔ **Always declare `let` and `const` at the top of their scope to avoid TDZ issues.** 🚀"		
54	Strict mode	Things not allowed in Strict Mode	"### **Strict Mode (`""use strict""`) in JavaScript**  

The `""use strict""` directive enforces **safer coding practices** by **disabling certain problematic JavaScript behaviors**.  

✅ **Prevents accidental global variables**  
✅ **Restricts certain bad practices**  
✅ **Improves debugging and performance**  

---

## **📌 1. Using a Variable or Object Without Declaring It is Not Allowed**  
```js
""use strict"";
x = 10; // ❌ ReferenceError: x is not defined
console.log(x);
```
❌ **Without `var`, `let`, or `const`, `x` becomes an implicit global variable.**  
✅ **Strict mode prevents this mistake.**

---

## **📌 2. Deleting a Variable, Object, or Function is Not Allowed**  
```js
""use strict"";
var person = { name: ""John"" };
delete person; // ❌ SyntaxError: Delete of an unqualified identifier in strict mode.
```
❌ **Deleting variables or objects is not allowed in strict mode.**  
✅ **Use `delete` only for object properties.**
```js
delete person.name; // ✅ Allowed
```

---

## **📌 3. Duplicating Parameter Names is Not Allowed**  
```js
""use strict"";
function myFunction(a, a) { // ❌ SyntaxError: Duplicate parameter name
    console.log(a);
}
```
❌ **Strict mode prevents duplicate function parameters, which can cause confusion.**  

✅ **Fix: Use unique parameter names.**
```js
function myFunction(a, b) {
    console.log(a, b);
}
```

---

## **📌 4. Writing to a Read-Only Property is Not Allowed**  
```js
""use strict"";
const obj = Object.freeze({ name: ""Alice"" });

obj.name = ""Bob""; // ❌ TypeError: Cannot assign to read-only property 'name'
```
❌ **Strict mode prevents modification of frozen objects.**  

✅ **Fix: Remove `Object.freeze()` or avoid modifying constant objects.**

---

## **📌 5. Writing to a Get-Only Property is Not Allowed**  
```js
""use strict"";
let obj = {
    get name() { return ""John""; }
};

obj.name = ""Alice""; // ❌ TypeError: Cannot set property 'name' of #<object> which has only a getter
```
❌ **You cannot assign values to properties that only have a getter.**  
✅ **Fix: Use a setter if you need to modify the property.**

---

## **📌 6. `""use strict""` Must Be at the Beginning of a Script or Function**  
✅ **Correct usage at the top of a script:**  
```js
""use strict"";
let x = 10;
```
✅ **Correct usage inside a function:**  
```js
function myFunction() {
    ""use strict"";
    let y = 20;
}
```
❌ **Strict mode is ignored if placed incorrectly:**  
```js
let x = 10;
""use strict""; // ❌ Does NOT enable strict mode!
```
✅ **Always place `""use strict"";` at the very beginning of a script or function.**

---

### **📌 Key Takeaways**
✔ **`""use strict""` prevents common coding mistakes.**  
✔ **It must be at the beginning of a script or function.**  
✔ **Disallows undeclared variables, duplicate parameters, and modifying protected properties.**  
✔ **Improves debugging and helps write safer JavaScript.** 🚀</object>"		
55	This keyword	Core Concept &amp; Default Bindings	"**What is `this`?**
* The `this` keyword refers to the **object** that is executing the current piece of code.
* Its value is determined dynamically at **runtime**, based on *how* a function is called (the ""invocation context"").

**Default Bindings (When `this` isn't set by other rules):**

1.  **Global Context:**
    * Outside any function, `this` refers to the **global object**.
    * Browser: `window`
    * Node.js: `global`
    * **Strict Mode (`""use strict"";`)**: `this` is `undefined` globally.
    ```js
    // Browser, non-strict mode
    console.log(this === window); // true

    // Browser, strict mode
    ""use strict"";
    console.log(this); // undefined
    ```

2.  **Regular Function Call (Not as a method):**
    * When a standard function is called directly (e.g., `myFunction()`), `this` defaults to the **global object** (non-strict) or `undefined` (strict).
    ```js
    function showThis() {
      console.log(this);
    }

    // Browser, non-strict mode
    showThis(); // logs `window`

    // Browser, strict mode
    ""use strict"";
    function showThisStrict() {
      console.log(this);
    }
    showThisStrict(); // logs `undefined`
    ```
"		
56	This keyword	Methods, Constructors &amp; Classes	"**Object-Oriented Contexts:**

1.  **Object Method:**
    * When a function is called *as a method* of an object (e.g., `obj.method()`), `this` refers to the **object the method was called on**.
    ```js
    const person = {
      name: ""Alice"",
      greet: function() {
        // 'this' refers to the 'person' object
        console.log(`Hello, ${this.name}`);
      }
    };
    person.greet(); // Output: Hello, Alice
    ```

2.  **Constructor Function:**
    * When a function is called with the `new` keyword (e.g., `new Constructor()`), `this` refers to the **newly created object instance**.
    ```js
    function Car(make) {
      // 'this' refers to the new Car instance
      this.make = make;
    }
    const myCar = new Car('Toyota');
    console.log(myCar.make); // Output: Toyota
    ```

3.  **Class Methods:**
    * Inside instance methods of a class, `this` refers to the **instance of the class**.
    ```js
    class Dog {
      constructor(name) {
        this.name = name;
      }
      bark() {
        // 'this' refers to the Dog instance (e.g., 'fido')
        console.log(`${this.name} says woof`);
      }
    }
    const fido = new Dog('Fido');
    fido.bark(); // Output: Fido says woof
    "		
57	This keyword	Arrow Functions, Event Listeners &amp; Explicit Binding	"**Special Contexts &amp; Manual Control:**

1.  **Arrow Functions (`=&gt;`):**
    * Arrow functions **do not have their own `this` binding**.
    * They inherit `this` **lexically** from their surrounding (parent) scope at the time they are *defined*.
    ```js
    const myObj = {
      value: 42,
      getValueRegular: function() { return this.value; }, // 'this' is myObj
      getValueArrow: () =&gt; { return this.value; } // 'this' is inherited (e.g., window/undefined)
    };
    console.log(myObj.getValueRegular()); // 42
    console.log(myObj.getValueArrow());   // undefined (in non-strict browser global scope)
    ```

2.  **DOM Event Listeners:**
    * In a regular function used as an event handler, `this` is set to the **element the event listener is attached to**.
    * *Caveat:* If you use an *arrow function*, `this` will be inherited from the surrounding scope, *not* the element.
    ```js
    buttonElement.addEventListener('click', function() {
      // 'this' refers to buttonElement
      console.log(this.id);
    });

    buttonElement.addEventListener('mouseover', () =&gt; {
      // 'this' refers to the scope where addEventListener was called, NOT the button
      console.log(this);
    });
    ```

3.  **Explicit Binding (`call()`, `apply()`, `bind()`):**
    * These methods allow you to **manually set the value of `this`** for a function call, overriding the default rules.
    ```js
    function introduce(greeting) {
      console.log(`${greeting}, I am ${this.name}`);
    }
    const user = { name: 'Bob' };

    // Set 'this' to 'user' for this specific call
    introduce.call(user, 'Hi'); // Output: Hi, I am Bob
    introduce.apply(user, ['Hello']); // Output: Hello, I am Bob

    // Create a new function where 'this' is permanently bound to 'user'
    const introduceBob = introduce.bind(user);
    introduceBob('Good morning'); // Output: Good morning, I am Bob
    ```"		
58	This keyword	Using 'this' in a Constructor Function	"**Purpose in Constructors:**
* Inside a constructor function (a function intended to be called with `new`), `this` refers to the **new object instance being created**.
* It's used to assign initial **properties** and **methods** to that new object based on the arguments passed to the constructor.

**How it Works:**
When you use `new ConstructorFunction(args...)`:
1.  A new empty object `{}` is created.
2.  This new object is set as the `this` context for the constructor function's execution.
3.  The constructor function runs, assigning properties/methods to `this`.
4.  The new object (now populated via `this`) is implicitly returned (unless the constructor explicitly returns a different *object*).

**Example:**
```js
function Vehicle(type, wheels) {
  // 'this' refers to the new object instance (e.g., myBike)
  this.type = type;
  this.wheels = wheels;

  this.getInfo = function() {
    return `Type: ${this.type}, Wheels: ${this.wheels}`;
  };
}

// 'new' sets up the 'this' context inside Vehicle
const myBike = new Vehicle('Bicycle', 2);

console.log(myBike.type); // Output: Bicycle
console.log(myBike.getInfo()); // Output: Type: Bicycle, Wheels: 2
```
**Key Point:** The `new` keyword is essential for establishing `this` correctly within the constructor. Without `new`, `this` would follow the rules for a regular function call (usually `window` or `undefined`).
"		
59	Let	Definition	"Introduced in **ES6 (2015)**, `let` is a modern way to declare variables in JavaScript.

✨ **Main Feature: Block Scope**
* Variables declared with `let` exist **only** within the code block (`{ ... }`) where they are defined.
    ```js
    if (true) {
      let message = ""Hello!""; // Scoped to this 'if' block
      console.log(message); // ✅ Output: Hello!
    }
    // console.log(message); // ❌ ReferenceError: message is not defined here
    ```

🆚 **Key Differences from `var`:**
1.  **Scope:** `let` = **Block Scope** (`{}`); `var` = Function Scope.
2.  **Redeclaration:** `let` **cannot** be redeclared in the *same* scope; `var` *can*.
    ```js
    let x = 10;
    // let x = 20; // ❌ SyntaxError: 'x' has already been declared
    var y = 10;
    var y = 20; // ✅ Allowed (but often bad practice)
    ```
3.  **Hoisting &amp; TDZ:** `let` variables are hoisted but enter a **Temporal Dead Zone (TDZ)** – they cannot be accessed before their declaration line. `var` variables are hoisted and initialized to `undefined`.
    ```js
    // console.log(a); // ❌ ReferenceError: Cannot access 'a' before initialization (TDZ)
    let a = 5;

    console.log(b); // ✅ Output: undefined
    var b = 5;
    ```

💡 **Recommendation:** Prefer `let` over `var` in modern JavaScript for clearer scoping rules and preventing common errors.
"		
60	Let	Redeclaring variables	"🎯 **Rule:** You **cannot** redeclare the *same* `let` variable within the *same* scope.

🧱 **Block Scope Interaction:**
* Declaring a `let` variable inside a block (`{...}`) creates a **new, separate variable**, even if it shares a name with a variable outside the block.
* This inner variable **shadows** the outer one within the block but does **not** affect the outer variable's value.

**Example:**
```js
let score = 100; // Outer scope variable

if (true) {
  let score = 50; // ✨ New variable, scoped only to this 'if' block
  console.log(""Inside block:"", score); // ✅ Output: 50
}

console.log(""Outside block:"", score); // ✅ Output: 100 (Outer variable is unchanged)
```

🆚 **Contrast with `var`:** Redeclaring `var` inside a block *does* affect the outer variable because `var` doesn't have block scope.
```js
var points = 10;
{
  var points = 20; // This overwrites the outer 'points'
  console.log(""Inside:"", points); // Output: 20
}
console.log(""Outside:"", points); // ❌ Output: 20
```

🗝️ **Key Point:** `let` respects block boundaries, allowing safe variable shadowing without unintentional side effects on outer scopes.
"		
61	Let	Loop scope	"🔄 **`let` in Loops:**
* When `let` declares a loop control variable (e.g., `for (let i = 0; ...)`), that variable is **scoped only to the loop block**.

👀 **Visibility:**
* The loop variable (`i`) exists *only* within the loop's body (`{...}`) and its control block (`(...)`).
* It **cannot** be accessed after the loop finishes.

**Example:**
```js
for (let i = 0; i &lt; 3; i++) {
  console.log(""Inside loop:"", i); // ✅ 0, 1, 2
}
// console.log(""After loop:"", i); // ❌ ReferenceError: i is not defined
```

✨ **Iteration Binding:** For `for` loops, `let` effectively creates a *new binding* (a separate instance) of the variable for each iteration. This is important for closures.

🆚 **Contrast with `var`:** `var` declared in a loop ""leaks"" into the surrounding function or global scope.
```js
for (var j = 0; j &lt; 3; j++) { /* ... */ }
console.log(""After loop:"", j); // ✅ Output: 3 (Variable 'j' leaked out)
```

👍 **Benefit:** Use `let` in loops to prevent variable leakage and ensure the loop variable doesn't interfere with the surrounding code.
"		
62	Let	Function scope	"**Function Scope:**
* Like `var`, variables declared with `let` *inside* a function are **local to that function**.
* They cannot be accessed from outside the function.

```js
function calculate() {
  let result = 10 * 5; // Local to the 'calculate' function
  console.log(result); // ✅ Output: 50
}
calculate();
// console.log(result); // ❌ ReferenceError: result is not defined
```

🧱 **Block Scope *Within* Functions:**
* **Crucially**, *unlike* `var`, `let` variables *also* respect **block scope (`{...}`)** *inside* a function.

**Example:**
```js
function processData(isValid) {
  let status = ""Processing""; // Function-scoped

  if (isValid) {
    let message = ""Data is valid""; // ✨ Block-scoped to the 'if' block
    console.log(message); // ✅ Access works here
  } else {
    let error = ""Invalid data""; // ✨ Block-scoped to the 'else' block
    console.log(error); // ✅ Access works here
  }

  console.log(status); // ✅ Access works ('status' is function-scoped)
  // console.log(message); // ❌ ReferenceError: message is not defined here
  // console.log(error); // ❌ ReferenceError: error is not defined here
}
processData(true);
```

🗝️ **Key Distinction:** `let` provides both **function scope** AND **block scope**, making variable visibility more granular and predictable within functions compared to `var` (which only has function scope).
"		
63	Const	Definition	"### **`const` vs `let`: Similarities and Differences**  

- **`const` behaves like `let` in terms of scope** (both are block-scoped).  
- **The key difference**: Variables declared with `const` **cannot be reassigned**.  
- **However, objects and arrays declared with `const` can have their properties modified**.  

---

## **📌 Example: `const` Cannot Be Reassigned**
```js
const x = 10;
x = 20; // ❌ TypeError: Assignment to constant variable
```
❌ **Once assigned, `const` variables cannot be reassigned.**  

✅ **However, modifying object properties is allowed.**  

---

## **📌 Example: Modifying a `const` Object**
```js
const person = { name: ""Alice"", age: 25 };

// ✅ You can modify properties
person.age = 30;  
console.log(person.age); // ✅ 30

// ❌ You CANNOT reassign the whole object
person = { name: ""Bob"", age: 40 }; // ❌ TypeError
```
✅ **You can change object properties but not reassign the object itself.**  

---

## **📌 Example: Modifying a `const` Array**
```js
const fruits = [""Apple"", ""Banana""];

// ✅ You can modify elements
fruits[0] = ""Mango"";  
console.log(fruits); // ✅ [""Mango"", ""Banana""]

// ✅ You can push new elements
fruits.push(""Cherry"");
console.log(fruits); // ✅ [""Mango"", ""Banana"", ""Cherry""]

// ❌ You CANNOT reassign the whole array
fruits = [""Orange"", ""Grapes""]; // ❌ TypeError
```
✅ **Elements inside a `const` array can be changed, but you cannot reassign the entire array.**  

---

## **📌 Summary: `const` vs `let`**
| Feature        | `let`  | `const` |
|--------------|--------|--------|
| **Block Scope** | ✅ Yes | ✅ Yes |
| **Reassignment** | ✅ Allowed | ❌ Not Allowed |
| **Modifying Objects** | ✅ Yes | ✅ Yes (but cannot reassign) |
| **Modifying Arrays** | ✅ Yes | ✅ Yes (but cannot reassign) |
| **Hoisting** | ✅ Hoisted (TDZ) | ✅ Hoisted (TDZ) |

---

## **📌 Key Takeaways**
✔ **`const` prevents reassignment, but allows modifying objects and arrays.**  
✔ **`let` and `const` both have block scope (`{}`).**  
✔ **Use `const` by default unless reassignment is needed, then use `let`.** 🚀"		
64	Arrow functions	Syntax &amp; Implicit Return	"Arrow functions (`=&gt;`) offer a more concise syntax for writing function expressions, introduced in ES6.

**Syntax Comparison:**

* **Regular Function Expression:**
    ```js
    const greet = function(name) {
      return ""Hello "" + name;
    };
    ```
* **Arrow Function Equivalent:**
    ```js
    const greet = name =&gt; ""Hello "" + name;
    ```

✨ **Key Syntax Rules:**

1.  **Single Parameter:** Parentheses `()` are optional.
    ```js
    const square = x =&gt; x * x;
    ```
2.  **Multiple/No Parameters:** Parentheses `()` are required.
    ```js
    const sum = (a, b) =&gt; a + b;
    const sayHi = () =&gt; ""Hi!"";
    ```
3.  **Single Expression Body:** Curly braces `{}` and the `return` keyword are optional (implicit return).
    ```js
    const multiply = (a, b) =&gt; a * b; // Implicit return
    ```
4.  **Multi-Statement Body:** Curly braces `{}` and an explicit `return` are required.
    ```js
    const complexCalc = (a, b) =&gt; {
      const intermediate = a + b;
      return intermediate / 2; // Explicit return needed
    };
    ```

&lt;0xF0&gt;&lt;0x9F&gt;&lt;0xAA&gt;&lt;0x84&gt; **Implicit Object Return:**
* To implicitly return an object literal, wrap it in parentheses `()`. This distinguishes the object `{}` from a function body block.
    ```js
    // ✅ Correct: Returns an object { value: 10 }
    const makeObject = value =&gt; ({ value: value });

    // ❌ Incorrect: {} treated as function body, returns undefined
    // const makeObjectIncorrect = value =&gt; { value: value };
    ```
"		
65	Arrow functions	This?	"🎯 **The Fundamental Difference in `this`:**

1.  **Arrow Functions (`=&gt;`)**
    * Do **NOT** have their own `this` binding.
    * They **inherit** `this` lexically from the **surrounding scope** where they are *defined*. The value of `this` inside an arrow function is determined when the function is created, not when it's called.

2.  **Regular Functions (`function`)**
    * Have their own `this` binding.
    * The value of `this` is determined dynamically based on *how the function is called* (e.g., as a method, standalone, with `new`, etc.).

**Example: `this` in an Object Method Context**
```js
const counter = {
  count: 10,
  // Regular function: 'this' refers to 'counter' when called as counter.increment()
  incrementRegular: function() {
    this.count++;
    console.log(""Regular:"", this.count);
  },
  // Arrow function: 'this' refers to the scope where 'counter' was defined (e.g., window)
  incrementArrow: () =&gt; {
    // 'this' is NOT 'counter' here
    // this.count++; // Would likely modify window.count or cause an error
    console.log(""Arrow 'this':"", this); // Logs window/global or undefined
  }
};

counter.incrementRegular(); // Output: Regular: 11
counter.incrementArrow();   // Output: Arrow 'this': [Window/Global Object or undefined]
```

🗝️ **Key Implication:** Arrow functions are generally **unsuitable** for object methods that need to refer to the object instance via `this`. Use regular functions for object methods.
"		
66	Arrow functions	'this' in Callbacks &amp; Event Handlers	"Arrow functions shine when you need to preserve the `this` context within nested functions or callbacks.

**Pattern 1: Callbacks (e.g., `setTimeout`, Array methods)**
* Regular functions used as callbacks often ""lose"" their intended `this` context, defaulting to `window` or `undefined`.
* Arrow functions inherit `this` from the enclosing scope, making them ideal here.

```js
const timer = {
  seconds: 0,
  startTimer: function() {
    // Arrow function inherits 'this' (timer) from startTimer
    setInterval(() =&gt; {
      this.seconds++;
      console.log(this.seconds); // Correctly logs incrementing seconds
    }, 1000);

    // Compare with a regular function (would fail)
    // setInterval(function() {
    //   console.log(this.seconds); // 'this' would NOT be 'timer' here
    // }, 1000);
  }
};
// timer.startTimer();
```

**Pattern 2: DOM Event Handlers**
* **Regular Function:** `this` refers to the **HTML element** the listener is attached to.
* **Arrow Function:** `this` refers to the **surrounding scope** where the listener was *defined*, **not** the element.

```js
const myButton = document.getElementById('myButton');

// ✅ Correct: 'this' refers to myButton
// myButton.addEventListener('click', function() {
//   console.log('Clicked element:', this.id);
// });

// ❌ Incorrect for accessing the element via 'this'
// myButton.addEventListener('click', () =&gt; {
//   // 'this' is likely window/global, not myButton
//   console.log('Element context lost:', this);
// });
```

✅ **Guideline:**
* Use **arrow functions** for callbacks (`setTimeout`, `.map`, `.filter` etc.) when you need to access the outer function's `this`.
* Use **regular functions** for event handlers when you need `this` to refer to the target element.
"		
67	Arrow functions	The 'arguments' Object	"🎯 **Fundamental Difference:**

1.  **Arrow Functions (`=&gt;`)**
    * Do **NOT** have their own built-in `arguments` object.
    * Referencing `arguments` inside an arrow function accesses the `arguments` object of the **nearest enclosing *non-arrow* (regular) function**.

2.  **Regular Functions (`function`)**
    * Each regular function receives its own `arguments` object, which is an array-like collection of the arguments passed during invocation.

**Example:**
```js
function wrapperFunction(a, b) {
  console.log('Wrapper args:', arguments); // { '0': 1, '1': 2 }

  const arrowInside = () =&gt; {
    // Inherits 'arguments' from wrapperFunction
    console.log('Arrow sees:', arguments); // { '0': 1, '1': 2 }
  };

  const regularInside = function(x) {
    // Has its own 'arguments' object
    console.log('Regular sees:', arguments); // { '0': 10 }
  };

  arrowInside();
  regularInside(10);
}

wrapperFunction(1, 2);
```

💡 **Modern Alternative: Rest Parameters (`...`)**
* Use **rest parameters** to capture arguments as a *true array*. This works reliably in **both** regular and arrow functions.
```js
const sumAll = (...numbers) =&gt; {
  // 'numbers' is a real array: [1, 2, 3, 4]
  return numbers.reduce((acc, current) =&gt; acc + current, 0);
};
console.log(sumAll(1, 2, 3, 4)); // Output: 10
```

🗝️ **Key Point:** Arrow functions lack their own `arguments`. Use rest parameters (`...args`) for a consistent way to handle function arguments in modern JavaScript."		
68	Classes	Definition &amp; Basic Structure	"**What is a Class?**
* A blueprint or template for creating objects, introduced in ES6.
* Provides a cleaner, more organized syntax over traditional prototype-based inheritance.

**Basic Syntax:**
```javascript
class ClassName {
  // 🏗️ Constructor: Initializes new objects
  constructor(param1, ...) {
    // 'this' refers to the new instance
    this.property1 = param1;
    // ... other properties
  }

  // ⚙️ Instance Method: Available on objects created from the class
  methodName(args...) {
    // Access properties via 'this'
    return `Property value is ${this.property1}`;
  }
}
```

**Key Components:**
* **`class` keyword:** Defines the class.
* **`constructor()`:** A special method called automatically by `new` to initialize the object.
* **Instance Methods:** Functions defined within the class, operating on instance data via `this`.
* **`new` keyword:** Used to create an instance (object) of the class: `const myInstance = new ClassName(args...);`

**Example:**
```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  greet() {
    return `Hello, my name is ${this.name}`;
  }
}

const user1 = new User('Alice');
console.log(user1.greet()); // Output: Hello, my name is Alice
```
"		
69	Classes	Static Methods	"**What are Static Methods?**
* Methods defined using the `static` keyword belong to the **class itself**, not to any specific instance (object) of the class.

**How to Call:**
* Called directly on the Class: `ClassName.staticMethod()`.
* **Cannot** be called on an instance: `instance.staticMethod()` will result in a `TypeError`.

**`this` Context:**
* Inside a static method, `this` generally refers to the **Class itself**, not an instance.
* Static methods **cannot** directly access instance properties (`this.propertyName`) because they are not tied to a specific instance. If instance data is needed, pass the instance as an argument.

**Common Use Cases:** utility functions related to the class, helper methods, or factory methods that create instances.

**Example:**
```javascript
class AppConfig {
  static defaultPort = 3000; // Static property

  // Static method - utility function
  static getInfo() {
    return `Default Port: ${this.defaultPort}`; // 'this' refers to AppConfig class here
  }

  // Static method needing instance data (passed as arg)
  static checkInstanceValidity(configInstance) {
     return configInstance.port &gt; 0;
  }

  constructor(port) {
    this.port = port; // Instance property
  }
}

console.log(AppConfig.getInfo()); // Output: Default Port: 3000
// console.log(AppConfig.defaultPort); // Output: 3000

const myConfig = new AppConfig(8080);
// myConfig.getInfo(); // ❌ TypeError: myConfig.getInfo is not a function
console.log(AppConfig.checkInstanceValidity(myConfig)); // Output: true
```
"		
70	Classes	Inheritance	"**What is Inheritance?**
* Allows a class (child/subclass) to **inherit** properties and methods from another class (parent/superclass).
* Promotes code reuse and creates hierarchical relationships.

**Keywords:**

1.  **`extends`**: Used in the class declaration to specify the parent class to inherit from.
    ```javascript
    class ChildClass extends ParentClass {
      // ... child class definition
    }
    ```
2.  **`super()`**:
    * Inside the child class `constructor`, `super()` calls the **parent class's constructor**. It **must** be called *before* accessing `this` in the child constructor.
    * Can also be used to call methods directly from the parent class (e.g., `super.parentMethod()`).

**Key Features:**
* Child classes inherit all non-static methods and properties from the parent.
* Child classes can **add** new methods and properties.
* Child classes can **override** inherited methods by defining a method with the same name.

**Example:**
```javascript
class Vehicle { // Parent class
  constructor(wheels) {
    this.wheels = wheels;
  }
  drive() {
    console.log(`Driving on ${this.wheels} wheels.`);
  }
}

class Car extends Vehicle { // Child class
  constructor(make) {
    super(4); // Calls Vehicle constructor with wheels=4
    this.make = make;
  }
  // Override drive method
  drive() {
    // Optional: Call parent method
    // super.drive();
    console.log(`Driving a ${this.make} car on ${this.wheels} wheels.`);
  }
}

const myCar = new Car('Toyota');
myCar.drive(); // Output: Driving a Toyota car on 4 wheels.
console.log(myCar.wheels); // Output: 4 (Initialized by super(4))
```
"		
71	Classes	Getters and Setters	"**What are Getters &amp; Setters?**
* Special methods that provide **controlled access** to an object's properties.
* They allow executing code when a property is read (`get`) or written (`set`).

**Syntax:**
* Use the `get` and `set` keywords before a method name. The method name typically matches the property being controlled.
* Often used with an internal property (e.g., `_propertyName`) to store the actual value.

```javascript
class Circle {
  constructor(radius) {
    this._radius = radius; // Internal property
  }

  // 📏 Getter for 'diameter'
  get diameter() {
    console.log('Calculating diameter...');
    return this._radius * 2;
  }

  // ✍️ Setter for 'radius' with validation
  set radius(value) {
    console.log('Setting radius...');
    if (value &gt; 0) {
      this._radius = value;
    } else {
      console.error('Radius must be positive.');
    }
  }
}
```

**Usage:**
* Access getters and setters **like regular properties**, not methods:
    * `instance.propertyName` // Calls the getter
    * `instance.propertyName = newValue;` // Calls the setter

**Benefits:**
* **Encapsulation:** Hides internal data storage.
* **Validation:** Enforces rules when setting property values.
* **Computed Properties:** Calculate values on the fly when accessed (like `diameter` above).
* **Side Effects:** Trigger actions when properties are read or written.

**Example:**
```javascript
const c = new Circle(5);
console.log(c.diameter); // Calls getter -&gt; Logs 'Calculating...' -&gt; Output: 10
c.radius = 10;        // Calls setter -&gt; Logs 'Setting...'
console.log(c.diameter); // Calls getter -&gt; Logs 'Calculating...' -&gt; Output: 20
c.radius = -2;        // Calls setter -&gt; Logs 'Setting...' -&gt; Logs error message
console.log(c._radius); // Still 10 (internal value wasn't updated due to validation)
```"		
72	Debugging	Console method	"### **Using `console.log()` for Debugging in JavaScript**  

If your browser supports debugging (most modern browsers do), you can use **`console.log()`** to display JavaScript values in the **developer console**.

---

## **📌 How to Use `console.log()`**
- `console.log()` prints values to the **console**, helping with debugging.
- You can open the console in most browsers:
  - **Chrome**: `Ctrl + Shift + J` (Windows) / `Cmd + Option + J` (Mac)
  - **Firefox**: `Ctrl + Shift + K` (Windows) / `Cmd + Option + K` (Mac)
  - **Edge**: `F12` → Console tab
  - **Safari**: Enable Developer Tools in Preferences, then `Cmd + Option + C`

#### **Example: Logging a Variable**
```js
let name = ""Alice"";
console.log(name); // ✅ Output: ""Alice"" in the console
```

---

## **📌 Debugging Objects and Arrays**
You can print complex data structures like **objects** and **arrays**.

#### **Example: Logging an Object**
```js
let user = { name: ""Alice"", age: 25 };
console.log(user);
```
✅ **Displays the object in a structured format in the console.**

#### **Example: Logging an Array**
```js
let fruits = [""Apple"", ""Banana"", ""Cherry""];
console.log(fruits);
```
✅ **Displays the array elements in the console.**

---

## **📌 `console.log()` with Multiple Values**
You can log multiple values in one statement.

```js
let a = 10, b = 20;
console.log(""Sum:"", a + b); // ✅ Output: ""Sum: 30""
```

---

## **📌 Other Console Methods for Debugging**
| Method | Description |
|--------|-------------|
| `console.log(value)` | Displays values in the console. |
| `console.table(object/array)` | Displays objects/arrays as a table. |
| `console.error(""Error message"")` | Displays an error message. |
| `console.warn(""Warning message"")` | Displays a warning. |
| `console.info(""Info message"")` | Displays an info message. |
| `console.time(""label"")` / `console.timeEnd(""label"")` | Measures execution time. |

#### **Example: `console.table()`**
```js
let users = [
    { name: ""Alice"", age: 25 },
    { name: ""Bob"", age: 30 }
];
console.table(users);
```
✅ **Displays an array of objects in a structured table format.**

---

## **📌 Key Takeaways**
✔ **Use `console.log()` to debug JavaScript code.**  
✔ **Use `console.table()` for better visualization of arrays/objects.**  
✔ **Use `console.error()` and `console.warn()` for debugging errors and warnings.**  
✔ **Check the browser's developer console (`F12`) to see output.** 🚀"		
73	Debugging	Display Objects as a Table (no w3)	"### **Using `console.table()` for Better Debugging in JavaScript**  

When dealing with **complex objects or arrays of objects**, using `console.log()` can be **cumbersome** because you have to manually expand the data in the console.

Instead, **`console.table()`** provides a **clear, structured table format** that makes it easier to inspect data.

---

## **📌 Example: Using `console.table()` with an Array of Objects**
```js
var animals = [
    { animal: ""Horse"", name: ""Henry"", age: 43 },
    { animal: ""Dog"", name: ""Fred"", age: 13 },
    { animal: ""Cat"", name: ""Frodo"", age: 18 }
];

console.table(animals);
```
✅ **Displays the data in a structured table format in the console.**  
✅ **Easier to scan compared to `console.log()`.**  

---

## **📌 Output in the Console**
| (Index) | animal | name  | age |
|---------|--------|-------|-----|
| 0       | Horse  | Henry | 43  |
| 1       | Dog    | Fred  | 13  |
| 2       | Cat    | Frodo | 18  |

---

## **📌 Example: Using `console.table()` with Objects**
`console.table()` can also be used with **plain objects**, where each key-value pair is displayed in a table format.

```js
var car = {
    brand: ""Toyota"",
    model: ""Camry"",
    year: 2022
};

console.table(car);
```
✅ **Displays the object properties in a structured format.**  

---

## **📌 Example: Filtering Columns in `console.table()`**
You can specify which **columns to display** by passing an array of column names.

```js
console.table(animals, [""name"", ""age""]);
```
✅ **Only `name` and `age` columns will be displayed.**  

---

## **📌 `console.table()` vs. `console.log()`**
| Feature | `console.log()` | `console.table()` |
|---------|---------------|-----------------|
| **Format** | Linear, requires scrolling | Structured table |
| **Best For** | Small, simple values | Large datasets, structured objects |
| **Filtering Columns** | ❌ No | ✅ Yes |

---

### **📌 Key Takeaways**
✔ **Use `console.table()` instead of `console.log()` for structured data visualization.**  
✔ **Easier to inspect arrays of objects or structured data.**  
✔ **Supports column filtering for better debugging.** 🚀"		
74	Debugging	Benchmark Loops (no w3)	"### **Measuring Execution Time with `console.time()` and `console.timeEnd()` in JavaScript**  

When debugging **slow loops or performance bottlenecks**, it's helpful to measure **how long a piece of code takes to execute**.

---

## **📌 How `console.time()` and `console.timeEnd()` Work**
1. **Start a timer** using `console.time('LabelName')`.  
2. **Run the code you want to measure.**  
3. **Stop the timer** using `console.timeEnd('LabelName')`.  
4. The console displays the **execution time** in milliseconds.  

---

## **📌 Example: Measuring Execution Time of a Loop**
```js
console.time(""Timer1""); // Start the timer

var items = [];
for (var i = 0; i &lt; 100000; i++) {
    items.push({ index: i });
}

console.timeEnd(""Timer1""); // End the timer
```
✅ **Output Example (varies based on performance):**
```
Timer1: 12.345ms
```
✅ **This shows how long it took for the loop to execute.**

---

## **📌 Using Multiple Timers with Different Labels**
You can **run multiple timers at once** by giving each one a unique label.

```js
console.time(""Small Loop"");
for (let i = 0; i &lt; 1000; i++) {}
console.timeEnd(""Small Loop"");

console.time(""Large Loop"");
for (let i = 0; i &lt; 1000000; i++) {}
console.timeEnd(""Large Loop"");
```
✅ **Output Example:**
```
Small Loop: 0.345ms
Large Loop: 15.678ms
```
✅ **This helps compare execution times of different operations.**

---

## **📌 `console.timeLog()` to Track Intermediate Times**
You can check execution progress **without stopping the timer** using `console.timeLog()`.

```js
console.time(""Process"");

setTimeout(() =&gt; {
    console.timeLog(""Process""); // Logs elapsed time but keeps the timer running
}, 1000);

setTimeout(() =&gt; {
    console.timeEnd(""Process""); // Stops the timer
}, 2000);
```
✅ **Output Example:**
```
Process: 1001.23ms
Process: 2003.45ms
```
✅ **`console.timeLog()` helps track time at different points.**

---

## **📌 Summary: Why Use `console.time()`?**
| Feature | Benefit |
|---------|---------|
| **Precise Execution Time** | Measures performance in milliseconds. |
| **Multiple Timers** | Supports multiple timers with unique labels. |
| **Track Progress** | Use `console.timeLog()` to log intermediate times. |
| **Great for Debugging** | Helps optimize loops, API calls, and heavy calculations. |

---

### **📌 Key Takeaways**
✔ **Use `console.time(""label"")` to start a timer.**  
✔ **Use `console.timeEnd(""label"")` to stop the timer and display execution time.**  
✔ **Use `console.timeLog(""label"")` to check progress without stopping the timer.**  
✔ **Super useful for debugging slow loops and optimizing performance.** 🚀"		
75	Debugging	Get the Stack Trace for a Function (no w3)	"### **Using `console.trace()` for Debugging in JavaScript**  

JavaScript's **dynamic nature** can sometimes make it difficult to track **function calls** and understand how execution flows.  
✅ **`console.trace()` helps by displaying the entire function call stack** that led to a specific point in execution.

---

## **📌 Example: Using `console.trace()` to Track Function Calls**
```js
var car;
var func1 = function() {
    func2();
}

var func2 = function() {
    func4();
}

var func3 = function() { }

var func4 = function() {
    car = new Car();
    car.funcX();
}

var Car = function() {
    this.brand = ""volvo"";
    this.color = ""red"";

    this.funcX = function() {
        this.funcY();
    }
    this.funcY = function() {
        this.funcZ();
    }
    this.funcZ = function() {
        console.trace(""Trace Car"");
    }
}

func1();
```

---

## **📌 What Happens When You Run This?**
1. **`func1()` is called**.
2. **`func1()` calls `func2()`**.
3. **`func2()` calls `func4()`**.
4. **`func4()` creates a `Car` instance and calls `car.funcX()`**.
5. **`funcX()` calls `funcY()`, which calls `funcZ()`**.
6. **Inside `funcZ()`, `console.trace(""Trace Car"")` logs the function call stack**.

✅ **`console.trace()` prints all function calls leading up to `funcZ()` in a structured stack trace.**  

---

## **📌 Example: What the Console Trace Output Looks Like**
```
Trace Car
    at Car.funcZ (script.js:22)
    at Car.funcY (script.js:18)
    at Car.funcX (script.js:15)
    at func4 (script.js:10)
    at func2 (script.js:6)
    at func1 (script.js:3)
    at script.js:26
```
✅ **Each function in the call stack is listed in execution order.**  
✅ **Each function is **clickable** in the browser console, allowing quick navigation.**

---

## **📌 Why Use `console.trace()`?**
| Feature | Benefit |
|---------|---------|
| **Tracks Function Calls** | Shows the full execution path leading to a function. |
| **Clickable Stack Trace** | Click on function names in the console to jump to their definitions. |
| **Great for Debugging** | Helps find unexpected calls or unintended recursive loops. |
| **Works Inside Objects and Classes** | Can be used in **methods**, **event handlers**, and **callbacks**. |

---

## **📌 Example: `console.trace()` in a Class**
```js
class Car {
    constructor(brand) {
        this.brand = brand;
    }
    
    drive() {
        this.accelerate();
    }

    accelerate() {
        this.brake();
    }

    brake() {
        console.trace(""Car stopped"");
    }
}

let myCar = new Car(""Tesla"");
myCar.drive();
```
✅ **Outputs the function call stack leading to `brake()`.**

---

## **📌 Summary**
✔ **`console.trace()` logs the call stack, showing how execution reached a function.**  
✔ **Functions in the stack are clickable, making debugging easier.**  
✔ **Useful for debugging deeply nested functions, recursive calls, and class methods.**  
✔ **Helps improve code efficiency by tracking unnecessary function calls.** 🚀"		
76	Debugging	Unminify Code as an Easy Way to Debug JavaScript (no w3)	"### **Unminifying Code to Debug JavaScript in Chrome DevTools**  

Sometimes, in a **production environment**, you might encounter **minified JavaScript files** that are hard to read.  
If **source maps** are missing or unavailable, Chrome DevTools provides a way to **unminify** code.

---

## **📌 How to Unminify JavaScript in Chrome DevTools**
1. **Open Chrome DevTools**  
   - Right-click on the webpage and select **""Inspect""** (`F12` or `Ctrl+Shift+I` / `Cmd+Option+I` on Mac).  
2. **Go to the Sources tab**  
   - Click on the **""Sources""** panel to view the website's JavaScript files.
3. **Locate the Minified JavaScript File**  
   - Expand the folder structure and find the `.js` file that looks minified.
4. **Click the `{}` Pretty Print Button**  
   - At the bottom of the **Source viewer**, click the `{}` button (Pretty Print).  
5. **The code is now formatted and easier to read!**  
   - It won’t restore original variable names, but **it makes debugging possible**.

---

## **📌 Why Use Pretty Print (`{}`) for Debugging?**
| Feature | Benefit |
|---------|---------|
| **Unminifies JavaScript** | Converts unreadable minified code into formatted code. |
| **Helps Debug Production Issues** | Useful when source maps are missing. |
| **Works in All Browsers** | Available in Chrome, Firefox, and Edge DevTools. |
| **Preserves Execution Flow** | Even if variable names are lost, you can still analyze function calls. |

---

## **📌 Example: Minified vs. Pretty Printed Code**
### **🔹 Minified JavaScript (Hard to Read)**
```js
function test(){for(var a=0;a&lt;10;a++)console.log(a)}
```
### **🔹 Pretty Printed JavaScript (Readable)**
```js
function test() {
    for (var a = 0; a &lt; 10; a++) {
        console.log(a);
    }
}
```
✅ **Now, you can debug and understand the logic more easily!**

---

## **📌 Other Ways to Debug Minified JavaScript**
### **1️⃣ Enable Source Maps (If Available)**
- Some **minified files have source maps (`.map` files)** that allow debugging with the original code.
- To enable source maps:
  - Open **DevTools → Settings (`F1`) → Enable Source Maps**.

### **2️⃣ Use Online Unminifiers**
If DevTools is not available, try online tools like:
- [Unminify.com](https://unminify.com)
- [JSBeautifier](https://beautifier.io)

---

## **📌 Key Takeaways**
✔ **Click `{}` Pretty Print in Chrome DevTools to format minified JavaScript.**  
✔ **Useful when debugging production issues without source maps.**  
✔ **Makes JavaScript readable but does not restore original variable names.**  
✔ **Combine with breakpoints and `console.log()` for better debugging.** 🚀"		
77	Debugging	Quickly Find a Function to Debug (no w3)	"### **Setting Breakpoints in JavaScript for Debugging**  

When debugging JavaScript, you can **pause execution at specific points** to inspect variables and execution flow.  

### **🔹 Common Ways to Set a Breakpoint**
1️⃣ **Manually setting a breakpoint in the browser's DevTools.**  
2️⃣ **Using the `debugger` statement inside the script.**  
3️⃣ **Using `debug(funcName)` in the console (quick and effective, but limited).**  

---

## **📌 1. Using the Browser Inspector to Add Breakpoints**
### **Steps:**
1. Open **DevTools (`F12` or `Ctrl + Shift + I` / `Cmd + Option + I` on Mac).**
2. Go to the **Sources** tab.
3. Open the JavaScript file.
4. Click the **line number** where you want to pause execution.
5. Reload or trigger the function.

✅ **Best for pinpointing a specific line visually.**  

---

## **📌 2. Using `debugger;` in Your Code**
You can **pause execution** by inserting `debugger;` inside a function.

#### **Example:**
```js
function test() {
    let x = 10;
    debugger; // Execution will pause here
    let y = x * 2;
    console.log(y);
}

test(); // Run this and the debugger will pause execution
```
✅ **Stops execution in DevTools, allowing inspection of variables.**  
❌ **Requires modifying the source code.**

---

## **📌 3. Using `debug(funcName)` in the Console**
You can **set a breakpoint without modifying the code** by calling `debug(funcName)` in the **console**.

#### **Example:**
```js
function myFunction() {
    console.log(""Executing function..."");
}

debug(myFunction); // Type this in the browser console
myFunction(); // The debugger will pause execution inside this function
```
✅ **No need to modify source code.**  
✅ **Works well for public functions.**  
❌ **Does NOT work for private or anonymous functions.**  

---

## **📌 Example: `debug()` vs. `debugger`**
```js
function calculate(num) {
    return num * 10;
}

// Using `debug()` in console:
debug(calculate);
calculate(5); // Will pause execution when called

// Using `debugger` inside the function:
function calculate(num) {
    debugger; // Stops execution when called
    return num * 10;
}
calculate(5);
```

---

## **📌 Summary: Choosing the Best Debugging Method**
| Method | How It Works | Pros | Cons |
|--------|-------------|------|------|
| **DevTools Breakpoints** | Click on line numbers in **Sources** tab | ✅ Easy to use | ❌ Requires clicking through files |
| **`debugger;` Statement** | Insert `debugger;` in code | ✅ Works in any function | ❌ Requires modifying code |
| **`debug(funcName)` in Console** | Type `debug(funcName)` in the console | ✅ No code changes | ❌ Doesn't work on private/anonymous functions |

---

### **📌 Key Takeaways**
✔ **Use `debugger;` to pause execution inside a function.**  
✔ **Use DevTools breakpoints for a visual debugging approach.**  
✔ **Use `debug(funcName)` in the console for a quick, no-code approach.**  
✔ **Combine these techniques for faster and more efficient debugging.** 🚀"		
78	Debugging	Black Box scripts debugging (no w3)	"### **Black Boxing Scripts in Chrome DevTools**  

When debugging **web apps with multiple libraries and frameworks**, stepping into third-party scripts (like jQuery, React, or Vue) can **slow down debugging** and make it harder to focus on your own code.  

✅ **Solution: Black Box scripts to prevent DevTools from stepping into them.**  
✅ **This makes debugging faster and more focused on your own code.**  

---

## **📌 How to Black Box Scripts in Chrome DevTools**
### **🔹 Option 1: Right-Click to Black Box a Specific File**
1. Open **Chrome DevTools** (`F12` or `Ctrl + Shift + I` / `Cmd + Option + I` on Mac).
2. Go to the **Sources** tab.
3. Find the **file you want to ignore** in the file tree.
4. **Right-click** the file and select **""Blackbox script""**.
5. Now, DevTools will **skip this script when stepping through code**.

✅ **Great for black-boxing a single file quickly.**

---

### **🔹 Option 2: Manage Black Boxed Scripts in Settings**
1. Open **Chrome DevTools**.
2. Click on the **⚙ (Settings) icon** in the top-right corner.
3. Go to **""Blackboxing""** under the **Debugger** section.
4. Click **""Manage framework black boxing""**.
5. **Add a regular expression (RegExp)** to ignore multiple files or folders.
   - Example: To ignore everything in a `vendor` folder:
     ```
     .*vendor.*
     ```
6. Close settings and enjoy a **cleaner debugging experience**.

✅ **Best for black-boxing entire folders or frameworks.**  

---

## **📌 Why Use Black Boxing?**
| Feature | Benefit |
|---------|---------|
| **Ignore third-party scripts** | Speeds up debugging by skipping jQuery, React, Vue, etc. |
| **Focus on your own code** | Prevents unnecessary stepping into framework code. |
| **Supports regular expressions (RegExp)** | Easily blacklist entire directories. |
| **Reversible** | You can remove black-boxed scripts anytime. |

---

## **📌 Example: Black Box All `node_modules` Files**
If your web app includes **third-party dependencies from `node_modules`**, you can black-box them all:

1. Open **DevTools Settings (`⚙`)** → **Blackboxing**.
2. Add this **RegExp pattern**:
   ```
   .*node_modules.*
   ```
✅ **Now, DevTools will ignore all files inside `node_modules/`.**  

---

## **📌 Summary: How to Black Box Scripts in Chrome DevTools**
| Method | Steps |
|--------|------|
| **Right-click Black Box a script** | Right-click the file in **Sources** → Select **""Blackbox script""**. |
| **Use DevTools Settings** | Click ⚙ (Settings) → Debugger → ""Manage framework black boxing"". |
| **Use RegExp for folders** | Add patterns like `.*node_modules.*` to ignore multiple scripts. |

---

### **📌 Key Takeaways**
✔ **Black Boxing prevents DevTools from stepping into unnecessary scripts.**  
✔ **Use it to ignore third-party frameworks like React, Vue, or jQuery.**  
✔ **Right-click to black box a single file, or use RegExp to black box multiple files.**  
✔ **Improves debugging speed by focusing only on relevant scripts.** 🚀"		
79	Debugging	CSS the console.log (no w3)	"### **Using CSS for Custom Styled Console Messages in JavaScript**  

You can **style console messages** in JavaScript using **CSS via `console.log()`**.  
This helps **highlight important messages** or categorize logs in debugging.

---

## **📌 Example: Custom `console.important()` Function**
```js
console.important = function(msg) {
    console.log('%c %s %s %s', 
        'color: brown; font-weight: bold; text-decoration: underline;', 
        '–', msg, '–'
    );
};

console.important('This is an important message');
```
✅ **Styled message in the console:**  
```
– This is an important message –
```
**(Formatted in brown, bold, and underlined)**

---

## **📌 How It Works**
- The **`%c` format specifier** applies CSS styling to the next argument.
- The **second parameter** is the CSS styles as a string.
- The **remaining parameters** are the text elements.

---

## **📌 More Examples: Different Styled Logs**
### **1️⃣ Highlighting Errors**
```js
console.errorMsg = function(msg) {
    console.log('%c ERROR: %s', 
        'color: red; font-weight: bold; background: yellow; padding: 3px;', 
        msg
    );
};

console.errorMsg('Something went wrong!');
```
✅ **Styled error message:**  
🟥 `""ERROR: Something went wrong!""` (Red text with yellow background)

---

### **2️⃣ Debug Messages**
```js
console.debugMsg = function(msg) {
    console.log('%c DEBUG: %s', 
        'color: blue; font-style: italic;', 
        msg
    );
};

console.debugMsg('This is a debug message.');
```
✅ **Styled debug message:**  
🔵 `""DEBUG: This is a debug message.""` (Blue, italic text)

---

### **3️⃣ Success Messages**
```js
console.success = function(msg) {
    console.log('%c SUCCESS: %s', 
        'color: green; font-weight: bold;', 
        msg
    );
};

console.success('Operation completed successfully!');
```
✅ **Styled success message:**  
🟢 `""SUCCESS: Operation completed successfully!""` (Green, bold text)

---

## **📌 Summary: Custom Console Logging**
| Function | Style | Use Case |
|----------|-------|----------|
| `console.important(msg)` | **Brown, bold, underlined** | Highlight important messages |
| `console.errorMsg(msg)` | **Red text, yellow background** | Display errors |
| `console.debugMsg(msg)` | **Blue, italic text** | Debugging messages |
| `console.success(msg)` | **Green, bold text** | Success messages |

---

## **📌 Key Takeaways**
✔ **Use `console.log('%c message', 'CSS styles')` to style logs.**  
✔ **Use `%c` to apply styles to only part of the message.**  
✔ **Create custom console functions for debugging efficiency.**  
✔ **Helps make logs clearer and easier to analyze!** 🚀"		
80	Debugging	Watch Specific Function Calls and It’s Arguments (no w3)	"### **Monitoring Function Calls in Chrome DevTools Using `monitor(funcName)`**  

In **Chrome DevTools**, you can **track function calls** automatically using the `monitor(funcName)` command.  
Every time the function is called, the console **logs the function name and its arguments**.

---

## **📌 How to Use `monitor(funcName)`**
1. **Open Chrome DevTools** (`F12` or `Ctrl + Shift + I` / `Cmd + Option + I` on Mac).
2. **Go to the Console tab**.
3. **Type `monitor(funcName)`** to start tracking.
4. **Run the function** in your script, and Chrome will log each call.

---

## **📌 Example: Monitoring a Function**
```js
function func1(a, b) {
    return a + b;
}

monitor(func1); // Start monitoring `func1`

func1(2, 3); // ✅ Output in console: func1(2, 3)
func1(10, 20); // ✅ Output in console: func1(10, 20)
```
**Console Output:**
```
func1(2, 3)
func1(10, 20)
```
✅ **Every time `func1` is called, its name and arguments are logged automatically.**

---

## **📌 Stopping the Monitoring**
To **stop monitoring** a function, use:
```js
unmonitor(func1);
```
✅ **Now `func1` calls will no longer be logged.**

---

## **📌 Why Use `monitor(funcName)`?**
| Feature | Benefit |
|---------|---------|
| **Tracks Function Calls** | Automatically logs function calls in real-time. |
| **Shows Passed Arguments** | Displays values passed into the function. |
| **No Need to Modify Code** | Works without adding `console.log()` inside functions. |
| **Useful for Debugging Events** | Great for tracking event handlers like `click`, `keydown`, etc. |

---

## **📌 Example: Monitoring Event Handlers**
If you want to **track when an event handler runs**, you can monitor it:

```js
function handleClick(event) {
    console.log(""Button clicked!"", event.target);
}

document.getElementById(""myButton"").addEventListener(""click"", handleClick);

monitor(handleClick);
```
✅ **Now, every button click is automatically logged in the console.**

---

## **📌 Summary: Using `monitor(funcName)` in Chrome DevTools**
| Command | Purpose |
|---------|---------|
| `monitor(funcName)` | Start monitoring function calls. |
| `unmonitor(funcName)` | Stop monitoring function calls. |

---

### **📌 Key Takeaways**
✔ **Use `monitor(funcName)` to track function calls automatically.**  
✔ **Displays function arguments without modifying the code.**  
✔ **Use `unmonitor(funcName)` to stop tracking.**  
✔ **Great for debugging event handlers and frequently called functions.** 🚀"		
81	Debugging	Quickly Access Elements in the Console (no w3)	"### **Using `$()` and `$$()` for Faster DOM Queries in Chrome Console**  

Chrome DevTools provides shortcuts to make **DOM element selection** faster and easier in the console.  

---

## **📌 `$()` - Selecting the First Element with a CSS Selector**
- **`$()`** is a shortcut for **`document.querySelector()`**, which selects the first element that matches the given CSS selector.

#### **Example: Selecting the First Element**
```js
let element = $('#myButton');
console.log(element); // Logs the first element with id=""myButton""
```
✅ **Returns the first match of the CSS selector (`#myButton`)**.  
✅ **Equivalent to `document.querySelector('#myButton')`.**

---

## **📌 `$$()` - Selecting All Matching Elements**
- **`$$()`** is a shortcut for **`document.querySelectorAll()`**, which selects all elements that match the given CSS selector.

#### **Example: Selecting All Elements**
```js
let allButtons = $$('button');
console.log(allButtons); // Logs all button elements
```
✅ **Returns an array of all matching elements.**  
✅ **Equivalent to `document.querySelectorAll('button')`.**

---

## **📌 Saving Repeated Elements as Variables**
If you need to interact with an element multiple times, it's more efficient to **store it in a variable** to avoid selecting it multiple times.

#### **Example: Storing and Reusing an Element**
```js
let myButton = $('#myButton');
myButton.style.backgroundColor = 'red'; // Changes the background color of the button

myButton.addEventListener('click', () =&gt; {
    console.log('Button clicked!');
});
```
✅ **Now you can reuse `myButton` to modify the element multiple times without querying it repeatedly.**

---

## **📌 Why Use `$()` and `$$()`?**
| Feature | Benefit |
|---------|---------|
| **Quick DOM Queries** | Select elements faster using shorthand. |
| **Single vs. Multiple Selection** | `$()` for the first match, `$$()` for all matches. |
| **Reusable Variables** | Store elements in variables for repeated use. |
| **Improves Debugging Efficiency** | Reduces the need for repeated `document.querySelector` calls. |

---

## **📌 Summary**
- **`$()`**: Selects the **first** element matching the CSS selector.
- **`$$()`**: Selects **all** elements matching the CSS selector.

---

### **📌 Key Takeaways**
✔ **Use `$()` for selecting the first matching element quickly.**  
✔ **Use `$$()` for selecting all matching elements.**  
✔ **Store elements in variables when interacting with them multiple times.**  
✔ **These shortcuts help you debug and interact with DOM elements more efficiently.** 🚀"		
82	Debugging	Postman Is Great (But Firefox Is Faster) (no w3)	"### **Editing and Resending Requests in Firefox for Debugging**

When you're working with **password-protected pages** or debugging network requests, **editing and resending HTTP requests** can be incredibly useful. Firefox provides a built-in way to do this directly from the **Network tab** of the **Inspector**.

---

## **📌 Steps to Edit and Resend Requests in Firefox**
1. **Open Firefox Developer Tools**:
   - Right-click on the page and select **""Inspect""**, or press `F12` (`Ctrl + Shift + I` / `Cmd + Option + I` on Mac).
   - Go to the **Network tab**.

2. **Trigger the Request**:
   - Reload the page or interact with the site as usual to ensure the request you want to modify is captured in the **Network tab**.

3. **Right-click on the Desired Request**:
   - Find the request you want to edit in the **Network tab**.
   - Right-click the request and choose **""Edit and Resend""**.

4. **Edit the Request**:
   - A popup window will appear with the details of the request.
   - You can **change** any part of the request:
     - Modify **headers** (e.g., cookies, authentication tokens).
     - Edit the **parameters** (e.g., POST data, query parameters).
     - Adjust the **method** (GET, POST, etc.) if necessary.

5. **Resend the Request**:
   - Once you're done editing, click **""Send""** or **""Resend""** to send the modified request.
   - The **response** will be displayed in the console, and you can inspect the result.

---

## **📌 Example: Editing and Resending a POST Request**
Imagine you want to change a **POST request** with new parameters or headers (e.g., to test with different form values or cookies).

1. **Open Developer Tools** → **Network Tab**.
2. **Find the POST request** (e.g., a login request).
3. **Right-click and choose ""Edit and Resend""**.
4. **Modify the request body** (like updating form values) or change headers (e.g., updating authentication cookies).
5. **Click ""Resend""** to send the new request.

---

## **📌 Why is Editing and Resending Useful?**
| Feature | Benefit |
|---------|---------|
| **Testing** | Test different parameters, headers, or request bodies. |
| **Debugging** | Modify requests to diagnose issues without having to refresh the page. |
| **Bypass Authentication** | Edit cookies or tokens to simulate authenticated requests. |
| **Save Time** | You don't need to write or modify scripts to repeat the requests. |

---

## **📌 Key Takeaways**
✔ **Firefox allows you to easily edit and resend HTTP requests in the Network tab.**  
✔ **Modify headers, parameters, and methods to test different scenarios.**  
✔ **Useful for debugging, testing, and bypassing authentication.**  
✔ **Helps simulate various conditions without needing to reload or modify the source code.** 🚀"		
83	Debugging	Break on Node Change (no w3)	"### **Breaking on DOM Changes in Chrome DevTools**

When debugging JavaScript, **DOM elements** might change unexpectedly, and it can be tricky to figure out why. Fortunately, **Chrome DevTools** provides a way to **pause code execution** when a **DOM element changes**. This is especially useful when you're trying to track changes to a DOM element that you don't explicitly modify in your code.

---

## **📌 How to Use Break on Node Change in Chrome DevTools**

1. **Open Chrome DevTools**:
   - Right-click on the webpage and select **""Inspect""** (`F12` or `Ctrl + Shift + I` / `Cmd + Option + I` on Mac).

2. **Locate the DOM Element**:
   - In the **Elements tab**, find the DOM element you want to monitor.
   
3. **Right-click on the Element**:
   - Right-click on the desired DOM element in the **Elements panel**.

4. **Choose ""Break on"" Option**:
   - Select one of the **""Break on""** options:
     - **""Subtree Modifications""**: Break when any child nodes are added or removed.
     - **""Attribute Modifications""**: Break when the element’s attributes change (e.g., `class`, `style`).
     - **""Node Removal""**: Break when the element is removed from the DOM.

5. **Trigger the Change**:
   - Once you select the break point, the debugger will automatically **pause** execution when the selected event occurs on that element.
   - **Inspect the call stack** and determine **what triggered the change**.

---

## **📌 Example: Breaking on Attribute Modifications**

### Steps:
1. **Right-click** on an element in the **Elements tab**.
2. Select **Break on → Attribute Modifications**.
3. Now, if any attribute of this element changes (e.g., `id`, `class`, `style`), the code will **pause execution**.

#### **Why This is Useful**:
- **If an element's class or style is dynamically modified**, you can pause and see **which script or function changed it**.
  
---

## **📌 Example: Breaking on Subtree Modifications**

### Steps:
1. **Right-click** on an element in the **Elements tab**.
2. Select **Break on → Subtree Modifications**.
3. If any **child elements** of that node are modified (added, removed, or changed), execution will pause.

#### **Why This is Useful**:
- **If an element’s child nodes are changing unexpectedly**, you can inspect the code and find the source of the modification.

---

## **📌 Example: Breaking on Node Removal**

### Steps:
1. **Right-click** on the element you want to monitor.
2. Select **Break on → Node Removal**.
3. Execution will pause when the element is removed from the DOM.

#### **Why This is Useful**:
- **When elements are dynamically removed**, you can trace the exact point where and why the element was removed.

---

## **📌 Why Use Break on Node Change?**
| Feature | Benefit |
|---------|---------|
| **Pause Execution on DOM Changes** | Debug when elements change without manually tracking them. |
| **Track Attribute Modifications** | Catch changes to attributes like `class`, `style`, etc. |
| **Monitor Subtree Changes** | Detect when child nodes are added or removed unexpectedly. |
| **Node Removal Tracking** | Debug when an element is removed from the DOM. |

---

## **📌 Key Takeaways**
✔ **Right-click on a DOM element in Chrome DevTools to monitor its changes.**  
✔ **Use ""Break on"" options to pause when an element’s attributes, children, or removal are triggered.**  
✔ **Great for tracking unexpected changes to the DOM that might be caused by JavaScript.**  
✔ **Helps pinpoint exactly where and why a DOM element was modified.** 🚀"		
84	Debugging	Setting Breakpoints (no w3)	"### **Setting Breakpoints in the Browser Debugger for JavaScript**

Breakpoints are a crucial tool for debugging JavaScript, allowing you to **pause code execution** at specific points. This lets you **examine variable values, function calls, and the execution flow**, making it much easier to track down issues in your code.

---

## **📌 How to Set Breakpoints in Chrome DevTools**

1. **Open Chrome DevTools**:
   - Right-click on the webpage and select **""Inspect""** (`F12` or `Ctrl + Shift + I` / `Cmd + Option + I` on Mac).
   - Go to the **Sources tab** to view the JavaScript files.

2. **Set a Breakpoint**:
   - In the **Sources tab**, find the JavaScript file you want to debug in the **file navigator**.
   - Click on the **line number** where you want to set the breakpoint.
   - **A blue marker** will appear, indicating the breakpoint.

3. **Trigger the Code**:
   - Refresh the page or trigger the action that causes the breakpoint to be hit (e.g., clicking a button, submitting a form).

4. **Examine Variables and Execution Flow**:
   - Once the breakpoint is hit, execution **pauses**, and you can examine the values of **variables** and **objects** in the **Scope** section.
   - You can also view the **Call Stack** to see the functions that were called to reach the breakpoint.

5. **Resume Execution**:
   - After inspecting values, you can **resume execution** by clicking the **play (▶️) button** or pressing `F8`.
   - You can also use the **step buttons** (step into, step over, step out) to move through the code line by line.

---

## **📌 Example: Setting Breakpoints**
Let's say you have the following JavaScript code:

```js
function calculateTotal(price, tax) {
    let total = price + tax;
    console.log(total);
    return total;
}

let totalAmount = calculateTotal(100, 10);
```

### **Steps to Set Breakpoints**:
1. Open **DevTools → Sources**.
2. Find the **JavaScript file** with the `calculateTotal` function.
3. **Click on the line number** where `let total = price + tax;` is defined.
4. **Trigger the function** by running the script or reloading the page.
5. **Inspect the values** of `price`, `tax`, and `total` in the **Scope** section of DevTools.

---

## **📌 Navigating with Debugger Controls**
- **Play (▶️)**: Resume execution until the next breakpoint.
- **Step Over (⇩)**: Move to the next line of code, skipping any function calls.
- **Step Into (⬇️)**: Move into the next function call to debug it step by step.
- **Step Out (⬆️)**: Move out of the current function back to the caller.

---

## **📌 Key Takeaways**
✔ **Breakpoints allow you to pause code execution at specific points** to inspect the values of variables and objects.  
✔ **In DevTools**, use the **Sources tab** to set breakpoints and navigate through the code.  
✔ **After inspecting values**, you can **resume the code** execution with the play button.  
✔ **Useful for debugging logic errors** and understanding how data changes throughout the code. 🚀"		
85	Debugging	The debugger Keyword (no w3)	"### **Using the `debugger` Keyword in JavaScript for Debugging**

The `debugger` statement is a powerful tool in JavaScript that can be used to **pause code execution** and invoke the debugger. This allows you to inspect variables, the call stack, and other debugging details directly in the browser's Developer Tools.

---

## **📌 How the `debugger` Keyword Works**

- The `debugger` keyword **pauses JavaScript execution** at the point where it's placed, much like setting a breakpoint in DevTools.
- If the browser's **debugger is open**, the script will **pause execution** right at the `debugger` statement.
- If no debugger is present, **the `debugger` statement has no effect** and the code continues executing normally.

---

## **📌 Example: Using the `debugger` Keyword**
```js
var x = 15 * 5;  // First line
debugger;        // Code will stop here when DevTools is open
document.getElementById(""demo"").innerHTML = x;  // This line won't be executed until you resume
```

### **What Happens?**
1. The **first line** calculates `15 * 5` and assigns it to `x`.
2. The **second line**, `debugger;`, tells the browser to pause execution and open the **DevTools**.
3. The **third line** where the value of `x` is displayed will **not execute** until you **resume the script** in the debugger.

---

## **📌 How to Use the Debugger**

### **Steps to Use the `debugger` Keyword**:
1. **Add `debugger;`** to the part of your JavaScript code where you want to pause execution.
2. Open **DevTools** in the browser (`F12` or `Ctrl + Shift + I` / `Cmd + Option + I`).
3. Trigger the code (e.g., by refreshing the page or performing an action).
4. **Execution will pause** at the `debugger` statement, and you can **inspect variables**, **step through code**, and **use debugging features** like **call stack**, **scope**, and **watch expressions**.
5. **Resume execution** with the play button (`▶️`), or use **step controls** to move line-by-line through the code.

---

## **📌 Debugging Flow**

1. **Before Execution**:
   - Code runs normally.
   
2. **When `debugger;` is Hit**:
   - Execution **pauses** at the `debugger` statement.
   - You can now **inspect variables** and **analyze execution** using DevTools.
   
3. **Resume Execution**:
   - You can **resume** the script or **step through** to see how the code behaves.

---

## **📌 Example of Using the `debugger` with a Loop**

```js
for (let i = 0; i &lt; 5; i++) {
    debugger;  // Pauses here on each iteration
    console.log(i);
}
```
- The script will **pause** every time the loop runs.
- You can inspect **the value of `i`** at each iteration and check the **call stack** to ensure the loop is executing as expected.

---

## **📌 Key Takeaways**
✔ **The `debugger` statement pauses code execution and opens DevTools** when debugging is available.  
✔ **Use `debugger;` to inspect variables, call stacks, and control the flow of execution**.  
✔ **It's equivalent to manually setting a breakpoint** in DevTools.  
✔ **No debugger? The `debugger` statement does nothing and the code continues normally.**  
✔ **Helpful for stopping execution at specific points and analyzing code behavior**. 🚀"		
86	Style guide	Variable names	"### **Using camelCase for Identifiers in JavaScript**

In JavaScript, it's a common practice to use **camelCase** for naming **variables**, **functions**, and other identifiers. This means that:

- **The first word** starts with a lowercase letter.
- **Subsequent words** start with an uppercase letter.

#### **Example of camelCase**:
```js
let firstName = ""John"";     // Variable name
let calculateTotal = function(price, tax) { // Function name
    return price + tax;
};
```

---

### **📌 Key Rules for camelCase**
1. **Start with a lowercase letter**:
   - Example: `firstName`, `totalAmount`
   
2. **Use uppercase letters** for the first letter of each subsequent word:
   - Example: `calculateTotal`, `addProductToCart`

3. **Avoid using underscores or hyphens** between words.
   - ❌ **Incorrect**: `first_name`, `calculate-total`
   - ✅ **Correct**: `firstName`, `calculateTotal`

---

### **📌 Why Use camelCase?**
- **Consistency**: CamelCase helps maintain consistent and readable naming conventions across your code.
- **Standards**: Most JavaScript frameworks and libraries (such as React, Node.js, and Angular) follow camelCase, so using it in your own code ensures compatibility with best practices.
- **Readability**: It makes multi-word variable or function names easier to read and understand at a glance.

---

### **📌 Examples of camelCase Usage**

#### **1. Variables**
```js
let userAge = 30;
let productList = [""apple"", ""banana"", ""cherry""];
```

#### **2. Functions**
```js
function calculateDiscount(price, discountRate) {
    return price - (price * discountRate);
}
```

#### **3. Objects**
```js
let carDetails = {
    brandName: ""Toyota"",
    modelYear: 2020,
    isElectric: false
};
```

---

### **📌 Summary: camelCase Naming Convention**
- **First word**: Lowercase.
- **Subsequent words**: Uppercase first letter.
- **Example**: `userFirstName`, `calculateTotalPrice`.

---

### **📌 Key Takeaways**
✔ **Use camelCase for variables, functions, and other identifiers in JavaScript.**  
✔ **Avoid underscores (`_`) or hyphens (`-`) in variable names.**  
✔ **Start with lowercase letters and capitalize subsequent words for better readability and consistency.** 🚀"		
87	Style guide	Spaces Around Operators	"### **Best Practices: Spacing Around Operators and Commas in JavaScript**

To improve the **readability** and **maintainability** of your code, it's important to follow consistent spacing conventions. One such convention is to **put spaces around operators** (like `=`, `+`, `-`, `*`, `/`) and **after commas** in JavaScript.

---

## **📌 Spacing Around Operators**
Always put a **space before and after** operators to improve readability.

### **Correct Usage:**
```js
let x = 10 + 5;
let result = a * b / c;
```

### **Incorrect Usage:**
```js
let x=10+5;
let result=a*b/c;
```

✅ **Why?**  
- Spaces around operators make the code easier to scan and understand, especially when expressions grow more complex.

---

## **📌 Spacing After Commas**
When defining **arrays**, **objects**, or passing **function arguments**, always put a **space after commas** to separate items.

### **Correct Usage:**
```js
let numbers = [1, 2, 3, 4, 5];
let person = { name: 'John', age: 30, job: 'developer' };
function sum(a, b, c) {
    return a + b + c;
}
```

### **Incorrect Usage:**
```js
let numbers = [1,2,3,4,5];
let person = { name:'John', age:30, job:'developer' };
function sum(a,b,c) {
    return a+b+c;
}
```

✅ **Why?**
- Spaces after commas make it easier to distinguish between individual items or arguments, improving the clarity of the code.

---

## **📌 Summary**
1. **Always place a space around operators** (e.g., `=`, `+`, `-`, `*`, `/`).
2. **Always place a space after commas** in arrays, objects, and function parameters.

---

### **📌 Key Takeaways**
✔ **Spacing around operators and after commas improves readability.**  
✔ **It helps separate elements clearly and makes the code easier to understand.**  
✔ **This is a widely accepted JavaScript convention to improve consistency and clarity.** 🚀"		
88	Style guide	Code Indentation	"### **Indentation Best Practices in JavaScript**

Proper **indentation** is essential for code **readability** and **maintainability**. It helps you and others quickly understand the structure and logic of the code. 

---

## **📌 Rule: Always Use 2 Spaces for Indentation**
It is considered best practice to use **2 spaces** for **indentation** in JavaScript code, and **avoid using tabs** (tabulators).

### **Why Use 2 Spaces?**
- **Consistency**: Different developers use different text editors, and some editors may interpret tabs differently, causing inconsistent code formatting. Using **2 spaces** ensures consistency across different editors.
- **Readability**: Using **2 spaces** instead of tabs gives a clean, compact structure that is easy to read and navigate.
- **Widely Accepted**: Most JavaScript frameworks and style guides (like **Airbnb** and **Google JavaScript Style Guide**) recommend using **2 spaces** for indentation.

---

## **📌 Correct Example Using 2 Spaces**
```js
function calculateTotal(price, tax) {
  let total = price + tax;
  return total;
}

let totalAmount = calculateTotal(100, 10);
console.log(totalAmount);  // Output: 110
```

### **Explanation**:
- Each block inside the function is indented by **2 spaces**.

---

## **📌 Incorrect Example Using Tabs**
```js
function calculateTotal(price, tax) {
→	let total = price + tax;
→	return total;
}

let totalAmount = calculateTotal(100, 10);
console.log(totalAmount);  // Output: 110
```

### **Explanation**:
- Here, **tabs** are used for indentation, which could appear differently across editors and might cause alignment issues.

---

## **📌 Why Not Use Tabs?**
- **Inconsistent Appearance**: Different editors or environments may interpret a **tab** character as a different number of spaces, causing alignment issues and inconsistent code formatting.
- **Lack of Control**: You don’t have control over how many spaces a tab will represent in different editors, making collaboration with others potentially problematic.

---

## **📌 How to Set Your Editor to Use 2 Spaces Instead of Tabs**
### **Visual Studio Code (VSCode)**
1. Open **Command Palette** (`Ctrl + Shift + P` / `Cmd + Shift + P`).
2. Type **""settings""** and select **Preferences: Open User Settings**.
3. Search for **""tab size""**.
4. Set **""Tab Size""** to **2** and **""Insert Spaces""** to **true**.

### **Sublime Text**
1. Open **Preferences → Settings**.
2. Set:
   ```json
   ""tab_size"": 2,
   ""translate_tabs_to_spaces"": true
   ```

### **Atom**
1. Open **Settings → Editor**.
2. Check **""Soft Tabs""** and set the **Tab Length** to **2**.

---

## **📌 Summary**
- **Always use 2 spaces for indentation in JavaScript**.
- **Do not use tabs** as they can be interpreted inconsistently across different editors.
- **Most JavaScript style guides recommend using 2 spaces** for consistency and readability.

---

### **📌 Key Takeaways**
✔ **2 spaces for indentation ensure consistent, readable, and maintainable code**.  
✔ **Avoid using tabs**, as they are interpreted differently across editors and environments.  
✔ **Set your editor to use 2 spaces for consistent indentation** across your projects. 🚀"		
89	Style guide	Statement Rules	"### **Semicolon and Bracket Best Practices in JavaScript**

Proper usage of **semicolons** and **brackets** in JavaScript is essential for maintaining clean, readable, and consistent code. Adhering to consistent rules for simple and complex statements can help avoid potential issues and improve the clarity of your code.

---

## **📌 Simple Statements (Declarations)**

### **Rule: Always End Simple Statements with a Semicolon**
A **simple statement** in JavaScript typically includes **variable declarations**, **assignments**, **object creation**, and **array declarations**. These statements should always be terminated with a semicolon.

#### **Correct Example:**
```js
let x = 10;  // Variable declaration
const myArray = [1, 2, 3];  // Array declaration
const person = { name: 'Alice', age: 30 };  // Object declaration
```
✅ **End simple statements (variable declarations, object/array creation, etc.) with a semicolon.**

#### **Incorrect Example:**
```js
let x = 10  // Missing semicolon
const myArray = [1, 2, 3]  // Missing semicolon
const person = { name: 'Alice', age: 30 }  // Missing semicolon
```
❌ **Missing semicolons may cause errors or unexpected behavior.**

---

## **📌 Complex (Compound) Statements**

### **General Rules for Complex Statements (Functions, Loops, Conditionals, etc.)**

1. **Opening Bracket**: Put the **opening bracket** `{` at the **end of the first line**.
   - Example: In functions, conditionals, and loops, place `{` immediately after the condition or the function declaration.

2. **One Space Before Opening Bracket**: Always use **one space** between the statement (e.g., `if`, `for`, `function`) and the opening bracket `{`.

3. **Closing Bracket**: Place the **closing bracket** `}` on a new line, with **no leading spaces**.

4. **No Semicolon for Complex Statements**: Do **not end complex statements** (functions, loops, conditionals) with a semicolon.

---

### **Correct Example: Functions**
```js
function greet(name) {
  console.log('Hello ' + name);
}
```
✅ **The opening bracket is on the same line, the closing bracket is on a new line, and there is no semicolon after the function.**

### **Correct Example: Loops**
```js
for (let i = 0; i &lt; 5; i++) {
  console.log(i);
}
```
✅ **The opening bracket is on the same line as the loop, the closing bracket is on a new line, and no semicolon is used.**

### **Correct Example: Conditionals**
```js
if (x &gt; 5) {
  console.log('x is greater than 5');
} else {
  console.log('x is less than or equal to 5');
}
```
✅ **The opening bracket is on the same line as the `if`/`else`, and the closing bracket is on a new line with no semicolon.**

---

### **Incorrect Example: Function**
```js
function greet(name) { 
  console.log('Hello ' + name);;  // Semicolon at the end is unnecessary
}
```
❌ **Don’t add a semicolon after a complex statement like a function declaration.**

### **Incorrect Example: Loop**
```js
for (let i = 0; i &lt; 5; i++) 
  { 
    console.log(i);  // The opening bracket should be on the same line
  }
```
❌ **The opening bracket `{` should be placed at the end of the first line.**

---

## **📌 Summary of Rules**

| Statement Type               | Syntax Rules                                                           |
|------------------------------|------------------------------------------------------------------------|
| **Simple Statements**         | End with a semicolon (`let x = 10;`).                                  |
| **Complex Statements**        | - Opening bracket `{` on the same line with a space before it.        |
|                              | - Closing bracket `}` on a new line with no spaces before it.         |
|                              | - Do **not** end with a semicolon (functions, loops, conditionals).   |

---

### **📌 Key Takeaways**
✔ **Always end simple statements (variable declarations, object/array creation) with a semicolon.**  
✔ **For complex statements (functions, loops, conditionals):**  
   - Opening bracket `{` on the same line.  
   - Closing bracket `}` on a new line with no spaces.  
   - Do **not** end the statement with a semicolon.  
✔ **These formatting conventions improve readability and consistency** across your JavaScript code. 🚀"		
90	Style guide	Object Rules	"### **Object Formatting Best Practices in JavaScript**

To ensure your JavaScript objects are **clean**, **readable**, and **consistent**, follow these rules when defining and formatting objects. These best practices help to enhance the clarity of your code, making it easier to work with.

---

## **📌 Rules for Object Formatting**

### 1. **Place the Opening Bracket on the Same Line as the Object Name**
- The opening bracket `{` should immediately follow the object declaration.

#### **Correct Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer'
};
```

#### **Incorrect Example:**
```js
const person
  = {
    name: 'Alice',
    age: 30,
    job: 'Developer'
  };
```
❌ **Avoid splitting the declaration and the opening bracket.**

---

### 2. **Use a Colon Plus One Space Between Each Property and Its Value**
- After each **property name**, place a **colon (`:`)** followed by **one space** before its value.

#### **Correct Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer'
};
```

#### **Incorrect Example:**
```js
const person = {
  name:'Alice',
  age:30,
  job:'Developer'
};
```
❌ **Avoid placing the colon directly next to the property name.**

---

### 3. **Use Quotes Around String Values, Not Around Numeric Values**
- **String values** should be enclosed in quotes (`'` or `""`), but **numeric values** do not need quotes.

#### **Correct Example:**
```js
const person = {
  name: 'Alice',  // string with quotes
  age: 30,        // numeric value without quotes
  job: 'Developer'
};
```

#### **Incorrect Example:**
```js
const person = {
  name: 'Alice',
  age: '30',      // numeric value shouldn't have quotes
  job: 'Developer'
};
```
❌ **Avoid using quotes around numeric values.**

---

### 4. **Do Not Add a Comma After the Last Property-Value Pair**
- **Omit the comma** after the last property-value pair. This helps keep the code clean.

#### **Correct Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer'
};
```

#### **Incorrect Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer',  // unnecessary comma after last property
};
```
❌ **Do not include a trailing comma after the last property.**

---

### 5. **Place the Closing Bracket on a New Line, Without Leading Spaces**
- The **closing bracket (`}`)** should be on a new line, with **no spaces** before it.

#### **Correct Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer'
};
```

#### **Incorrect Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer' }
```
❌ **Avoid placing the closing bracket on the same line as the last property.**

---

### 6. **Always End an Object Definition with a Semicolon**
- **End the object definition with a semicolon** to follow consistent syntax and prevent potential issues.

#### **Correct Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer'
};
```

#### **Incorrect Example:**
```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer'
}
```
❌ **Always add a semicolon after an object definition.**

---

### 7. **Short Objects Can Be Written Compressed on One Line**
- If the object is small, you can write it **on one line**, separating properties with spaces (but no commas or extra spaces between the property-value pairs).

#### **Correct Example:**
```js
const person = { name: 'Alice', age: 30, job: 'Developer' };
```

#### **Incorrect Example:**
```js
const person = { name: 'Alice', age: 30, job: 'Developer', };
```
❌ **Avoid trailing commas and unnecessary extra spaces.**

---

## **📌 Summary of Object Formatting Rules**
| Rule | Description |
|------|-------------|
| **Opening Bracket** | Place on the same line as the object name. |
| **Colon &amp; Space** | Use colon followed by one space between properties and their values. |
| **String Values** | Enclose string values in quotes, but do not use quotes around numeric values. |
| **Trailing Comma** | Do not add a comma after the last property-value pair. |
| **Closing Bracket** | Place on a new line, without leading spaces. |
| **Semicolon** | Always end an object definition with a semicolon. |
| **Compressed Objects** | Short objects can be written on one line. |

---

### **📌 Key Takeaways**
✔ **Follow these formatting rules for consistent and readable object definitions in JavaScript.**  
✔ **Proper spacing, correct use of quotes, and avoiding unnecessary commas and spaces improve code clarity.**  
✔ **These practices align with common style guides and make collaboration easier.** 🚀"		
91	Style guide	Line Length	"### **Best Practices for Line Length and Breaking Long JavaScript Statements**

Maintaining readable and clean code is crucial for both development and collaboration. One common guideline is to **avoid lines longer than 80 characters**. This ensures that the code remains easy to read on smaller screens and prevents horizontal scrolling, making it more maintainable.

---

## **📌 Rule: Avoid Lines Longer Than 80 Characters**
### **Why?**
- **Improves readability**: Shorter lines are easier to read and understand, especially on smaller screens.
- **Prevents horizontal scrolling**: This avoids the need to scroll horizontally, which can be inconvenient and hard to maintain.
- **Better code review**: Smaller lines are easier to review, with fewer chances of missing details.

---

### **📌 Where to Break Long Statements**
When a line does not fit within the 80-character limit, **break the line after an operator or a comma**. This makes the break **logical** and keeps the code **aligned** for better readability.

---

### **Correct Example: Breaking a Line After an Operator**
```js
let totalPrice = price + tax + shipping + discount +
                 handlingFee - specialOfferDiscount;
```
✅ **Breaking the line after the `+` operator makes it clear where the calculation continues.**

#### **Incorrect Example**:
```js
let totalPrice = price + tax + shipping + discount + handlingFee - specialOfferDiscount;
```
❌ **This line is over 80 characters and is harder to read.**

---

### **Correct Example: Breaking a Line After a Comma**
When creating objects, arrays, or function arguments, it's best to break lines **after a comma**.

```js
const person = {
  name: 'Alice',
  age: 30,
  job: 'Developer',
  country: 'USA'
};

function sum(a, b, c, d) {
  return a + b + c + d;
}
```
✅ **Each property in the object and each parameter in the function is on its own line, making it easier to read and edit.**

#### **Incorrect Example**:
```js
const person = { name: 'Alice', age: 30, job: 'Developer', country: 'USA' };
```
❌ **This single line is long and difficult to maintain.**

---

### **📌 Additional Tips**
1. **Align Multiline Statements**: When breaking a long statement across multiple lines, align the break so that it’s clear where the statement continues.
   
2. **Use Consistent Formatting**: When breaking lines after operators, try to keep the **operator aligned** vertically to enhance the readability of the code.

### **Example with Operator and Comma Breaks**:
```js
let totalAmount = itemPrice + tax + shippingCost +
                  discount + serviceCharge;
                  
const user = {
  name: 'John',
  age: 28,
  occupation: 'Engineer',
  location: 'New York'
};
```

---

## **📌 Summary of Best Practices**
| Practice | Benefit |
|----------|---------|
| **Avoid lines longer than 80 characters** | Improves readability and prevents horizontal scrolling. |
| **Break lines after an operator or a comma** | Makes the breaks logical and easier to understand. |
| **Align code properly** | Makes the continuation of code clear and maintains consistency. |

---

### **📌 Key Takeaways**
✔ **Break long lines after operators or commas to maintain readability.**  
✔ **Keep lines under 80 characters to prevent scrolling and improve clarity.**  
✔ **Proper line breaks and alignment make the code easier to review, understand, and maintain.** 🚀"		
92	Style guide	Naming Conventions	"### **Best Practices for Naming Conventions in JavaScript, HTML, and CSS**

Proper naming conventions improve code **readability**, **maintainability**, and **consistency**. By following standardized rules for naming variables, functions, constants, and other identifiers, you make it easier to collaborate with other developers and maintain your code.

---

## **📌 JavaScript Naming Conventions**

### **1. camelCase for Variables and Function Names**
- **Use camelCase** for **variables** and **function names**. This convention starts with a lowercase letter and capitalizes each subsequent word.

#### **Correct Example:**
```js
let totalAmount = 100;
function calculateTotal(price, tax) {
  return price + tax;
}
```

#### **Incorrect Example:**
```js
let TotalAmount = 100;  // Should be in camelCase
function CalculateTotal(price, tax) { // Should be in camelCase
  return price + tax;
}
```
❌ **Avoid capitalizing the first letter** in variable and function names.

---

### **2. UPPERCASE for Global Variables and Constants**
- **Global variables** and **constants** (e.g., `PI`) should be written in **UPPERCASE** to differentiate them from regular variables.

#### **Correct Example:**
```js
const PI = 3.14159;
let GLOBAL_VARIABLE = ""Global scope data"";
```

#### **Incorrect Example:**
```js
const pi = 3.14159;  // Should be UPPERCASE for constants
let globalVariable = ""Global scope data"";  // Should be UPPERCASE for global variables
```
❌ **Avoid using lowercase or camelCase for constants and global variables.**

---

### **3. Avoid Using `$` Sign in Names**
- Do **not start names with a `$`** sign, as it can conflict with popular JavaScript libraries (like jQuery).

#### **Correct Example:**
```js
let totalAmount = 100;
function calculateDiscount(price) {
  return price * 0.1;
}
```

#### **Incorrect Example:**
```js
let $totalAmount = 100;  // Avoid using $ in variable names
function $calculateDiscount(price) {
  return price * 0.1;
}
```
❌ **Avoid using the `$` sign** for variable and function names to avoid conflicts.

---

## **📌 HTML and CSS Naming Conventions**

### **1. Hyphens in HTML and CSS**
- **HTML5 attributes** can start with `data-` (e.g., `data-quantity`, `data-price`).
- **CSS property names** typically use **hyphens** (e.g., `font-size`, `background-color`).

#### **Correct Example in HTML:**
```html
<div data-quantity=""10"" data-price=""100""></div>
```

#### **Correct Example in CSS:**
```css
body {
  font-size: 16px;
  background-color: #f0f0f0;
}
```

---

### **2. Hyphens in JavaScript**  
- **Do not use hyphens** in JavaScript variable names, as hyphens are treated as **subtraction operators**.

#### **Incorrect Example:**
```js
let total-price = 100;  // Invalid in JavaScript
```

#### **Correct Example (camelCase):**
```js
let totalPrice = 100;  // Correct in JavaScript (camelCase)
```
❌ **Avoid using hyphens** in JavaScript variable names.

---

### **3. Underscores in Naming**
- **Underscores** are often used in certain contexts, especially in **SQL databases**, or when interacting with some legacy systems.

#### **Correct Example in SQL or Legacy Context:**
```js
let date_of_birth = ""1990-01-01"";
```

#### **Incorrect Example in JavaScript:**
```js
let date_of_birth = ""1990-01-01""; // Avoid underscores in JavaScript
```
❌ **In JavaScript**, prefer **camelCase** for naming instead of underscores.

---

## **📌 Summary of Naming Conventions**
| Type                        | Convention                                 | Example                 |
|-----------------------------|--------------------------------------------|-------------------------|
| **Variables and Functions**  | camelCase (lowercase first word, uppercase subsequent words) | `let totalAmount = 100;` |
| **Global Variables**         | UPPERCASE                                  | `let GLOBAL_VARIABLE = 100;` |
| **Constants**                | UPPERCASE                                  | `const PI = 3.14159;`   |
| **HTML5 Attributes**         | Hyphen-separated (`data-*`)                | `data-quantity=""10""`     |
| **CSS Properties**           | Hyphen-separated                           | `font-size: 16px;`       |
| **JavaScript Names**         | No hyphens or underscores, use camelCase   | `let totalPrice = 100;`  |
| **Avoid `$` in JavaScript**  | Do not use `$` at the beginning of names   | `let totalAmount = 100;` |

---

### **📌 Key Takeaways**
✔ **Use `camelCase` for variables and functions in JavaScript.**  
✔ **Use `UPPERCASE` for constants and global variables.**  
✔ **Avoid using the `$` sign in variable and function names.**  
✔ **For HTML5 attributes, use hyphens (`data-*`).**  
✔ **Use hyphens for CSS property names, but **not** in JavaScript variable names.**  
✔ **Underscores are acceptable in specific cases like SQL databases, but avoid them in JavaScript.** 🚀"		
93	Best practices	General	"### **JavaScript Best Practices**

Following best practices in JavaScript helps you write **clean**, **maintainable**, and **efficient** code. Below is a summary of important guidelines to follow for **variable management**, **comparison operators**, **function handling**, and **other general JavaScript practices**.

---

## **📌 Avoid Global Variables**
- **Avoid global variables** wherever possible, as they can lead to conflicts or unintended behavior.
- **Use local variables** within functions and learn how to work with **closures** to preserve state without polluting the global scope.

### **Example:**
```js
function example() {
  let localVar = ""I'm local""; // local variable
}
```

---

## **📌 Always Declare Local Variables**
- **Always declare variables** with `var`, `let`, or `const` to prevent them from becoming **global** by accident.
  
### **Correct Example**:
```js
let localVar = 10;
```

### **Incorrect Example** (Implicit Global):
```js
localVar = 10;  // Implicitly creates a global variable
```

---

## **📌 Use Strict Mode**
- Enabling **Strict Mode** helps catch common coding mistakes by throwing errors for potentially unsafe actions.
  
### **Enable Strict Mode**:
```js
""use strict"";
let x = 10; // Throws an error if we try to use an undeclared variable
```

---

## **📌 Declarations on Top (Hoisting)**
- **Declare variables at the top** of their scope. JavaScript automatically hoists variable declarations to the top of their scope.
- This applies even to **loop variables**.

### **Correct Example**:
```js
let x = 10; // Declare at the top
for (let i = 0; i &lt; 5; i++) {
  console.log(i);
}
```

---

## **📌 Initialize Variables When You Declare Them**
- **Always initialize variables** when declaring them to avoid unintentional behavior caused by uninitialized variables.

### **Correct Example**:
```js
let x = 10;
```

### **Incorrect Example**:
```js
let x;  // Uninitialized
console.log(x); // undefined
```

---

## **📌 Never Declare Primitives as New Objects**
- Do **not declare primitive types (numbers, strings, booleans)** using the `new` keyword, as this is unnecessary and may cause unexpected behavior.

### **Incorrect Example**:
```js
let num = new Number(5);  // Avoid this
let str = new String(""hello"");  // Avoid this
```

### **Correct Example**:
```js
let num = 5;
let str = ""hello"";
```

---

## **📌 Beware of Automatic Type Conversions**
- JavaScript performs **implicit type conversions** (also known as type coercion). Be cautious when performing operations on different data types, as **numbers can be converted to strings**, or **NaN** can appear unexpectedly.

### **Example**:
```js
let num = 10;
let str = ""20"";
console.log(num + str); // 1020 (number is converted to a string)
```

---

## **📌 JavaScript is Loosely Typed**
- JavaScript allows variables to **hold different types of data** at different points in time. A variable can **change its data type** during execution.

### **Example**:
```js
let x = 10; // number
x = ""hello""; // string
x = true; // boolean
```

---

## **📌 Use `===` for Comparison**
- Always use **strict comparison** (`===`) to avoid type coercion, which can lead to unexpected results.

### **Correct Example**:
```js
if (x === 10) {
  console.log(""Strict equality: true"");
}
```

### **Incorrect Example**:
```js
if (x == 10) {
  console.log(""Loose equality: true"");
}
```

---

## **📌 Use Parameter Defaults Inside Function Declarations**
- To avoid `undefined` values when arguments are missing in function calls, use **default parameters** for function arguments.

### **Correct Example**:
```js
function greet(name = ""Guest"") {
  console.log(""Hello, "" + name);
}

greet(); // Hello, Guest
greet(""Alice""); // Hello, Alice
```

---

## **📌 End Switch Statements with Default**
- Always include a **default** case in **switch statements** to handle unmatched cases.

### **Correct Example**:
```js
switch (day) {
  case 1:
    console.log(""Monday"");
    break;
  case 2:
    console.log(""Tuesday"");
    break;
  default:
    console.log(""Invalid day"");
}
```

---

## **📌 Strict Comparison in Switch Statements**
- In **switch** statements, always use strict equality (`===`) for comparisons.

### **Correct Example**:
```js
switch (value) {
  case 10:
    console.log(""Value is 10"");
    break;
  default:
    console.log(""Default case"");
}
```

---

## **📌 Floating Point Precision**
- Be cautious when working with **floating-point numbers** in JavaScript. Due to their 64-bit representation, calculations involving decimals (like `0.1 + 0.2`) can lead to unexpected results.

### **Example**:
```js
console.log(0.1 + 0.2);  // 0.30000000000000004, not exactly 0.3
```

---

## **📌 Avoid Line Breaks in Function Return Statements**
- Do **not break return statements** across multiple lines. Keeping it on one line improves readability.

### **Correct Example**:
```js
return result + 10;
```

### **Incorrect Example**:
```js
return 
  result + 10;  // This will return `undefined`
```

---

## **📌 Undefined is Not Null**
- **`undefined`** and **`null`** are two distinct values in JavaScript:
  - **`undefined`** represents a variable that has been declared but not assigned a value.
  - **`null`** is an assignment value that represents an intentional absence of any value.

### **Example**:
```js
let x; // undefined
let y = null; // null
```

---

## **📌 Summary of Best Practices**
| Practice | Description |
|----------|-------------|
| **Avoid Global Variables** | Use local variables and closures instead. |
| **Declare Variables with `let` or `const`** | Always declare variables to avoid them becoming global. |
| **Use Strict Mode** | Helps catch errors and improves security. |
| **Declarations on Top** | JavaScript hoists declarations, so declare variables at the top of the block. |
| **Initialize Variables** | Initialize variables at the point of declaration. |
| **Avoid `new` with Primitives** | Don’t declare numbers, strings, or booleans as new objects. |
| **Be Cautious of Type Coercion** | Use strict comparison (`===`) to avoid implicit type conversions. |
| **Use Default Parameters** | Set default values in function parameters. |
| **End Switch with Default** | Always have a default case in switch statements. |
| **Be Careful with Floating Point Precision** | Avoid unexpected results with floating-point operations. |
| **Don’t Break Return Statements** | Keep return statements on a single line. |
| **Remember `undefined` is not `null`** | Treat `undefined` and `null` as distinct values. |

---

### **📌 Key Takeaways**
✔ **Follow best practices for variable management, function handling, and type safety.**  
✔ **Use strict comparison (`===`) and be aware of type conversions.**  
✔ **Ensure proper syntax for objects, switch statements, and function declarations.**  
✔ **Take extra care with floating-point numbers and avoid pitfalls with `undefined` and `null`.** 🚀"		
94	Best practices	New object()	"### **Best Practices: Avoid Using `new` with Primitives and Built-in Objects**

In JavaScript, it's best practice to use **literal notation** for creating values instead of the `new` keyword, which can lead to **unnecessary object creation** and **unexpected behavior**. Using the appropriate literal notation makes your code more **efficient**, **consistent**, and **easy to read**.

---

## **📌 Use `{}` Instead of `new Object()`**
Instead of creating an empty object with `new Object()`, you can use the **literal notation** `{}`.

### **Correct Example**:
```js
let person = {};  // Object literal notation
```

### **Incorrect Example**:
```js
let person = new Object();  // Avoid using new Object()
```
❌ **Avoid `new Object()`, as it is more verbose and unnecessary.**

---

## **📌 Use `""asdf""` Instead of `new String()`**
Instead of using `new String()` to create a string object, use the string literal `""asdf""`.

### **Correct Example**:
```js
let name = ""Alice"";  // String literal
```

### **Incorrect Example**:
```js
let name = new String(""Alice"");  // Avoid using new String()
```
❌ **Using `new String()` creates a String object, which is unnecessary and leads to unexpected behavior when comparing.**

---

## **📌 Use `123` Instead of `new Number()`**
Instead of creating a number object with `new Number()`, use the **numeric literal** `123`.

### **Correct Example**:
```js
let age = 30;  // Numeric literal
```

### **Incorrect Example**:
```js
let age = new Number(30);  // Avoid using new Number()
```
❌ **Avoid using `new Number()`, which creates a number object and can cause problems with type comparison.**

---

## **📌 Use `false` Instead of `new Boolean()`**
Instead of using `new Boolean()` to create a Boolean object, use the **Boolean literal** `false`.

### **Correct Example**:
```js
let isActive = false;  // Boolean literal
```

### **Incorrect Example**:
```js
let isActive = new Boolean(false);  // Avoid using new Boolean()
```
❌ **Using `new Boolean()` results in a Boolean object rather than a primitive, which can cause issues in conditions.**

---

## **📌 Use `[]` Instead of `new Array()`**
Instead of using `new Array()` to create an array, use the **array literal** `[]`.

### **Correct Example**:
```js
let numbers = [1, 2, 3];  // Array literal
```

### **Incorrect Example**:
```js
let numbers = new Array(1, 2, 3);  // Avoid using new Array()
```
❌ **Avoid using `new Array()`, as it can lead to confusion and unexpected behavior, especially when passing a single numeric argument.**

---

## **📌 Use `/()/` Instead of `new RegExp()`**
Instead of creating a regular expression object with `new RegExp()`, use the **regular expression literal** `/()/`.

### **Correct Example**:
```js
let regex = /[a-zA-Z]/;  // Regular expression literal
```

### **Incorrect Example**:
```js
let regex = new RegExp(""[a-zA-Z]"");  // Avoid using new RegExp()
```
❌ **Avoid using `new RegExp()` unless you need to create the regular expression dynamically.**

---

## **📌 Use `function() {}` Instead of `new Function()`**
Instead of using `new Function()`, use the **function literal** `function() {}` to define functions.

### **Correct Example**:
```js
function greet(name) {
  return ""Hello, "" + name;
}
```

### **Incorrect Example**:
```js
let greet = new Function(""name"", ""return 'Hello, ' + name;"");  // Avoid using new Function()
```
❌ **Avoid using `new Function()` as it is less readable and can introduce security risks when dealing with dynamic code.**

---

## **📌 Why Avoid `new` with Built-in Objects?**

1. **Performance**: Using literals is **faster** and **more efficient** than using `new` to create objects.
2. **Clarity**: Using literal syntax makes the intent of your code clearer and more consistent with other JavaScript code.
3. **Avoids Unintended Behavior**: Some built-in objects like `String`, `Number`, and `Boolean` created with `new` are **objects**, not primitive values, which can lead to unexpected behavior, especially in comparisons.

---

## **📌 Summary of Best Practices**

| Practice | Description |
|----------|-------------|
| **Use `{}` instead of `new Object()`** | Use object literal notation to create objects. |
| **Use `""asdf""` instead of `new String()`** | Use string literals for strings. |
| **Use `123` instead of `new Number()`** | Use numeric literals for numbers. |
| **Use `false` instead of `new Boolean()`** | Use Boolean literals for boolean values. |
| **Use `[]` instead of `new Array()`** | Use array literal notation for arrays. |
| **Use `/()/` instead of `new RegExp()`** | Use regular expression literals. |
| **Use `function() {}` instead of `new Function()`** | Use function literals to define functions. |

---

### **📌 Key Takeaways**
✔ **Prefer using literals (e.g., `{}`, `""asdf""`, `123`, `[]`) over `new` for built-in objects** to avoid unnecessary complexity.  
✔ **Literals are more efficient, readable, and prevent unintended behavior** when compared to using constructors like `new Object()` or `new String()`.  
✔ **Use the appropriate literal for each data type** (object, string, number, array, etc.) to follow best practices in JavaScript. 🚀"		
95	JSON	Introduction	"### **JSON: JavaScript Object Notation**

JSON (JavaScript Object Notation) is a lightweight, **text-based format** for **storing and exchanging data**. It's widely used for transmitting data between a client (browser) and a server, due to its simplicity and efficiency.

---

## **📌 Key Characteristics of JSON**
1. **Syntax**: JSON uses **JavaScript object notation**, but it is **language-independent** and can be used in various programming languages.
2. **Text-based**: JSON is a string format, which makes it ideal for data exchange over networks (e.g., between a server and a client).
3. **JavaScript Compatibility**: Since JSON is derived from JavaScript object notation, it maps directly to JavaScript objects, arrays, numbers, and strings.

---

## **📌 Converting JavaScript Objects to JSON**
JavaScript objects can be converted to JSON using the `JSON.stringify()` method.

### **Example: Converting a JavaScript Object to JSON**
```js
let person = {
  name: ""Alice"",
  age: 30,
  job: ""developer""
};

let jsonPerson = JSON.stringify(person);  // Convert to JSON
console.log(jsonPerson);
// Output: '{""name"":""Alice"",""age"":30,""job"":""developer""}'
```
- The **`JSON.stringify()`** method converts the `person` object into a JSON string.

---

## **📌 Converting JSON to JavaScript Objects**
JSON data received from the server can be converted back into a JavaScript object using the `JSON.parse()` method.

### **Example: Converting JSON to a JavaScript Object**
```js
let jsonPerson = '{""name"":""Alice"",""age"":30,""job"":""developer""}';

let person = JSON.parse(jsonPerson);  // Convert JSON to object
console.log(person);
// Output: { name: ""Alice"", age: 30, job: ""developer"" }
```
- The **`JSON.parse()`** method converts the JSON string into a JavaScript object, so we can work with it directly.

---

## **📌 Why Use JSON?**
1. **Simplicity**: JSON is easy to read and write for humans and machines alike.
2. **Lightweight**: JSON is more compact than XML and easier to transmit over the web.
3. **JavaScript Compatibility**: JSON maps directly to JavaScript objects, making it easier to work with data.
4. **Language Agnostic**: While JSON uses JavaScript object notation, it's supported by many programming languages.

---

## **📌 JSON Syntax Rules**
1. **Objects**: An object is enclosed in curly braces `{}` and contains key-value pairs separated by commas. Keys must be strings (in double quotes), and values can be strings, numbers, arrays, booleans, or other objects.
   - Example: `{""name"": ""Alice"", ""age"": 30}`

2. **Arrays**: An array is enclosed in square brackets `[]` and contains a list of values separated by commas.
   - Example: `[""apple"", ""banana"", ""cherry""]`

3. **Strings**: A string is enclosed in double quotes `""""`. Strings can contain text, numbers, or special characters.
   - Example: `""Hello, world!""`

4. **Numbers**: JSON supports both integers and floating-point numbers.
   - Example: `123`, `45.67`

5. **Booleans**: JSON supports `true` or `false` values.
   - Example: `true`, `false`

6. **Null**: JSON also has a `null` value.
   - Example: `null`

---

## **📌 Example of a Full JSON Object**
```json
{
  ""name"": ""Alice"",
  ""age"": 30,
  ""job"": ""developer"",
  ""isEmployed"": true,
  ""skills"": [""JavaScript"", ""Python"", ""CSS""],
  ""address"": {
    ""street"": ""123 Main St"",
    ""city"": ""Wonderland""
  }
}
```

- **Keys** are always in double quotes.
- **Values** can be strings, numbers, booleans, arrays, objects, or null.

---

## **📌 Summary**
1. **JSON (JavaScript Object Notation)** is a lightweight text-based format for storing and exchanging data.
2. **JSON is easy to read and write** for both humans and machines, and it can be converted directly to and from JavaScript objects.
3. **Use `JSON.stringify()`** to convert JavaScript objects to JSON strings, and **use `JSON.parse()`** to convert JSON strings into JavaScript objects.
4. **JSON syntax** follows a simple structure using key-value pairs, arrays, strings, numbers, booleans, and null values.

---

### **📌 Key Takeaways**
✔ **JSON is a text format for exchanging data**, easily converted to and from JavaScript objects.  
✔ **Use `JSON.stringify()`** to convert objects to JSON and **`JSON.parse()`** to convert JSON back to objects.  
✔ **JSON is lightweight and widely used**, making it a great choice for data exchange. 🚀"		
96	JSON	Syntax	"### **JSON Syntax: Understanding Key Concepts**

JSON (JavaScript Object Notation) is derived from JavaScript's object notation syntax but is language-independent. It is used primarily for **data exchange** and **storage**.

Here are some core features of JSON syntax:

---

## **📌 Key Features of JSON Syntax**

1. **Data in Name/Value Pairs**:
   - Data in JSON is stored as **name/value pairs** (also known as key-value pairs). Each name (or key) is a string, and the value can be any valid JSON data type.
   
   ### **Example:**
   ```json
   ""firstName"": ""John""
   ```

2. **Data is Separated by Commas**:
   - In JSON, **multiple name/value pairs** are separated by commas.
   
   ### **Example**:
   ```json
   ""firstName"": ""John"", ""lastName"": ""Doe""
   ```

3. **Curly Braces Hold Objects**:
   - JSON **objects** are enclosed in curly braces `{}`. An object is a collection of key-value pairs.

   ### **Example of a JSON Object**:
   ```json
   {
     ""firstName"": ""John"",
     ""lastName"": ""Doe""
   }
   ```

4. **Square Brackets Hold Arrays**:
   - JSON **arrays** are enclosed in square brackets `[]` and can hold multiple values, including objects, numbers, or strings.

   ### **Example of a JSON Array**:
   ```json
   [""apple"", ""banana"", ""cherry""]
   ```

---

## **📌 Example of JSON Data Structure**

Let's look at a complete JSON example that includes an array and objects:

```js
var text = { 
  ""employees"": [
    {""firstName"": ""John"", ""lastName"": ""Doe""},
    {""firstName"": ""Anna"", ""lastName"": ""Smith""},
    {""firstName"": ""Peter"", ""lastName"": ""Jones""}
  ]
};
```

In this example:
- **""employees""** is the key (or name) for the array of employee objects.
- Each object inside the array has **two properties**: `""firstName""` and `""lastName""`.

---

## **📌 Converting JSON to JavaScript Object**
You can convert a **JSON string** to a **JavaScript object** using `JSON.parse()`.

### **Example**:
```js
var obj = JSON.parse(text);
console.log(obj.employees[0].firstName);  // Output: ""John""
```

In the example above:
- `JSON.parse(text)` converts the **JSON string** into a JavaScript object.
- You can then access the object’s properties (like `obj.employees[0].firstName`) in the usual way.

---

## **📌 Summary of JSON Syntax**
- **Name/Value Pairs**: Data is structured in key-value pairs.
- **Curly Braces `{}`**: Used to define objects.
- **Square Brackets `[]`**: Used to define arrays.
- **Commas**: Separate key-value pairs within objects and array elements.

---

### **📌 Key Takeaways**
✔ **JSON data is structured using name/value pairs**, objects (`{}`), and arrays (`[]`).  
✔ **Use `JSON.parse()`** to convert JSON text into JavaScript objects.  
✔ **JSON provides a compact, human-readable format** for exchanging data between client and server. 🚀"		
97	JSON	Sending Data	"### **Converting JavaScript Objects to JSON for Server Communication**

When you need to send data from a **JavaScript object** to a server, you can **convert the object into JSON** using the `JSON.stringify()` method. JSON is the standard format for data exchange between a client (like a web browser) and a server.

---

## **📌 Example: Converting a JavaScript Object to JSON**

### **Step 1: Create a JavaScript Object**
```js
var myObj = { name: ""John"", age: 31, city: ""New York"" };
```

Here, we have a simple JavaScript object `myObj` with **three properties**: `name`, `age`, and `city`.

### **Step 2: Convert the Object to JSON**
Use `JSON.stringify()` to convert the JavaScript object into a **JSON string**.
```js
var myJSON = JSON.stringify(myObj);
```
This will convert the `myObj` object into a JSON string like this:
```json
{""name"":""John"",""age"":31,""city"":""New York""}
```

### **Step 3: Send the JSON to the Server**
Once you have the object converted into JSON, you can send it to the server (e.g., via a URL or an HTTP request).

In this example, the JSON is passed in the **URL** as a query parameter (`x`):
```js
window.location = ""demo_json.php?x="" + myJSON;
```
This sends the JSON string to the server at `demo_json.php` via a query parameter named `x`.

---

## **📌 Handling Date Objects in JSON**

In JSON, **date objects are not allowed**. When you try to convert a JavaScript **`Date`** object into JSON, the `JSON.stringify()` function will **automatically convert it to a string**. 

### **Example: Converting a Date Object**
```js
var myDate = new Date();
var myObjWithDate = { name: ""John"", birthdate: myDate };

var myJSON = JSON.stringify(myObjWithDate);
console.log(myJSON);
```
Output might look like:
```json
{""name"":""John"",""birthdate"":""2023-03-02T12:34:56.789Z""}
```
- The `birthdate` property is converted into a string representing the date and time in ISO format.
  
---

## **📌 Why are Date Objects Not Allowed in JSON?**

- **JSON specification** does not have a native data type for date objects.
- JavaScript's **`Date`** object is converted into a string when stringified because the JSON format is **not aware of the `Date` type**.
- Using the **ISO 8601** format for dates (e.g., `""2023-03-02T12:34:56.789Z""`) ensures that date information is preserved as a string.

---

### **📌 Key Takeaways**
✔ **Convert JavaScript objects to JSON** using `JSON.stringify()` for easy data transfer to a server.  
✔ **Date objects are converted into strings** by `JSON.stringify()`, as JSON does not support the `Date` type.  
✔ **Sending JSON data to a server** is commonly done through query parameters, POST requests, or API calls.  
✔ **When handling dates**, store them as **strings** (ISO 8601 format) when transferring data to or from the server. 🚀"		
98	JSON	Receiving Data	"### **Converting JSON to JavaScript Object**

When you receive **JSON data** (typically as a string) from a server or external source, you can easily **convert it into a JavaScript object** using the `JSON.parse()` method. Once converted, you can work with the data just like any other JavaScript object.

---

## **📌 Example: Converting JSON to a JavaScript Object**

### **Step 1: Receive JSON Data**

Let’s say you receive the following **JSON data**:
```js
var myJSON = '{""name"":""John"", ""age"":31, ""city"":""New York""}';
```
This is a JSON string representing an object with three properties: `name`, `age`, and `city`.

### **Step 2: Convert JSON to JavaScript Object**

You can convert the **JSON string** into a **JavaScript object** using the `JSON.parse()` method:
```js
var myObj = JSON.parse(myJSON);
```
Now, `myObj` is a **JavaScript object** with the following structure:
```js
{
  name: ""John"",
  age: 31,
  city: ""New York""
}
```

### **Step 3: Access Object Properties**

Once you have the JavaScript object, you can easily access its properties. For example, to display the `name` property in the HTML:

```js
document.getElementById(""demo"").innerHTML = myObj.name;
```

This will display `""John""` in the element with the `id=""demo""`.

---

## **📌 Full Example in HTML:**
```html




<p id=""demo""></p>





```
### **Explanation**:
- The **`JSON.parse()`** method converts the **JSON string** into a JavaScript object.
- **`myObj.name`** is used to access the `name` property from the object and display it inside the HTML element with `id=""demo""`.

---

## **📌 Key Takeaways**
✔ **Use `JSON.parse()`** to convert JSON data into a JavaScript object.  
✔ Once converted, **work with the data as a regular JavaScript object**.  
✔ You can **access the properties** of the object using dot notation (`myObj.name`).  
✔ **This method is commonly used** for handling data received from a server or API in JSON format. 🚀"		
99	JSON	Stringify Functions	"### **JSON and Functions**

JSON (JavaScript Object Notation) is designed to store and exchange **data**. However, **functions are not allowed** as object values in JSON. JSON is meant to represent **simple data structures** (strings, numbers, arrays, booleans, and null), not executable code like functions. If you try to include functions in a JavaScript object and then convert that object into JSON, the functions will be removed.

---

## **📌 Functions in JSON Objects**

When you try to **convert an object with functions** into JSON using `JSON.stringify()`, the functions are **removed** from the resulting JSON string. This is because JSON is **data-only** and doesn't support functions.

### **Example: Converting Object with Functions to JSON**
```js
var person = {
  name: ""Alice"",
  greet: function() {
    return ""Hello, "" + this.name;
  }
};

var jsonPerson = JSON.stringify(person);
console.log(jsonPerson);  // Output: {""name"":""Alice""}
```
- **The `greet` function is omitted** from the JSON string because JSON doesn't support functions.

---

## **📌 Converting Functions into Strings**

If you need to **send functions** as part of the JSON data, you can **convert the functions to strings** before calling `JSON.stringify()`. This allows you to send the function's code as a string, but keep in mind that the function will lose its scope and behavior when parsed back.

### **Example: Converting Function to String**
```js
var person = {
  name: ""Alice"",
  greet: function() {
    return ""Hello, "" + this.name;
  }
};

var jsonPerson = JSON.stringify(person, function(key, value) {
  if (typeof value === ""function"") {
    return value.toString();  // Convert function to string
  }
  return value;
});

console.log(jsonPerson);
// Output: {""name"":""Alice"",""greet"":""function() { return 'Hello, ' + this.name; }""}
```
- Here, **the function is converted to a string** in the JSON, but when you retrieve the JSON data, you'll need to **recreate the function** manually if you need to use it.

---

## **📌 Avoid Using Functions in JSON**

Using functions in JSON is generally **not recommended** for a few reasons:
1. **Scope Loss**: When you convert a function to a string, it loses its scope, and you cannot execute it as a function anymore.
2. **Reconstruction of Functions**: If you really need to use functions in the future, you'd need to **use `eval()`** to reconstruct them, which introduces **security risks**.

### **Example of Reconstructing Function with `eval()`**
```js
var jsonPerson = '{""name"":""Alice"",""greet"":""function() { return \'Hello, \' + this.name; }""}';
var person = JSON.parse(jsonPerson);
person.greet = eval('(' + person.greet + ')'); // Rebuild the function from string
console.log(person.greet());  // Output: ""Hello, Alice""
```
- **Using `eval()`** allows you to reintroduce the function, but it comes with **security risks** because it executes the string as JavaScript code.

---

## **📌 Best Practices**
- **Avoid sending functions in JSON**: Instead of including functions in your JSON, try to send just the necessary data and handle logic on the client or server side.
- **Use function references**: If you must send function-like behavior, consider sending **function names** and then defining the functions on the receiving end (e.g., with callbacks or event handlers).
- **Don't use `eval()`**: Using `eval()` for reconstructing functions is **dangerous** and should be avoided due to the potential for **code injection** and **security vulnerabilities**.

---

## **📌 Summary**
1. **JSON cannot include functions**. If you try to send an object with functions, they will be **removed** by `JSON.stringify()`.
2. **Convert functions into strings** if you must include them in JSON, but keep in mind the function will lose its scope and behavior.
3. **Avoid using functions in JSON** and **never use `eval()`** to reconstruct them due to potential security risks.

---

### **📌 Key Takeaways**
✔ **JSON is for data only**—functions are not supported in JSON.  
✔ **Convert functions to strings** before sending them in JSON, but beware of scope loss and security risks.  
✔ **Avoid using `eval()`** to reconstruct functions from JSON due to security concerns.  
✔ **Send only the necessary data in JSON** and keep logic separate. 🚀"		
100	JSON	JSON - Comparision to JavaScript Objects	"### **JSON vs JavaScript Objects: Key Differences**

While **JSON** (JavaScript Object Notation) and **JavaScript objects** share many similarities, they also have some key differences. Understanding these differences is important when working with **data exchange** and **serialization**.

---

## **📌 JSON vs JavaScript Objects: Syntax Differences**

### **1. Keys in JSON**
- **JSON**: Keys (also called **property names**) **must be strings** and must always be written with **double quotes**.
  - Example:
    ```json
    { ""name"": ""John"" }
    ```
  
- **JavaScript**: Keys can be **strings**, **numbers**, or **identifier names**. You can also use **single or double quotes** around string keys.
  - Example:
    ```js
    { name: 'John' }
    ```

#### **Key Differences**:
- In **JSON**, keys **must** be surrounded by **double quotes**.
- In **JavaScript**, keys can be written without quotes if they follow valid identifier rules (e.g., `name`), and strings can be enclosed in **single** or **double quotes**.

---

### **2. String Values**
- **JSON**: String values must be enclosed in **double quotes**.
  - Example:
    ```json
    { ""name"": ""John"" }
    ```

- **JavaScript**: String values can be enclosed in **single quotes** or **double quotes**.
  - Example:
    ```js
    { name: 'John' }
    ```

#### **Key Differences**:
- **JSON** only allows **double quotes** for strings, whereas **JavaScript** allows both **single and double quotes**.

---

## **📌 Supported Data Types: JSON vs JavaScript Objects**

### **3. Valid Data Types in JSON**
In **JSON**, values can only be of the following data types:
- **String**: `""John""`
- **Number**: `31`
- **Object**: `{ ""name"": ""John"", ""age"": 30 }`
- **Array**: `[1, 2, 3]`
- **Boolean**: `true` or `false`
- **Null**: `null`

#### **Example of JSON**:
```json
{
  ""name"": ""John"",
  ""age"": 30,
  ""isEmployed"": true,
  ""skills"": [""JavaScript"", ""HTML"", ""CSS""],
  ""address"": {
    ""city"": ""New York"",
    ""country"": ""USA""
  },
  ""birthdate"": null
}
```

### **4. Valid Data Types in JavaScript**
In **JavaScript**, values can be all of the types allowed in JSON, plus additional JavaScript-specific types:
- **String**: `'John'`, `""Alice""`
- **Number**: `30`, `3.14`
- **Object**: `{ name: 'John' }`
- **Array**: `[1, 2, 3]`
- **Boolean**: `true`, `false`
- **Null**: `null`
- **Function**: `function() { return 'hello'; }`
- **Date**: `new Date()`
- **Undefined**: `undefined`

#### **Example of JavaScript Object**:
```js
var myObj = {
  name: 'John',
  age: 30,
  isEmployed: true,
  skills: ['JavaScript', 'HTML', 'CSS'],
  birthdate: null,
  greet: function() { return 'Hello, ' + this.name; },
  dateOfBirth: new Date(),
  extraData: undefined
};
```

#### **Key Differences**:
- **JSON** does not allow **functions**, **dates**, or **undefined** as valid values.
- **JavaScript** objects can include **functions** (methods), **Date objects**, and **undefined**.

---

## **📌 Summary of Key Differences**

| Aspect                     | JSON                                   | JavaScript Objects                 |
|----------------------------|---------------------------------------|------------------------------------|
| **Keys**                    | Must be strings, enclosed in double quotes | Can be strings, numbers, or identifiers; can use single or double quotes |
| **String Values**           | Must be in double quotes               | Can be in single or double quotes  |
| **Allowed Data Types**      | String, Number, Object, Array, Boolean, Null | All JSON data types plus Function, Date, and Undefined |
| **Functions**               | Not allowed in JSON                   | Can be used in JavaScript objects  |
| **Date**                    | Not allowed in JSON                   | Can be used in JavaScript objects  |
| **Undefined**               | Not allowed in JSON                   | Can be used in JavaScript objects  |

---

### **📌 Key Takeaways**
✔ **JSON is a lightweight data-interchange format** that is **data-only**, supporting simple data types like strings, numbers, objects, arrays, booleans, and null.  
✔ **JavaScript objects can include additional data types**, such as functions, dates, and undefined, which are not supported by JSON.  
✔ **In JSON**, keys must always be in **double quotes**, and string values must be in **double quotes**, while in JavaScript, both **single and double quotes** can be used.  
✔ **When working with JSON**, **avoid functions, dates, and undefined** to ensure compatibility across systems. 🚀"		
101	JSON	Why JSON is Better Than XML	"### **JSON vs XML: Parsing and Usability**

When it comes to exchanging and parsing data, **JSON** (JavaScript Object Notation) and **XML** (Extensible Markup Language) are two widely used formats. However, **JSON** offers significant advantages over **XML**, especially when it comes to **parsing** and working with the data in JavaScript.

---

## **📌 Parsing JSON vs XML**

### **1. JSON: Easy to Parse**

One of the biggest advantages of **JSON** is that it is designed to be directly compatible with **JavaScript**. This means when you receive **JSON data**, you can easily parse it into a **ready-to-use JavaScript object** using the built-in `JSON.parse()` method. This makes working with the data in JavaScript seamless and straightforward.

#### **Example of Parsing JSON:**
```js
var jsonData = '{""name"": ""John"", ""age"": 30, ""city"": ""New York""}';
var obj = JSON.parse(jsonData);  // Converts JSON to a JavaScript object

console.log(obj.name);  // Output: ""John""
```
- `JSON.parse()` takes the JSON string and converts it into a JavaScript object. You can then access properties directly as object attributes (`obj.name`, `obj.age`).

#### **Advantages of JSON Parsing**:
- **Direct Mapping**: JSON maps directly to JavaScript objects, so you can work with the data immediately after parsing.
- **Built-in Methods**: `JSON.parse()` and `JSON.stringify()` are simple, fast, and natively supported in JavaScript.
- **Lightweight**: JSON is more concise and easier to read than XML, reducing the complexity of parsing.

---

### **2. XML: Difficult to Parse**

**XML** parsing is much more complex compared to JSON. XML is a **markup language**, not a data representation format like JSON, so it requires a more involved approach to extract useful information.

#### **XML Parsing Example:**
```xml
<person>
  <name>John</name>
  <age>30</age>
  <city>New York</city>
</person>
```

To **parse XML** in JavaScript, you typically use the `DOMParser()` or similar tools to convert the XML string into a document object model (DOM) that can be queried for data. You cannot directly manipulate XML data as JavaScript objects without additional steps.

#### **Example of Parsing XML in JavaScript**:
```js
var xmlString = '<person><name>John</name><age>30</age><city>New York</city></person>';
var parser = new DOMParser();
var xmlDoc = parser.parseFromString(xmlString, ""application/xml"");

var name = xmlDoc.getElementsByTagName(""name"")[0].childNodes[0].nodeValue;
console.log(name);  // Output: ""John""
```
- You need to **traverse the XML DOM** to extract values. In this case, we use methods like `getElementsByTagName()` and `childNodes` to access the content.

#### **Challenges of XML Parsing**:
- **Complex Structure**: XML often has nested elements and attributes, requiring more effort to navigate and extract values.
- **DOM Handling**: XML is parsed into a **DOM object** structure, which is more difficult to work with than a simple JavaScript object.
- **Verbose**: XML is more **verbose** than JSON, requiring more lines of code to handle and more bandwidth to transfer.

---

## **📌 Key Differences Between JSON and XML**

| Feature                        | JSON                              | XML                           |
|---------------------------------|-----------------------------------|-------------------------------|
| **Data Structure**              | JavaScript object                | Tree structure (DOM)          |
| **Parsing Method**              | `JSON.parse()` to convert to object | Requires DOM parsing          |
| **Readability**                 | More concise, human-readable      | More verbose and complex      |
| **Support for Data Types**      | Supports strings, numbers, arrays, objects, booleans, null | Supports text, attributes, and mixed content |
| **Usage**                       | Primarily for data interchange   | Used for both data and document markup |
| **Overhead**                    | Lower overhead, faster parsing    | Higher overhead, slower parsing |

---

## **📌 Summary: JSON vs XML**

### **JSON**:
- **Easier and faster to parse** with the `JSON.parse()` method, converting data directly into JavaScript objects.
- **More lightweight and human-readable** compared to XML, making it the preferred choice for data exchange, especially in APIs.
- **Directly compatible with JavaScript**, making it easy to work with data without complex parsing.

### **XML**:
- **Requires complex parsing** and traversal of the XML DOM.
- **More verbose and less human-readable** than JSON.
- **Better suited for document markup** and more complex use cases, but not as efficient for data exchange.

---

### **📌 Key Takeaways**
✔ **JSON is easier to parse and use** in JavaScript with built-in methods like `JSON.parse()` and `JSON.stringify()`.  
✔ **XML requires more work** to parse and extract data because it involves manipulating the DOM structure.  
✔ **JSON is faster and more lightweight**, making it the preferred choice for web APIs and data exchange.  
✔ **Use XML** when you need document-oriented data (with markup and attributes) or when working with legacy systems that require XML.

🚀 **JSON is the clear choice** when working with data interchange in modern web applications!"		
102	JSON	JSONP	"### **JSONP (JSON with Padding) – Cross-Domain Requests**

**JSONP** is a technique used to bypass the **cross-domain restrictions** in browsers by requesting data via the `"		
103	Object definitions	Creating a JavaScript Object	"### **Ways to Create Objects in JavaScript**

JavaScript provides several methods to create new objects. Here are the most common ways:

---

## **1. Object Literal Notation**

The most common and simplest way to create an object is by using **object literal notation**. This approach defines and initializes the object in a single step.

### **Example**:
```js
let person = {
  name: ""John"",
  age: 30,
  city: ""New York""
};
```
- This method is concise and easy to read. It is typically used when you want to create a single object.

---

## **2. Using the `new` Keyword**

You can create an object using the `new` keyword. This method uses **Object constructor** to instantiate a new object.

### **Example**:
```js
let person = new Object();
person.name = ""John"";
person.age = 30;
person.city = ""New York"";
```
- This approach is less common than object literals but can still be used to create objects.

---

## **3. Object Constructor Function**

You can define an **object constructor function** and then create objects of that type using the `new` keyword.

### **Example**:
```js
function Person(name, age, city) {
  this.name = name;
  this.age = age;
  this.city = city;
}

let person1 = new Person(""John"", 30, ""New York"");
let person2 = new Person(""Anna"", 25, ""London"");
```
- This method allows you to create multiple objects with the same structure and properties.

---

## **4. `Object.create()` (ES5)**

In ECMAScript 5 (ES5), you can create a new object with `Object.create()`, which allows you to create an object that inherits from a specified prototype object.

### **Example**:
```js
let personPrototype = {
  greet: function() {
    console.log(""Hello, "" + this.name);
  }
};

let person = Object.create(personPrototype);
person.name = ""John"";
person.age = 30;
person.greet();  // Output: Hello, John
```
- `Object.create()` allows you to create an object with a specified prototype, making it more flexible for inheritance.

---

### **Summary of Object Creation Methods**

| Method                     | Description |
|----------------------------|-------------|
| **Object Literal**          | `{}` syntax for defining and initializing an object. Most common and simple. |
| **`new` Keyword**           | Using `new Object()` creates an object. Less commonly used. |
| **Object Constructor**      | Define a constructor function and use `new` to create multiple instances of objects. |
| **`Object.create()` (ES5)** | Creates an object with a specified prototype. More flexible for inheritance. |

---

### **Key Takeaways**
✔ **Object literal notation** is the simplest and most common way to create objects.  
✔ Use **constructor functions** for creating multiple instances of the same type of object.  
✔ **`Object.create()`** provides more control over the prototype and inheritance in ES5."		
104	Object definitions	Using an Object Literal (literal declaration)	"### **Object Literal Declaration in JavaScript**

An **object literal** is the simplest and most common way to create objects in JavaScript. It allows you to define both **properties** and **methods** for an object in a concise, readable manner.

### **Example of Object Literal Declaration**:

```js
var person = {
  firstName: ""pepe"",  // Property: firstName
  lastName: ""trueno"", // Property: lastName
  
  // Method: fullName
  fullName: function() {
    return this.firstName + "" "" + this.lastName;
  }
};
```

#### **Explanation**:
- **`firstName`** and **`lastName`** are **properties** of the object `person`, which hold string values.
- **`fullName`** is a **method** defined on the object. It uses the `this` keyword to access the properties `firstName` and `lastName` of the object.

---

### **Using the Object**:

You can access the object's properties and methods like this:

```js
console.log(person.firstName);   // Output: ""pepe""
console.log(person.lastName);    // Output: ""trueno""
console.log(person.fullName());  // Output: ""pepe trueno""
```

- **Properties**: Accessed directly using the dot notation (`person.firstName`).
- **Methods**: Called using the same dot notation (`person.fullName()`).

---

### **Summary**:
- **Object literal** syntax is a **clean and efficient** way to define objects in JavaScript.
- You can define **properties** and **methods** directly within the object.
- The **`this` keyword** inside methods refers to the object itself, allowing access to its properties.

"		
105	Object definitions	Using the JavaScript Keyword new	"### **Avoiding `new Object()` in Favor of Object Literal Declaration**

While you can use the **`new Object()`** method to create objects in JavaScript, it is generally **not recommended** because it is less concise and readable compared to using **object literal notation**. The object literal method is cleaner and more straightforward for creating objects.

### **Example Using `new Object()` (Less Recommended)**:
```js
var person = new Object();  // Using the `new` keyword to create an object
person.firstName = ""John"";  // Adding properties
person.lastName = ""Doe"";
person.fullName = function() {  // Adding a method
    return this.firstName + "" "" + this.lastName;
};
```

#### **Explanation**:
- Here, we are explicitly using `new Object()` to create a new object.
- We then add properties (`firstName`, `lastName`) and a method (`fullName`) to the object using dot notation.

---

### **Preferred Approach: Object Literal Notation**

The **preferred approach** is to use the **object literal notation**, which is more concise and easier to understand.

### **Example Using Object Literal Declaration (Recommended)**:
```js
var person = {
  firstName: ""John"",  // Property
  lastName: ""Doe"",    // Property
  
  fullName: function() {  // Method
    return this.firstName + "" "" + this.lastName;
  }
};
```

#### **Key Benefits of Object Literal Notation**:
1. **Conciseness**: Object literals are shorter and more readable.
2. **Clarity**: The structure of the object is clearer and easier to understand.
3. **Efficiency**: It avoids unnecessary instantiation using `new Object()`.

---

### **Summary**:
- **Avoid using `new Object()`** to create objects in JavaScript. Instead, use the more readable and concise **object literal notation**.
- **Object literals** are the preferred method for object creation because they are easier to write and understand.
"		
106	Object definitions	JavaScript Objects are Mutable	"### **Objects in JavaScript: Mutability and Reference Assignment**

In JavaScript, **objects** are **mutable** and are addressed by **reference** rather than by **value**. This means that when you assign an object to another variable, you are not creating a **copy** of that object. Instead, both variables will refer to the same object in memory.

---

## **📌 Assignment by Reference (Not by Value)**

When you assign one object to another variable, both variables refer to the **same object**. This is different from primitive values (such as strings, numbers, or booleans), which are assigned by value.

### **Example: Assignment by Reference**
```js
let person = { firstName: ""John"", lastName: ""Doe"" };
let x = person;  // Both 'x' and 'person' refer to the same object
```

In this example:
- `person` is an object with two properties: `firstName` and `lastName`.
- When you assign `person` to `x`, you are **not** creating a new copy of the `person` object.
- Instead, both `x` and `person` now point to the **same object** in memory.

---

### **📌 Modifying the Object Through Both Variables**

Since both `x` and `person` refer to the same object, modifying the object through either variable will affect the same object.

### **Example: Modifying the Object**
```js
x.firstName = ""Jane"";  // Modify the object through 'x'
console.log(person.firstName);  // Output: ""Jane""
```

In this case:
- Changing the `firstName` property of `x` also affects `person`, because `x` and `person` reference the **same object**.
- Both `x` and `person` are pointing to the same object in memory.

---

## **📌 Creating a Copy of an Object**

To create a **true copy** of an object (so that the original object is not affected by changes to the copy), you must create a new object rather than simply assigning the object by reference.

### **Example: Creating a Copy Using Object Spread (ES6)**
```js
let person = { firstName: ""John"", lastName: ""Doe"" };
let x = { ...person };  // Create a shallow copy using spread syntax
x.firstName = ""Jane"";

console.log(person.firstName);  // Output: ""John""  (original object is unchanged)
console.log(x.firstName);       // Output: ""Jane""  (new object is modified)
```

In this case, `x` is a **new object** that is a **shallow copy** of `person`. Modifying `x` does not affect `person`.

---

## **📌 Key Takeaways**
✔ **Objects are referenced by memory**: Assigning an object to a variable doesn't create a copy, it creates a reference to the same object.
  
✔ **Changing an object through one reference** will affect all other references to that object.

✔ **To create a true copy**, use methods like the **spread operator** (`{ ...person }`) or **`Object.assign()`** to copy the object's properties.

✔ **Objects are mutable**, meaning their properties can be changed after creation.

---

### **Example of Shallow Copy Using `Object.assign()`**
```js
let person = { firstName: ""John"", lastName: ""Doe"" };
let x = Object.assign({}, person);  // Create a shallow copy of 'person'
x.firstName = ""Jane"";

console.log(person.firstName);  // Output: ""John""
console.log(x.firstName);       // Output: ""Jane""
```

"		
107	Object properties	Accessing object properties	"### **Accessing Object Properties in JavaScript**

In JavaScript, you can access the properties of an object in several ways. The two most common methods are **dot notation** and **bracket notation**. There is also a way to dynamically access properties using **expressions**.

---

## **1. Dot Notation**
Dot notation is the most common and simplest way to access an object's properties. It is used when the property name is a valid identifier (no spaces or special characters) and is known in advance.

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  age: 30
};

console.log(person.age);  // Output: 30
```
- In this example, `person.age` accesses the `age` property of the `person` object.

---

## **2. Bracket Notation**
Bracket notation is more flexible than dot notation and is used when:
- The property name is stored in a variable.
- The property name contains spaces or special characters.
- You need to use a dynamic value for the property name.

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  age: 30
};

console.log(person[""age""]);  // Output: 30
```
- Here, `person[""age""]` is used to access the `age` property. This is equivalent to using dot notation in this case, but bracket notation is required for more complex scenarios.

---

## **3. Accessing Properties with Expressions**
You can also access an object's property dynamically by using an expression inside the brackets. This allows for flexible property access based on variable values.

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  age: 30
};

let x = ""age"";  // Variable holding the property name
console.log(person[x]);  // Output: 30
```
- In this case, `person[x]` uses the value of the variable `x` (`""age""`) to access the `age` property.

---

## **📌 Summary of Accessing Object Properties**

1. **Dot Notation** (`objectName.property`): 
   - **Simple and commonly used**.
   - Only works when the property name is a valid identifier.

2. **Bracket Notation** (`objectName[""property""]`): 
   - **More flexible**.
   - Works for property names with spaces, special characters, or variables.
   - Allows dynamic property access.

3. **Accessing with Expressions** (`objectName[expression]`): 
   - Enables **dynamic property lookup** using variables or expressions.

---

### **Key Takeaways**
✔ **Dot notation** is best when the property name is a valid identifier and known beforehand.  
✔ **Bracket notation** is used for more flexibility, especially with dynamic or complex property names.  
✔ **Expressions** inside brackets allow for dynamic property access based on variables or computed values. 🚀"		
108	Object properties	for...in Loop	"### **Using `for...in` Loop to Iterate Over Object Properties**

In JavaScript, the `for...in` loop is used to iterate over the **properties** of an object. This loop allows you to access each property name (or key) and its corresponding value.

---

## **📌 Syntax of `for...in` Loop**
```js
for (var key in object) {
    // Code to be executed for each property
    // object[key] gives the value of the current property
}
```

### **Explanation**:
- `key`: This is a variable that holds the name of the property (key) on each iteration.
- `object[key]`: Accesses the value of the property using the property name (`key`).

---

## **📌 Example of Using `for...in` to Iterate Over an Object**

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  age: 30,
  city: ""New York""
};

for (let key in person) {
  console.log(key + "": "" + person[key]);
}
```

### **Output**:
```
firstName: John
lastName: Doe
age: 30
city: New York
```

In this example:
- The `for...in` loop iterates over each property (`firstName`, `lastName`, `age`, `city`) of the `person` object.
- Inside the loop, `key` holds the name of the property (e.g., `firstName`), and `person[key]` gives the corresponding value (e.g., `""John""`).

---

## **📌 Important Considerations**:
- **Inherited Properties**: The `for...in` loop will iterate over all **enumerable properties** of an object, including those that are inherited from its prototype chain. To avoid this, you can check if the property belongs directly to the object by using `object.hasOwnProperty(key)`.

### **Example with `hasOwnProperty()`**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe""
};

let car = Object.create(person);
car.model = ""Tesla"";

for (let key in car) {
  if (car.hasOwnProperty(key)) {
    console.log(key + "": "" + car[key]);
  }
}
```

### **Output**:
```
model: Tesla
```
- In this case, the loop will only print the properties that are directly on the `car` object (not inherited from `person`).

---

### **Key Takeaways**
✔ **`for...in`** is used to iterate over **object properties**.  
✔ **Use `hasOwnProperty()`** to ensure you're only accessing the object's own properties (excluding inherited ones).  
✔ The **`for...in` loop** gives access to the **key** of each property, which can be used to access the corresponding **value**. 🚀"		
109	Object properties	Adding New Properties	"### **Adding New Properties to an Existing Object**

In JavaScript, objects are **mutable**, which means you can **dynamically add new properties** to an existing object simply by assigning a value to a property that doesn't yet exist. This is one of the key features of JavaScript objects.

---

## **📌 Adding New Properties to an Object**

If the `person` object already exists, you can add new properties to it by directly assigning a value to a new property.

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  age: 30
};

// Adding a new property 'nationality' to the existing 'person' object
person.nationality = ""English"";

console.log(person.nationality);  // Output: ""English""
```

### **Explanation**:
- Initially, the `person` object has properties like `firstName`, `lastName`, and `age`.
- By assigning a value to `person.nationality`, we add a new property `nationality` with the value `""English""` to the `person` object.
  
---

## **📌 Accessing the New Property**

You can access the newly added property just like any other property of the object.

```js
console.log(person.nationality);  // Output: ""English""
```

### **Alternative Approach: Bracket Notation**

If you prefer, you can also use **bracket notation** to add new properties to an object:

```js
person[""country""] = ""UK"";
console.log(person[""country""]);  // Output: ""UK""
```

---

### **Key Takeaways**
✔ **Objects in JavaScript are mutable**, and you can add new properties to an object at any time.  
✔ You can use **dot notation** (`person.nationality = ""English""`) or **bracket notation** (`person[""country""] = ""UK""`) to add properties.  
✔ **New properties** are added dynamically, allowing flexibility when working with objects in JavaScript. 🚀"		
110	Object properties	Deleting Properties	"### **Using the `delete` Keyword to Remove Object Properties**

In JavaScript, the `delete` keyword is used to **remove a property** from an object. It deletes both the **property name** and its **value**. After using `delete`, the property no longer exists in the object, and any attempt to access it will return `undefined`.

---

## **📌 Syntax of the `delete` Keyword**

```js
delete object.property;  // or
delete object[""property""];
```

- `object`: The object from which you want to delete the property.
- `property`: The property (key) to be deleted from the object.

---

### **Example of Using `delete`**

```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  age: 50,
  eyeColor: ""blue""
};

// Deleting the 'age' property
delete person.age;

console.log(person.age);  // Output: undefined
```

### **Explanation**:
- In this example, `person.age` is deleted using `delete person.age`.
- After the deletion, the `age` property no longer exists in the `person` object, so `person.age` returns `undefined`.

---

## **📌 Bracket Notation with `delete`**

You can also use **bracket notation** to delete a property:

```js
delete person[""age""];  // Equivalent to delete person.age;
```

This method is useful if the property name is stored in a variable.

### **Example**:
```js
let propertyName = ""age"";
delete person[propertyName];  // Delete the 'age' property
console.log(person.age);  // Output: undefined
```

---

### **📌 Important Notes**
1. **Deletes the Property**: `delete` removes both the **value** and the **property** itself.
2. **Cannot Delete Non-Configurable Properties**: You cannot delete certain built-in properties, such as those that are **non-configurable** (like `Math` or `Object` methods).
3. **Return Value**: The `delete` operator returns a **Boolean** (`true` if the property was successfully deleted, or `false` if it couldn't be deleted).

---

### **Key Takeaways**
✔ **`delete`** removes both the **property and its value** from an object.  
✔ **After using `delete`**, the property is completely gone from the object and **cannot be accessed**.  
✔ You can use **dot notation** or **bracket notation** with `delete` to remove properties from an object.  

🚀 **`delete` is a powerful tool for removing unwanted properties** from objects in JavaScript!"		
111	Object methods	The this Keyword	"### **The `this` Keyword in JavaScript Functions**

The `this` keyword in JavaScript is used to refer to the **owner** of a function or the **object** that invokes it. The behavior of `this` depends on how the function is called and what context it is executed in.

---

## **📌 `this` in Object Methods**

When a function is defined as a method inside an object, `this` refers to the **object** that owns the method (i.e., the object that the method is called on). 

### **Example**:
```js
let person = {
  name: ""John"",
  age: 30,
  greet: function() {
    console.log(""Hello, "" + this.name);  // 'this' refers to the person object
  }
};

person.greet();  // Output: ""Hello, John""
```

### **Explanation**:
- In this example, `person` is an object, and it has a method called `greet`.
- Inside the method, `this.name` refers to the `name` property of the `person` object.
- When we call `person.greet()`, `this` points to the `person` object, so `this.name` gives us `""John""`.

---

## **📌 `this` in Global Context**

When used outside of an object or function, `this` refers to the global object. In the browser, the global object is `window`.

### **Example**:
```js
function showThis() {
  console.log(this);  // 'this' refers to the global object (window in browsers)
}

showThis();  // Output: Window {...} (the global object in a browser)
```

---

## **📌 `this` in Constructor Functions**

In **constructor functions**, `this` refers to the instance of the object being created.

### **Example**:
```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

let person1 = new Person(""Alice"", 25);
console.log(person1.name);  // Output: ""Alice""
```

### **Explanation**:
- Here, `this` inside the `Person` constructor refers to the newly created object (`person1`).
- When `new Person(""Alice"", 25)` is called, `this` points to the newly created `person1` object, so `this.name` is `""Alice""`.

---

## **📌 Arrow Functions and `this`**

In **arrow functions**, `this` does not refer to the object that owns the function. Instead, it inherits the value of `this` from the surrounding **lexical scope**.

### **Example**:
```js
let person = {
  name: ""John"",
  greet: () =&gt; {
    console.log(""Hello, "" + this.name);  // 'this' refers to the global object, not person
  }
};

person.greet();  // Output: ""Hello, undefined""
```

### **Explanation**:
- In the arrow function `greet`, `this` does not refer to the `person` object.
- Instead, `this` refers to the **global object** (e.g., `window` in browsers), and since there is no `name` property on the global object, `this.name` is `undefined`.

---

### **Key Takeaways**
✔ **`this` refers to the object** that owns the function when it's called as a method of an object.  
✔ **In global functions**, `this` refers to the **global object**.  
✔ **In constructor functions**, `this` refers to the **newly created object**.  
✔ **Arrow functions** do not have their own `this`; they inherit `this` from the **lexical scope**.

🚀 **Understanding `this` is crucial** for working with methods, constructors, and callbacks in JavaScript."		
112	Object methods	Accessing Object Methods	"### **Accessing Object Methods in JavaScript**

In JavaScript, you can **define methods** (functions) within objects and **call them** using a specific syntax. When you access an object method, you use parentheses `()` to invoke it, and if you access the method without parentheses, you get a **reference** to the function itself, not the result of the function.

---

## **📌 Accessing Object Methods**

When you define a method within an object, you can **invoke** it using the following syntax:

```js
objectName.methodName();
```

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  fullName: function() {
    return this.firstName + "" "" + this.lastName;
  }
};

let x = person.fullName();  // Call the method (function) and get the result
console.log(x);  // Output: ""John Doe""
```

- **`person.fullName()`** is a method call, which **invokes** the `fullName` function and returns its result (`""John Doe""`).

---

## **📌 Accessing the Function Definition Without `()`**

If you access the `fullName` method **without parentheses** (`()`), it will return the **function definition**, not the result of the function.

### **Example Without `()`**:
```js
let func = person.fullName;  // No parentheses, get a reference to the function
console.log(func);  // Output: function() { return this.firstName + "" "" + this.lastName; }
```

- In this case, `person.fullName` is a reference to the **function definition**, not its result.
- The `func` variable now holds the **function itself**, and calling `func()` would execute the function.

---

### **Key Takeaways**
✔ **Invoke a method** in an object using `objectName.methodName()`, which calls the function and returns its result.  
✔ **Without parentheses**, accessing the method gives you the **function definition**, not the result of the function.  
✔ **Function references** can be stored in variables and called later.

🚀 **Understanding method invocation** and how JavaScript treats **functions as first-class objects** helps you work efficiently with objects and methods in JavaScript!"		
113	Object methods	Using Built-In Methods	"### **Built-in Methods in JavaScript**

JavaScript provides a variety of **built-in methods** for common tasks, which can be used directly on objects. These methods are already defined by JavaScript and allow you to perform operations on different data types, such as **strings**, **arrays**, and **numbers**.

---

## **📌 Example: Using the `toUpperCase()` Method**

The `toUpperCase()` method is a built-in method of the **String** object that converts all characters in a string to **uppercase**.

### **Syntax**:
```js
string.toUpperCase();
```

- This method **does not modify the original string** but **returns a new string** with all characters converted to uppercase.

### **Example**:
```js
var message = ""Hello, World!"";
var x = message.toUpperCase();  // Converts the string to uppercase
console.log(x);  // Output: ""HELLO, WORLD!""
```

### **Explanation**:
- `message.toUpperCase()` converts the string `""Hello, World!""` to `""HELLO, WORLD!""`.
- The **original `message`** string remains unchanged, and the result is stored in the variable `x`.

---

## **📌 Other Common String Methods**

1. **`toLowerCase()`**: Converts all characters in a string to lowercase.
   ```js
   var lowerCaseMessage = message.toLowerCase();
   ```

2. **`charAt()`**: Returns the character at a specified index.
   ```js
   var char = message.charAt(0);  // Returns 'H'
   ```

3. **`slice()`**: Extracts a portion of a string.
   ```js
   var slicedMessage = message.slice(0, 5);  // Returns 'Hello'
   ```

4. **`indexOf()`**: Returns the position of the first occurrence of a specified value.
   ```js
   var index = message.indexOf(""World"");  // Returns 7
   ```

---

### **Key Takeaways**
✔ **Built-in methods** like `toUpperCase()` are pre-defined by JavaScript and can be used directly on data types like strings.  
✔ **`toUpperCase()`** converts all characters in a string to uppercase without modifying the original string.  
✔ JavaScript offers many useful **string methods** for various string manipulations, such as `toLowerCase()`, `charAt()`, and `slice()`.  

🚀 **Using built-in methods effectively** helps streamline your coding and allows you to work efficiently with different data types in JavaScript!"		
114	Object methods	Adding a Method to an Object	"### **Adding a Method to an Object in JavaScript**

In JavaScript, you can add methods to an object dynamically after the object is created. A method is simply a function that is a property of an object. You can add methods by directly assigning a function to a property of the object.

---

## **📌 Example: Adding a Method to an Object**

Let's say we have a `person` object, and we want to add a method `name` to it. The method will return the full name by combining the `firstName` and `lastName` properties.

### **Example Code**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe""
};

// Adding a method to the person object
person.name = function() {
  return this.firstName + "" "" + this.lastName;
};

console.log(person.name());  // Output: ""John Doe""
```

### **Explanation**:
1. We define the `person` object with two properties: `firstName` and `lastName`.
2. We add a method `name` to the `person` object using `person.name = function() {...}`.
   - Inside the method, `this.firstName` and `this.lastName` refer to the properties of the `person` object.
   - `this` is used to access the properties of the object that owns the method.
3. When we call `person.name()`, it returns `""John Doe""` because it combines the values of `firstName` and `lastName`.

---

## **📌 Alternative: Defining Methods During Object Creation**

Instead of adding methods later, you can also define methods while creating the object using the object literal notation:

### **Example Code**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  name: function() {
    return this.firstName + "" "" + this.lastName;
  }
};

console.log(person.name());  // Output: ""John Doe""
```

- This approach defines the method `name` directly when the object `person` is created.

---

### **Key Takeaways**
✔ You can **add methods to objects dynamically** by assigning a function to an object property.  
✔ **`this`** inside a method refers to the **object** that owns the method, allowing you to access its properties.  
✔ You can also define methods when you **create the object** using object literal notation.

🚀 **Adding methods to objects** enhances the functionality of the object and helps organize related operations within a single structure!"		
115	Object accessors	JavaScript Accessors (Getters and Setters)	"### **Using Getters and Setters in JavaScript**

In JavaScript, **getters** and **setters** are special methods that allow you to define how a property is accessed and modified. They behave like regular properties, but internally they use functions to handle the logic of **getting** or **setting** the value.

---

## **📌 Example of Using Getters and Setters**

Here is an example where **getters** and **setters** are used to manage the `language` property of a `person` object.

### **Code Example**:
```js
var person = {
  firstName: ""John"",
  lastName: ""Doe"",
  language: """",

  // Getter for 'language' property
  get getLang() {
    return this.language.toUpperCase();  // Returns the language in uppercase
  },

  // Setter for 'language' property
  set setLang(lang) {
    this.language = lang.toLowerCase();  // Sets the language in lowercase
  }
};

// Set the language property using the setter
person.setLang = ""en"";  // This will set person.language to ""en""

// Get the language property using the getter
document.getElementById(""demo"").innerHTML = person.getLang;  // Output: ""EN""
```

### **Explanation**:
- **Setter**: The `set setLang(lang)` method sets the `language` property of the object. When you assign a value to `person.setLang`, the setter is automatically called. It converts the input value to lowercase and assigns it to `person.language`.
- **Getter**: The `get getLang()` method retrieves the `language` property but returns it in **uppercase**. When you access `person.getLang`, the getter is automatically called.

---

## **📌 Accessing Getters and Setters**
1. **Setting a Property Using the Setter**:  
   You set the property using the setter like this:
   ```js
   person.setLang = ""en"";
   ```
   This sets `person.language` to `""en""` after converting it to lowercase inside the setter.

2. **Getting a Property Using the Getter**:  
   You access the property using the getter like this:
   ```js
   document.getElementById(""demo"").innerHTML = person.getLang;
   ```
   This retrieves the `language` property and returns it in uppercase (`""EN""`).

---

### **Key Takeaways**
✔ **Getters and setters** are used to define how you access and modify object properties in a controlled manner.  
✔ **Getters** allow you to **retrieve** the property value and can perform additional logic before returning it.  
✔ **Setters** allow you to **modify** the property value and can perform additional logic before setting the value.  
✔ You call **getters and setters like properties**, not functions, without parentheses (`person.getLang` and `person.setLang = ""en""`).

🚀 **Getters and setters** are powerful tools for creating **encapsulation** in your objects, giving you control over how data is accessed and modified."		
116	Object accessors	Why Using Getters and Setters?	"### **Why Using Getters and Setters?**

Getters and setters are powerful tools in JavaScript that provide more control over how properties of an object are accessed and modified. They help manage the interaction with an object's properties while keeping the syntax clean and consistent.

Here are some of the main reasons why getters and setters are beneficial:

---

## **1. Simpler Syntax**
- Getters and setters allow you to **interact with properties** in a simple, **property-like syntax**, without having to call a method.
- This results in more intuitive and concise code.

### **Example**:
Instead of calling a method like this:
```js
person.getLang();
```
You can access the property directly using:
```js
person.getLang;  // Simpler and looks like a property, not a function
```

- This makes the code **cleaner and easier to understand** while providing the flexibility of methods behind the scenes.

---

## **2. Equal Syntax for Properties and Methods**
- Getters and setters make **properties** behave like **methods** without needing to use function calls.
- This makes the code more consistent, as you can access both properties and methods using the same syntax.

### **Example**:
```js
person.setLang = ""en"";  // Setter
document.getElementById(""demo"").innerHTML = person.getLang;  // Getter
```
- Both the getter and setter look like property access, but they are actually methods that handle logic behind the scenes.

---

## **3. Better Data Quality and Security**
- By using setters, you can enforce **validation** or **data transformation** before a property value is set, ensuring better data quality.
- You can also **restrict direct access** to certain properties, allowing controlled modification through setters only.

### **Example**:
You can validate or modify a property before setting it:
```js
set setLang(lang) {
  if (lang.length &gt; 2) {
    this.language = lang.toLowerCase();  // Only accept valid input
  } else {
    console.error(""Invalid language code"");
  }
}
```
- This ensures that only valid values are assigned to the `language` property, improving the integrity of the object data.

---

## **4. Useful for Behind-the-Scenes Logic**
- Getters and setters are perfect for **encapsulation** and hiding complex logic or calculations from the user. The client can interact with the object in a simple way while the internal logic remains hidden.

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  fullName: function() {
    return this.firstName + "" "" + this.lastName;
  }
};

person.fullName = function() {
  return this.firstName.toUpperCase() + "" "" + this.lastName.toUpperCase();
};
```
- Here, the method's functionality can be modified without changing how users interact with it.

---

### **Key Takeaways**
✔ **Simpler syntax**: Getters and setters allow you to access and modify properties like regular attributes, improving code readability.  
✔ **Consistency**: They provide equal syntax for both properties and methods, making the code more uniform and intuitive.  
✔ **Data integrity**: Getters and setters give you control over data, allowing you to enforce validation and transformations.  
✔ **Encapsulation**: They enable behind-the-scenes logic, which keeps the object interface clean while hiding complex operations.

🚀 **Getters and setters** are powerful tools for managing and securing object data, allowing for cleaner code and better control over property access and modifications!"		
117	Object constructors	Object constructor function declaration	"### **Constructor Functions in JavaScript**

Constructor functions are a way to create multiple objects that share the same structure and behavior. They act as a **blueprint** for creating objects of a similar ""type"" or class. 

---

## **📌 What is a Constructor Function?**

A **constructor function** is a special function used to create and initialize objects. It uses the `this` keyword to assign properties and methods to the newly created object. Constructor functions are typically named with an **uppercase first letter** by convention, following the **camelCase** style.

### **Example of a Constructor Function**:
```js
function Person(first, last, age, eye) {
    this.firstName = first;
    this.lastName = last;
    this.age = age;
    this.eyeColor = eye;

    // Method to return full name
    this.name = function() {
        return this.firstName + "" "" + this.lastName;
    };
}
```

In this constructor function:
- `Person` is the name of the constructor function.
- `this` refers to the **newly created object**. The properties (`firstName`, `lastName`, etc.) and methods (`name`) are assigned to this new object.

---

## **📌 Creating Objects Using `new` Keyword**

Once the constructor function is defined, you can use the **`new` keyword** to create multiple instances of the object based on the constructor function.

### **Example**:
```js
var myFather = new Person(""John"", ""Doe"", 50, ""blue"");
console.log(myFather.name());  // Output: ""John Doe""
```

- `new Person(""John"", ""Doe"", 50, ""blue"")` creates a new object `myFather` with the properties and methods defined in the `Person` constructor function.
- Calling `myFather.name()` will return `""John Doe""` because the `name()` method combines the `firstName` and `lastName`.

---

## **📌 Modifying Properties and Methods**

You can modify the properties or call methods on the newly created object as needed.

### **Example**:
```js
myFather.firstName = ""Mike"";  // Modify a property
console.log(myFather.name());  // Output: ""Mike Doe""
```

You can also create additional objects using the `Person` constructor:

```js
var myMother = new Person(""Jane"", ""Doe"", 48, ""green"");
console.log(myMother.name());  // Output: ""Jane Doe""
```

---

## **📌 Important Considerations**
1. **Naming Convention**: Constructor functions should be named with an uppercase first letter (`Person`), as this helps distinguish them from regular functions.
2. **`new` Keyword**: You need to use the `new` keyword when calling the constructor function to create a new object.
3. **Object Creation**: Every time you use `new`, a new object is created and initialized with the properties and methods defined in the constructor function.

---

### **Key Takeaways**
✔ **Constructor functions** act as **blueprints** for creating objects with the same structure and behavior.  
✔ **Use the `new` keyword** to create new instances of the object.  
✔ It is good practice to name constructor functions with an **uppercase first letter** (e.g., `Person`).

🚀 **Constructor functions** help you efficiently create and manage multiple objects with shared properties and methods!"		
118	Object constructors	The this Keyword	"### **Understanding the `this` Keyword in JavaScript**

In JavaScript, the `this` keyword is a special reference that points to the **object** that ""owns"" the current code. The value of `this` depends on the context in which it is used—whether it's inside an object method, a constructor function, or a standalone function.

---

## **1. `this` in an Object Method**
When `this` is used inside a method of an object, it refers to the **object itself**.

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  fullName: function() {
    return this.firstName + "" "" + this.lastName;
  }
};

console.log(person.fullName());  // Output: ""John Doe""
```

- In the `fullName()` method, `this.firstName` and `this.lastName` refer to the **properties of the `person` object**.
- When the method is called as `person.fullName()`, `this` refers to the `person` object, and it can access `firstName` and `lastName`.

---

## **2. `this` in a Constructor Function**
In a **constructor function**, `this` does not initially have a value. However, it acts as a placeholder for the **new object** that will be created when the constructor function is called with the `new` keyword.

### **Example**:
```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.fullName = function() {
    return this.firstName + "" "" + this.lastName;
  };
}

// Creating a new object using the constructor
let person1 = new Person(""John"", ""Doe"");
console.log(person1.fullName());  // Output: ""John Doe""
```

- Inside the `Person` constructor function, `this` refers to the **newly created object** (`person1` in this case).
- When `new Person()` is called, `this` will refer to the new object being created, and properties like `firstName` and `lastName` are set on it.

---

## **3. `this` in a Regular Function**
When `this` is used in a regular (non-method) function, its value depends on how the function is called:
- In **strict mode**, `this` will be `undefined`.
- In **non-strict mode**, `this` will refer to the global object (`window` in browsers).

### **Example** (Non-Strict Mode):
```js
function showThis() {
  console.log(this);
}

showThis();  // Output: Window {} in a browser (global object)
```

### **Example** (Strict Mode):
```js
""use strict"";
function showThis() {
  console.log(this);  // Output: undefined
}

showThis();
```

- In **strict mode**, `this` will be `undefined` in a regular function because it doesn't refer to the global object.

---

## **4. `this` in Arrow Functions**
Arrow functions do not have their own `this`. Instead, they **inherit `this` from their surrounding context**, meaning `this` in an arrow function refers to the value of `this` from the outer scope.

### **Example**:
```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  fullName: function() {
    let arrowFunc = () =&gt; {
      return this.firstName + "" "" + this.lastName;
    };
    return arrowFunc();
  }
};

console.log(person.fullName());  // Output: ""John Doe""
```

- In the arrow function inside the `fullName()` method, `this` still refers to the **`person` object** because the arrow function **inherits `this` from the `fullName` method**.

---

### **Key Takeaways**
✔ **`this` in an object method**: Refers to the **object itself** that owns the method.
  
✔ **`this` in a constructor function**: Acts as a **placeholder** for the new object being created when `new` is used.

✔ **`this` in regular functions**: Its value depends on how the function is invoked:
  - In **strict mode**, `this` is `undefined`.
  - In **non-strict mode**, `this` refers to the **global object**.

✔ **`this` in arrow functions**: Inherits `this` from the **surrounding context**, not from the function itself.

🚀 **The behavior of `this` is crucial** for understanding how methods, constructors, and functions behave in different contexts in JavaScript!"		
119	Object prototypes	Prototype Inheritance	"### **Prototype Inheritance in JavaScript**

In JavaScript, all objects inherit properties and methods from a prototype. This is known as **prototype inheritance**. Every object in JavaScript has a hidden internal property called `[[Prototype]]` (often accessed through `__proto__`), which points to another object—its **prototype**. This allows objects to inherit behavior (methods and properties) from other objects.

---

## **📌 Prototype Chain**

Each type of object inherits from its respective prototype object, and this prototype chain continues up to **`Object.prototype`**, which is at the top of the inheritance chain.

### **Example of Inheritance**:

- **Date objects** inherit from `Date.prototype`.
- **Array objects** inherit from `Array.prototype`.
- **Custom objects (e.g., `Person`)** inherit from `Person.prototype`.

Finally, all objects ultimately inherit from `Object.prototype`.

---

## **📌 Inheriting from Prototypes**

### **Example 1: Inheritance from `Date.prototype`**
All instances of the `Date` object inherit properties and methods from `Date.prototype`.

```js
let myDate = new Date();
console.log(myDate.getFullYear());  // Inherited from Date.prototype
```

- `getFullYear()` is a method that belongs to `Date.prototype`, and since `myDate` is a `Date` object, it can use this method.

### **Example 2: Inheritance from `Array.prototype`**
All instances of `Array` inherit methods from `Array.prototype`.

```js
let myArray = [1, 2, 3];
console.log(myArray.push(4));  // Inherited from Array.prototype
```

- `push()` is a method on `Array.prototype` that adds an item to the array.

### **Example 3: Inheritance from `Person.prototype`**
When you define your own constructor function (e.g., `Person`), the objects created from it will inherit from `Person.prototype`.

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  return `Hello, my name is ${this.name}`;
};

let person1 = new Person(""Alice"", 30);
console.log(person1.greet());  // Output: ""Hello, my name is Alice""
```

- `greet()` is a method defined on `Person.prototype`, and `person1` inherits it because it was created from the `Person` constructor function.

---

## **📌 The `Object.prototype` Inheritance**

At the top of the prototype chain is **`Object.prototype`**. This means that all objects, regardless of whether they are arrays, dates, or custom objects, inherit from `Object.prototype`. Even `Date`, `Array`, and `Person` objects inherit from `Object.prototype`.

### **Example of Inherited Properties from `Object.prototype`**:

```js
let myObject = {};
console.log(myObject.hasOwnProperty(""name""));  // Inherited from Object.prototype
```

- `hasOwnProperty()` is a method that all objects inherit from `Object.prototype`, which allows them to check if a property is part of the object itself (not inherited).

---

## **📌 Prototype Chain in Action**

1. **Date objects** inherit from `Date.prototype`, which inherits from `Object.prototype`.
2. **Array objects** inherit from `Array.prototype`, which inherits from `Object.prototype`.
3. **Custom objects** (e.g., `Person`) inherit from `Person.prototype`, which inherits from `Object.prototype`.

This creates a **prototype chain** where objects can access properties and methods from their prototype and the prototypes of their prototypes, all the way up to `Object.prototype`.

---

### **Key Takeaways**

✔ **Prototype inheritance** allows objects to **inherit methods and properties** from their prototypes.  
✔ All objects in JavaScript, including built-in objects like `Date` and `Array`, inherit from **`Object.prototype`** at the top of the prototype chain.  
✔ You can add properties and methods to an object's prototype, which are then available to all instances created from that constructor function.  
✔ **Prototype chains** allow for inheritance of methods and properties across various types of objects.

🚀 **Understanding prototypes and the prototype chain** is essential for working with object-oriented concepts in JavaScript and building efficient, reusable code!"		
120	Object prototypes	Adding properties and methods to objects	"### **Adding Properties and Methods to Object Constructors Using Prototypes**

In JavaScript, the **prototype** property allows you to add new properties or methods to an existing object constructor. This is useful when you want to define behavior (methods) or properties that should be shared by **all instances** of an object created by that constructor.

### **📌 The `prototype` Property**

The `prototype` property is an object associated with each function (including object constructors). You can add properties or methods to this prototype object, and all instances created by that constructor will have access to those properties or methods.

---

## **📌 Example: Adding Properties and Methods to the `Person` Constructor**

Here’s an example where we define a `Person` constructor and then add a **`nationality`** property and a **`name()`** method to the prototype.

```js
function Person(first, last, age, eyecolor) {
    this.firstName = first;
    this.lastName = last;
    this.age = age;
    this.eyeColor = eyecolor;
}

// Adding a new property to the prototype
Person.prototype.nationality = ""English"";

// Adding a method to the prototype
Person.prototype.name = function() {
    return this.firstName + "" "" + this.lastName;
};
```

### **Explanation**:
- The `Person` constructor function defines an object with properties like `firstName`, `lastName`, `age`, and `eyeColor`.
- We use **`Person.prototype.nationality = ""English""`** to add a new property `nationality` to the `Person` prototype. This property will be available to **all instances** of the `Person` object.
- We also define a **method `name()`** on the `Person.prototype`. This method returns the full name by combining `firstName` and `lastName`.

---

## **📌 Using the Constructor and Accessing the Prototype Properties**

Once the properties and methods are added to the prototype, any instance created using the `Person` constructor will have access to them.

### **Example of Creating Objects and Accessing Prototype Properties/Methods**:

```js
let person1 = new Person(""John"", ""Doe"", 30, ""blue"");
let person2 = new Person(""Jane"", ""Smith"", 25, ""green"");

console.log(person1.name());  // Output: ""John Doe""
console.log(person2.name());  // Output: ""Jane Smith""
console.log(person1.nationality);  // Output: ""English""
console.log(person2.nationality);  // Output: ""English""
```

### **Explanation**:
- Both `person1` and `person2` are instances of the `Person` constructor.
- They both have access to the `name()` method and the `nationality` property via the **prototype**.
- The `nationality` property has the same value (`""English""`) for both `person1` and `person2`, but it is **not stored** in each instance. Instead, it is shared from the **prototype**.

---

## **📌 Why Use Prototypes?**

1. **Memory Efficiency**: By adding properties or methods to the prototype, they are shared across all instances, so they are not repeated in every individual object. This helps **save memory**.
   
2. **Add Behavior to Existing Constructors**: You can add new methods or properties to **already existing constructors**. This is especially useful if you don't have access to the constructor function’s source code.

3. **Inheritance**: Prototypes play a central role in JavaScript's **inheritance model**. Objects inherit from their prototype, and the prototype can be extended with new properties or methods.

---

### **Key Takeaways**
✔ The **`prototype` property** allows you to add properties or methods to all instances of a constructor.  
✔ **Prototypes are shared across all instances** of the object, improving **memory efficiency**.  
✔ You can use **prototypes to extend behavior** or add properties to existing object constructors.  
✔ Prototypes are crucial for **inheritance** and defining shared behavior for objects in JavaScript.

🚀 **Mastering prototypes** lets you create flexible and efficient object-oriented code in JavaScript!"		
121	Object prototypes	Test if an object exist (no w3)	"### **Testing if an Object Exists in JavaScript**

In JavaScript, you may need to test if an object (or any other value) exists or is valid before performing operations on it. You can use a combination of `typeof` and direct comparison to check whether an object is defined and not `null`.

### **📌 Example: Checking if an Object Exists**

To check if an object `myObj` exists (i.e., it is neither `undefined` nor `null`), you can use the following condition:

```js
if (typeof myObj !== ""undefined"" &amp;&amp; myObj !== null) {
    // Proceed with operations on myObj
} else {
    // Handle the case where myObj is undefined or null
}
```

### **Explanation**:
1. **`typeof myObj !== ""undefined""`**: This checks if the `myObj` variable has been declared and is not `undefined`. If `myObj` is `undefined`, the `typeof` operator will return `""undefined""`.
   
2. **`myObj !== null`**: This checks if the `myObj` variable is not `null`. In JavaScript, `null` is a special value that represents the intentional absence of any object value.

Both conditions are necessary because an object can be either `null` or `undefined`, and they behave differently:
- **`undefined`**: Indicates that a variable has been **declared** but has not been assigned any value (or the property/method doesn't exist).
- **`null`**: Represents the intentional **absence of an object**. It is **assigned** to an object variable explicitly to indicate that it currently doesn't reference any object.

### **📌 Key Differences Between `null` and `undefined`**

- **`undefined`**:
  - Represents a variable that has been **declared** but not assigned a value.
  - It is the default value for **uninitialized variables**.
  - It is also the default value for **missing properties** in objects.
  
  ```js
  let x;
  console.log(x);  // Output: undefined
  ```

- **`null`**:
  - Represents the **intentional absence** of any object value.
  - It is **explicitly assigned** to a variable to indicate that it should not hold any value.
  
  ```js
  let obj = null;
  console.log(obj);  // Output: null
  ```

---

## **📌 Example of Using `null` and `undefined`**

```js
let myObj;  // This is undefined
console.log(typeof myObj);  // Output: ""undefined""

myObj = null;  // Now it's explicitly null
console.log(myObj);  // Output: null

if (typeof myObj !== ""undefined"" &amp;&amp; myObj !== null) {
    console.log(""myObj exists and is not null"");
} else {
    console.log(""myObj is either undefined or null"");
}
```

### **Output**:
```
undefined
null
myObj is either undefined or null
```

---

### **Key Takeaways**
✔ **`undefined`** means a variable is declared but not assigned a value (or a property doesn't exist).  
✔ **`null`** means an object is intentionally **empty** and doesn't point to any value.  
✔ Use **`typeof` and direct comparison** (`!== null`) to **test if an object exists** before using it.  
✔ Both **`undefined`** and **`null`** represent absence, but **`undefined`** is used for **uninitialized** variables or missing properties, while **`null`** is used for **explicit empty objects**.

🚀 **Knowing the difference** between `null` and `undefined` and how to test for them is essential for writing robust and error-free code in JavaScript!"		
122	Function definitions	First class citizens	"### **Higher-Order Functions in JavaScript**

A **higher-order function** is a function that either:
- Takes **another function as an argument**, or
- **Returns a function**.

In JavaScript, functions are **first-class citizens**, meaning they can be:
- Assigned to variables,
- Passed as arguments to other functions,
- Returned from other functions.

This makes higher-order functions a powerful tool for functional programming in JavaScript.

---

## **📌 Example of a Higher-Order Function**

### **Function that Takes Another Function as a Parameter:**
```js
function greet(name, callback) {
  console.log(""Hello, "" + name);
  callback();  // Calling the function passed as an argument
}

function sayGoodbye() {
  console.log(""Goodbye!"");
}

greet(""John"", sayGoodbye);  
// Output:
// Hello, John
// Goodbye!
```

In this example:
- `greet` is a higher-order function because it takes another function (`sayGoodbye`) as an argument.
- The `callback()` is invoked inside `greet`, which executes the `sayGoodbye` function.

### **Function that Returns Another Function:**
```js
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

let double = multiplier(2);  // 'double' is now a function
console.log(double(5));  // Output: 10
```

In this example:
- `multiplier` is a higher-order function because it returns a function.
- The `double` function is returned by `multiplier` with a preset factor (`2`), and when called with `5`, it returns `10`.

---

## **📌 Function Parameters and Arguments**

### **Parameters**:
- **Parameters** are the **names** listed in the function definition.
  ```js
  function add(a, b) {
    return a + b;
  }
  ```
  - In this example, `a` and `b` are **parameters** of the `add` function.

### **Arguments**:
- **Arguments** are the actual values that are **passed** to the function when it is called.
  ```js
  let result = add(5, 3);
  ```
  - Here, `5` and `3` are the **arguments** passed to the `add` function when it is called.

### **Missing Arguments**:
If a function is called with fewer arguments than the number of parameters, the missing values will be set to **`undefined`**. 

#### **Example of Missing Arguments**:
```js
function greet(name, message) {
  console.log(name + "": "" + message);
}

greet(""Alice"");  // Output: ""Alice: undefined""
```
- In this case, the `message` parameter is missing, so it is automatically set to `undefined`.

### **Default Parameters**:
You can **assign default values** to function parameters, which will be used if the argument is missing or `undefined`.

#### **Example of Default Parameters**:
```js
function greet(name, message = ""Hello!"") {
  console.log(name + "": "" + message);
}

greet(""Alice"");  // Output: ""Alice: Hello!""
greet(""Bob"", ""Good morning!"");  // Output: ""Bob: Good morning!""
```
- In this example, the `message` parameter has a default value of `""Hello!""`, which is used if the argument is not provided.

---

## **📌 Key Takeaways**

1. **Higher-Order Functions**: These are functions that either accept a function as an argument or return a function. This is possible because functions are **first-class citizens** in JavaScript.
2. **Function Parameters and Arguments**:
   - **Parameters** are the variable names in the function definition.
   - **Arguments** are the real values passed to the function during invocation.
3. **Default Parameters**: You can use **default parameters** to assign default values to parameters if the argument is missing or `undefined`, ensuring the function behaves predictably.

🚀 **Higher-order functions** and default parameters are essential for writing flexible and reusable code in JavaScript!"		
123	Function definitions	Function declarations	"### **Function Declarations in JavaScript**

In JavaScript, functions can be declared and used in a straightforward manner. Understanding how **function declarations** work and when to use **semicolons** can help you write cleaner and more readable code.

---

## **📌 Regular Function Declaration and Usage**

### **Example: Function Declaration and Calling**:

```js
myFunction(5);

function myFunction(y) {
  return y * y;
}
```

### **Explanation**:
- **`myFunction(5)`**: This is the **function call** where the value `5` is passed as the argument to the function.
- **Function Declaration**: 
  ```js
  function myFunction(y) {
    return y * y;
  }
  ```
  This is the **function declaration**, where:
  - `myFunction` is the name of the function.
  - `y` is the **parameter** that the function uses.
  - The body of the function calculates `y * y` and **returns** the result.

### **Function Call**:
- The function is called with an argument of `5`, which will make `y` equal to `5`. The function then returns `25` (`5 * 5`).

---

## **📌 Semicolons in JavaScript**

In JavaScript, **semicolons** are used to terminate executable statements. They separate **statements** from one another. However, there are specific cases where semicolons are not necessary, particularly when defining functions.

### **Function Declarations and Semicolons**:
- **Function declarations** are **not executable statements**, meaning they do not require a semicolon after them.
  - **Correct**: 
    ```js
    function myFunction() {
      // code
    }
    ```
  - **Incorrect**: 
    ```js
    function myFunction() { // Adding semicolon here is unnecessary
      // code
    };
    ```

### **Why No Semicolon for Function Declarations?**
- A function declaration itself does not represent an **executable action** when it's defined, but rather a **declaration of functionality**. Since it’s not an **expression** like a variable assignment or function call, you do not need a semicolon at the end of a function declaration.

---

## **📌 Example: Function Expression with Semicolon**

When you assign a function to a variable, it’s considered a **function expression**, and in that case, a semicolon is required.

```js
const square = function(y) {
  return y * y;
}; // Semicolon is needed here for function expression
```

### **Explanation**:
- **`square`** is a variable that holds a **function expression**.
- Since the function is assigned to a variable, it is an **expression**, and thus, a semicolon is required at the end.

---

### **Key Takeaways**
✔ **Function declarations** do **not require a semicolon** because they are not executable statements.  
✔ **Function expressions** (like assigning a function to a variable) **do require a semicolon** because they are expressions that represent executable statements.  
✔ **Semicolons** are used to separate executable JavaScript statements, but function declarations themselves are not considered executable.  

🚀 **Understanding when to use semicolons** in JavaScript helps improve code readability and ensures you follow proper syntax conventions!"		
124	Function definitions	Anonymous functions	"### **Anonymous Functions and Function Expressions in JavaScript**

In JavaScript, functions can be **anonymous**, meaning they do not have a name. These functions are typically defined and assigned to variables. You can then invoke the function using the variable name. This is called a **function expression**, and it's quite common in JavaScript.

---

## **📌 Example of an Anonymous Function**

### **Function Expression with Anonymous Function**:
```js
var myFunction = function(a, b) {
  return a * b;
};

var x = myFunction(4, 3);
console.log(x);  // Output: 12
```

### **Explanation**:
- `myFunction` is assigned an **anonymous function** (a function without a name) as its value.
- This anonymous function takes two parameters (`a` and `b`) and returns their product (`a * b`).
- The function is called by invoking `myFunction(4, 3)`, passing `4` and `3` as arguments. This results in `12`.

---

## **📌 Why is This an Anonymous Function?**

In the example above:
- The function does not have a name (`function(a, b)` is an anonymous function).
- **Anonymous functions** are often used when the function is **immediately used** or **passed as a callback**. They are typically not declared separately with a name.

### **Named Function Example**:
```js
function multiply(a, b) {
  return a * b;
}
```
- In this example, the function `multiply` is **named**, unlike the anonymous function in the previous example.

---

## **📌 Why End with a Semicolon?**

In the case of a **function expression**, a semicolon is required because the function is **part of an executable statement**. When you assign a function to a variable, you are creating an expression, and expressions are generally followed by semicolons.

### **Function Expression with Semicolon**:
```js
var myFunction = function(a, b) { return a * b; };  // Semicolon needed
```

### **Function Declaration without Semicolon**:
```js
function multiply(a, b) {
  return a * b;
}  // No semicolon needed
```

- The difference here is that a **function expression** is an **executable statement**, so it requires a semicolon. A **function declaration** is not an executable statement and does not require a semicolon.

---

### **Key Takeaways**
✔ **Anonymous functions** are functions without a name, typically defined and assigned to variables.  
✔ **Function expressions** (such as `var myFunction = function(a, b) {}`) must end with a **semicolon** because they are **executable statements**.  
✔ **Function declarations** do not require semicolons because they are not part of executable statements.  

🚀 **Anonymous functions and function expressions** are key concepts for modern JavaScript, especially when working with **callbacks** and **event handling**."		
125	Function definitions	Function Hoisting	"### **Hoisting in JavaScript**

**Hoisting** is a behavior in JavaScript where **variable declarations** and **function declarations** are moved to the top of their containing scope during the compilation phase, before the code is executed. This means that **variables and functions** can be used (called) before they are declared in the code.

---

## **📌 Hoisting with Function Declarations**

Function declarations are **hoisted** in JavaScript, meaning the function can be **called before** it is defined in the code.

### **Example: Hoisting with Function Declarations**

```js
console.log(myFunction());  // Output: ""Hello, World!""

function myFunction() {
  return ""Hello, World!"";
}
```

### **Explanation**:
- In the example, `myFunction()` is called before the function is declared.
- JavaScript **hoists the function declaration** to the top of the scope, so the function is available throughout the code.
- This works because **function declarations** are fully hoisted, including their body.

---

## **📌 Hoisting with Variables**

Variables declared using the `var` keyword are also hoisted, but only the **declaration** (not the initialization) is moved to the top.

### **Example: Hoisting with `var`**

```js
console.log(x);  // Output: undefined
var x = 5;
console.log(x);  // Output: 5
```

### **Explanation**:
- The declaration `var x` is hoisted to the top, but the assignment (`x = 5`) remains where it is.
- **At the time of the first `console.log(x)`**, `x` is **undefined**, because the declaration has been hoisted, but the value hasn't been assigned yet.

---

## **📌 Hoisting with `let` and `const`**

`let` and `const` behave differently than `var` when it comes to hoisting. They are **hoisted** to the top of the block scope, but they are not **initialized** until the code execution reaches the line where they are defined. This creates a **temporal dead zone** (TDZ), where accessing the variable before it is initialized results in a **ReferenceError**.

### **Example: Hoisting with `let` and `const`**

```js
console.log(y);  // Output: ReferenceError: Cannot access 'y' before initialization
let y = 10;
```

### **Explanation**:
- `let` and `const` declarations are hoisted, but they do not get initialized until their actual declaration is reached in the code.
- Trying to access the variable before initialization results in a **ReferenceError** due to the temporal dead zone.

---

## **📌 Hoisting with Function Expressions**

**Function expressions**, unlike **function declarations**, are **not hoisted**. This means that if you try to call a function expression before it is defined, you will get an error.

### **Example: Function Expression Not Hoisted**

```js
console.log(myFunction());  // Output: TypeError: myFunction is not a function

var myFunction = function() {
  return ""Hello!"";
};
```

### **Explanation**:
- In this example, `myFunction` is a **function expression** and is not hoisted like a function declaration.
- The variable `myFunction` is hoisted, but it is `undefined` until the function expression is assigned to it.
- Trying to call `myFunction()` before the assignment leads to a **TypeError** because at that point, `myFunction` is `undefined`.

---

### **Key Takeaways**
✔ **Function declarations** are hoisted, meaning you can call them before they are defined in the code.  
✔ **Variable declarations** (using `var`) are hoisted, but only their declaration (not the initialization).  
✔ **`let` and `const` variables** are hoisted to the top but are in a ""temporal dead zone"" until they are initialized, causing a `ReferenceError` if accessed too early.  
✔ **Function expressions** (assigned to variables) are **not hoisted**, and calling them before their definition results in an error.

🚀 **Understanding hoisting** is crucial for writing predictable JavaScript code and avoiding common pitfalls related to variable and function declarations!"		
126	Function definitions	Self-Invoking Functions	"### **Self-Invoking Functions in JavaScript**

A **self-invoking function** (also known as an **immediately invoked function expression** or **IIFE**) is a function that is defined and executed **immediately** after it is created. Unlike regular functions, you do not need to explicitly call them.

### **How Self-Invoking Functions Work:**

In JavaScript, a **function expression** can be **self-invoked** by wrapping it in parentheses `()` and appending `()` after it. This syntax ensures that the function is treated as an **expression**, and it gets executed immediately.

---

## **📌 Example of a Self-Invoking Function**

```js
(function() {
  var x = ""Hello!!"";  // A local variable inside the function
  console.log(x);      // Output: ""Hello!!""
})();
```

### **Explanation**:
- The function is an **anonymous function** (it has no name).
- It is wrapped in **parentheses** to treat it as an **expression**.
- After the function expression, **another set of parentheses `()`** is added to invoke (execute) the function immediately.
- The function creates a local variable `x` and logs it, but it is not accessible outside the function because it is scoped locally.

---

## **📌 Why Use Self-Invoking Functions?**

Self-invoking functions are commonly used in JavaScript for the following reasons:

1. **Encapsulation**:
   - They create a **local scope** to avoid polluting the global namespace. Variables inside the function do not interfere with variables outside of it.
   - For example, if you are working in a larger application, using a self-invoking function helps avoid conflicts between variable names.

2. **Avoiding Global Variables**:
   - If you define variables or functions in the global scope, they can be accessed from anywhere, which might cause conflicts. By using a self-invoking function, you keep the variables **private** to that function.

3. **Initialization Code**:
   - Self-invoking functions can be used for one-time **initialization tasks** that don't need to be reused later.

---

## **📌 Example with Parameters**

Self-invoking functions can also accept parameters. Here's an example of passing parameters into the function:

```js
(function(name) {
  console.log(""Hello, "" + name + ""!"");
})(""John"");
```

### **Explanation**:
- The function accepts `name` as a parameter and immediately logs `""Hello, John!""`.
- This is useful when you need to run a function immediately with dynamic inputs.

---

## **📌 Key Differences: Function Declarations vs. Function Expressions**

- **Function Declarations** are **not self-invoking**. They must be explicitly called after they are defined.
  ```js
  function greet() {
    console.log(""Hello!"");
  }
  greet();  // You need to call it explicitly
  ```
- **Function Expressions** can be self-invoked, and they are defined **inline**.
  ```js
  (function() {
    console.log(""Hello!!"");
  })();  // This invokes the function immediately
  ```

---

### **Key Takeaways**
✔ **Self-invoking functions** (IIFE) are functions that **execute immediately** after being defined.
✔ They are defined as **function expressions** and are wrapped in parentheses with an additional pair of parentheses for invocation.
✔ **Anonymous functions** are often used as self-invoking functions, meaning they do not have a name.
✔ They help with **encapsulation**, keeping variables **local** to the function and avoiding global namespace pollution.

🚀 **Self-invoking functions** are a powerful tool in JavaScript for immediate execution and managing scope effectively!"		
127	Function definitions	Functions Can Be Used as Values	"### **Using Functions in JavaScript Expressions**

In JavaScript, functions can be used not only as standalone blocks of code but also as **expressions**. This means that the result of calling a function can be used as part of a larger expression, including mathematical operations, assignments, or other function calls.

---

## **📌 Example 1: Basic Function Usage**

Here’s a simple function that takes two parameters and returns their product:

```js
function myFunction(a, b) {
    return a * b;
}

var x = myFunction(4, 3);
console.log(x);  // Output: 12
```

### **Explanation**:
- The `myFunction` function is called with arguments `4` and `3`.
- The function returns `12` (4 * 3), and the result is assigned to the variable `x`.
- The value of `x` is then `12`, which can be used in further expressions or logged.

---

## **📌 Example 2: Using Functions in Expressions**

JavaScript functions can also be used **within expressions**. You can call a function and then use its result directly as part of a larger operation.

```js
function myFunction(a, b) {
    return a * b;
}

var x = myFunction(4, 3) * 2;
console.log(x);  // Output: 24
```

### **Explanation**:
- `myFunction(4, 3)` returns `12` (the product of `4` and `3`).
- This result is then multiplied by `2`, giving the final result of `24`.
- The value `24` is assigned to the variable `x`, and logged to the console.

---

## **📌 More Examples of Functions in Expressions**

### **Example 3: Using Functions in Conditional Expressions**

```js
function add(a, b) {
    return a + b;
}

var x = add(5, 3) &gt; 5 ? ""Greater than 5"" : ""Less than or equal to 5"";
console.log(x);  // Output: ""Greater than 5""
```

### **Explanation**:
- `add(5, 3)` returns `8`, which is then compared with `5` in the conditional expression.
- Since `8 &gt; 5`, the result of the ternary operation is `""Greater than 5""`, and this value is assigned to `x`.

---

## **📌 Using Functions in Array or Object Assignments**

Functions can also be used when setting values in arrays or objects.

```js
function square(x) {
    return x * x;
}

var arr = [square(2), square(3), square(4)];
console.log(arr);  // Output: [4, 9, 16]
```

### **Explanation**:
- The `square` function is called three times with different values, and the results are stored in the `arr` array.

---

### **Key Takeaways**
✔ **JavaScript functions** can be used directly in **expressions**.
✔ The return value of a function can be part of larger **operations**, such as **mathematical calculations**, **conditional checks**, and **assignments**.
✔ Functions allow for more dynamic and reusable code by integrating their results into complex expressions.

🚀 **Using functions in expressions** enhances the flexibility and power of JavaScript, allowing for compact and efficient code!"		
128	Function definitions	Functions are Objects	"### **JavaScript Functions as Objects**

In JavaScript, **functions** are **first-class objects**. This means that functions are **objects** themselves and can have properties and methods. While the `typeof` operator returns `""function""` for functions, it's important to understand that **functions are objects** in JavaScript.

---

## **📌 Functions as Objects**

Since functions are objects in JavaScript, they can have properties and methods like any other object. The following examples illustrate how functions can behave as objects:

### **Example 1: `arguments.length` Property**

The `arguments.length` property returns the number of arguments received when the function was invoked. This is especially useful when dealing with functions that accept a variable number of arguments.

```js
function myFunction(a, b) {
  return arguments.length;
}

console.log(myFunction(1, 2));  // Output: 2
console.log(myFunction(1));     // Output: 1
console.log(myFunction());      // Output: 0
```

### **Explanation**:
- In this example, the `myFunction` function takes two parameters, but it can accept any number of arguments.
- `arguments.length` returns how many arguments were passed when the function was called.

---

## **📌 `toString()` Method**

Every function in JavaScript has a `toString()` method, which returns a string representation of the function's source code.

### **Example 2: Using `toString()` Method**

```js
function myFunction(a, b) {
    return a * b;
}

var txt = myFunction.toString();
console.log(txt);  // Output: ""function myFunction(a, b) { return a * b; }""
```

### **Explanation**:
- `myFunction.toString()` returns the **source code** of the function as a string.
- This can be useful for debugging, logging, or inspecting functions dynamically.

---

## **📌 Functions as Methods of Objects**

A function defined as a property of an object is called a **method**. A **method** is simply a function that is associated with an object and can be invoked using the object.

### **Example 3: Function as a Method**

```js
let person = {
  firstName: ""John"",
  lastName: ""Doe"",
  fullName: function() {
    return this.firstName + "" "" + this.lastName;
  }
};

console.log(person.fullName());  // Output: ""John Doe""
```

### **Explanation**:
- Here, `fullName` is a method because it's a function defined as a property of the `person` object.
- The function accesses the `firstName` and `lastName` properties of the `person` object using `this`.

---

## **📌 Object Constructor Functions**

A **constructor function** is a function designed to create new objects. It is used with the `new` keyword to create instances of objects that share a common structure.

### **Example 4: Object Constructor Function**

```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.fullName = function() {
    return this.firstName + "" "" + this.lastName;
  };
}

let person1 = new Person(""John"", ""Doe"");
let person2 = new Person(""Jane"", ""Smith"");

console.log(person1.fullName());  // Output: ""John Doe""
console.log(person2.fullName());  // Output: ""Jane Smith""
```

### **Explanation**:
- The `Person` function is an **object constructor** because it is designed to create new `Person` objects with the properties `firstName`, `lastName`, and the method `fullName`.
- The `new` keyword is used to create `person1` and `person2` instances.

---

### **Key Takeaways**
✔ **Functions are objects** in JavaScript and can have properties and methods like other objects.  
✔ The **`arguments.length`** property provides the number of arguments passed to a function.  
✔ The **`toString()`** method returns a string representation of the function’s source code.  
✔ A function defined as a property of an object is called a **method** of that object.  
✔ A **constructor function** is used to create new objects and typically uses the `new` keyword to instantiate them.

🚀 **JavaScript functions are versatile** and play a critical role in object-oriented programming by being used as methods, constructors, and having properties like any other object."		
129	Function parameters	Function Parameters and Arguments	"### **Function Parameters and Arguments in JavaScript**

In JavaScript, **functions** are designed to receive **parameters** and work with **arguments**. Understanding the difference between parameters and arguments is crucial for using functions effectively.

---

## **📌 Function Parameters**

Function parameters are the **names** defined in the function declaration. They act as placeholders for the values that will be passed to the function when it is called.

### **Syntax of Function Parameters**:

```js
function functionName(parameter1, parameter2, parameter3) {
    // code to be executed
}
```

- `parameter1`, `parameter2`, and `parameter3` are the **parameters**. They are placeholders that the function will use to operate on.
- These parameters will be replaced by **arguments** when the function is called.

---

## **📌 Function Arguments**

Function arguments are the **real values** passed to the function when it is called. These values correspond to the function’s parameters and are used inside the function to perform operations.

### **Example: Function with Parameters and Arguments**

```js
function add(a, b) {
    return a + b;
}

let result = add(5, 3);  // Arguments passed: 5 and 3
console.log(result);      // Output: 8
```

### **Explanation**:
- `a` and `b` are the **parameters** in the `add` function.
- `5` and `3` are the **arguments** passed to the function when it is called.
- Inside the function, `a` gets the value `5`, and `b` gets the value `3`, so the function returns `5 + 3 = 8`.

---

## **📌 Default Parameters (ES6)**

If you do not pass an argument for a parameter, it will be **undefined** by default. However, you can assign **default values** to parameters to ensure they always have a valid value.

### **Example: Default Parameters**

```js
function greet(name = ""Guest"") {
    return ""Hello, "" + name + ""!"";
}

console.log(greet(""John""));  // Output: ""Hello, John!""
console.log(greet());        // Output: ""Hello, Guest!""
```

### **Explanation**:
- In the `greet` function, `name` has a default value of `""Guest""`.
- If an argument is provided (like `""John""`), it will be used; otherwise, the default value `""Guest""` will be used.

---

## **📌 Rest Parameters (ES6)**

If you want a function to accept a variable number of arguments, you can use **rest parameters**. Rest parameters allow you to capture all remaining arguments passed to the function in an array.

### **Example: Rest Parameters**

```js
function sum(...numbers) {
    return numbers.reduce((total, num) =&gt; total + num, 0);
}

console.log(sum(1, 2, 3, 4));  // Output: 10
```

### **Explanation**:
- `...numbers` is a **rest parameter** that collects all arguments passed to the `sum` function into an array.
- The `reduce()` method is used to sum all the numbers.

---

## **📌 Key Takeaways**
✔ **Function parameters** are the **names** defined in the function declaration, while **function arguments** are the **values** passed to the function when it is called.  
✔ **Default parameters** allow you to assign a default value to a parameter if no argument is provided.  
✔ **Rest parameters** capture all arguments passed to a function into an array, allowing you to handle an indefinite number of arguments.

🚀 **Understanding parameters and arguments** is essential for working with functions in JavaScript and writing flexible, reusable code!"		
130	Function parameters	Parameter Rules	"### **JavaScript Function Flexibility**

In JavaScript, functions are quite **flexible** in terms of parameters and arguments. JavaScript does not enforce **data types** for parameters, **type checking** for arguments, or **checking the number of arguments** received. This flexibility allows for a more dynamic and versatile approach to handling functions.

---

## **📌 No Data Types for Parameters**

In JavaScript, function parameters do not specify data types. This means that **you don't need to declare the type of data (e.g., string, number)** that a parameter will receive.

### **Example: No Data Types for Parameters**

```js
function greet(name) {
    console.log(""Hello, "" + name);
}

greet(""John"");  // Output: ""Hello, John""
greet(42);      // Output: ""Hello, 42""
```

### **Explanation**:
- The `greet` function takes one parameter `name`, but there's no indication of the data type of `name`.
- You can pass both a **string** (`""John""`) and a **number** (`42`) as arguments to the same parameter, and the function will work without any issues.

---

## **📌 No Type Checking for Arguments**

JavaScript does not perform **type checking** on the arguments passed to a function. It will accept any value, regardless of whether it is the expected type or not.

### **Example: No Type Checking for Arguments**

```js
function add(a, b) {
    return a + b;
}

console.log(add(5, 10));      // Output: 15
console.log(add(""5"", ""10""));  // Output: ""510"" (String concatenation)
```

### **Explanation**:
- The `add` function is expecting two arguments (`a` and `b`), and it adds them together.
- If both arguments are numbers, it performs **addition**.
- If both arguments are **strings**, JavaScript will **concatenate** them, which shows that there is no type checking for the arguments. The `+` operator behaves differently based on the types of the operands.

---

## **📌 No Argument Count Checking**

JavaScript functions do not check the **number of arguments** received. If a function is called with more or fewer arguments than it declares, the function still works.

### **Example: No Argument Count Checking**

```js
function multiply(a, b) {
    return a * b;
}

console.log(multiply(3, 4));   // Output: 12
console.log(multiply(3));      // Output: NaN (undefined * 3)
console.log(multiply(3, 4, 5)); // Output: 12 (ignores the extra argument)
```

### **Explanation**:
- The `multiply` function expects two arguments (`a` and `b`).
- If you pass **only one argument**, the missing second argument (`b`) is `undefined`, so the function returns `NaN` (because `undefined` multiplied by any number results in `NaN`).
- If you pass more than two arguments, the function **ignores** the extra arguments and only uses the first two.

---

## **📌 Handling Undefined or Excess Arguments**

You can handle missing arguments (undefined) or excess arguments (those not needed) using different approaches:

### **1. Using Default Parameters (ES6)**

With **default parameters**, you can specify default values for parameters in case they are not provided:

```js
function greet(name = ""Guest"") {
    console.log(""Hello, "" + name);
}

greet();        // Output: ""Hello, Guest""
greet(""John"");  // Output: ""Hello, John""
```

### **2. Using `arguments` Object**

JavaScript functions provide an `arguments` object, which is an **array-like** object that contains all arguments passed to the function, even if they don't match the declared parameters:

```js
function sum() {
    let total = 0;
    for (let i = 0; i &lt; arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}

console.log(sum(1, 2, 3, 4));  // Output: 10
```

### **3. Rest Parameters (ES6)**

You can also use **rest parameters** (`...`) to handle any number of arguments passed to a function:

```js
function sum(...numbers) {
    return numbers.reduce((total, num) =&gt; total + num, 0);
}

console.log(sum(1, 2, 3, 4));  // Output: 10
```

---

### **Key Takeaways**
✔ **No data types for parameters**: JavaScript does not specify the types of parameters in function definitions. You can pass any type of value to the parameters.
  
✔ **No type checking**: JavaScript will accept any value as an argument, and the function will handle it based on the operation being performed.

✔ **No argument count checking**: Functions do not check the number of arguments passed. If more or fewer arguments are provided than declared, JavaScript will not throw an error, but will behave based on the available arguments.

✔ **Use default parameters, `arguments`, or rest parameters** to handle missing or excess arguments in a flexible way.

🚀 **JavaScript functions are flexible** and designed for dynamic handling of parameters and arguments, giving developers great flexibility in coding!"		
131	Function parameters	Parameter Defaults	"### **Handling Missing Function Arguments in JavaScript**

In JavaScript, when a function is called with **missing arguments** (i.e., fewer arguments than declared), the **missing values** are set to `undefined`. This behavior can sometimes lead to unexpected results, and thus, it may be beneficial to assign **default values** to parameters to ensure the function works as intended, even when arguments are missing.

---

## **📌 Manually Handling Missing Arguments**

Before ECMAScript 2015 (ES6), one common way to handle **missing arguments** was to check if the argument was `undefined` and manually assign a default value.

### **Example: Manually Setting Default Values**

```js
function myFunction(x, y) {
    if (y === undefined) { 
        y = 0;  // Default value for y
    }
    console.log(x, y);
}

myFunction(5);  // Output: 5 0
myFunction(5, 10);  // Output: 5 10
```

### **Explanation**:
- In this example, `myFunction` has two parameters, `x` and `y`.
- If `y` is missing (i.e., `undefined`), it is manually set to `0` inside the function.
- The function works for both cases: when one or both arguments are provided.

---

## **📌 Default Parameters in ECMAScript 2015 (ES6)**

With **ECMAScript 2015 (ES6)**, JavaScript introduced **default parameters**, which allow you to assign default values directly in the function declaration. This simplifies the code and makes it cleaner.

### **Example: Default Parameters in ES6**

```js
function myFunction(a = 1, b = 1) {
    console.log(a, b);
}

myFunction();      // Output: 1 1
myFunction(5);     // Output: 5 1
myFunction(5, 10); // Output: 5 10
```

### **Explanation**:
- In this example, `a` and `b` have default values of `1`.
- If no arguments are passed for `a` or `b`, the default values (`1`) are used.
- This eliminates the need for manually checking and assigning default values inside the function body.

---

## **📌 Default Parameters with Expressions**

You can also use **expressions** as default values, which can be more flexible and dynamic.

### **Example: Default Parameters with Expressions**

```js
function calculatePrice(price, taxRate = 0.05) {
    return price + (price * taxRate);
}

console.log(calculatePrice(100));    // Output: 105 (using default tax rate)
console.log(calculatePrice(100, 0.10)); // Output: 110 (using provided tax rate)
```

### **Explanation**:
- `taxRate` has a default value of `0.05`, but you can override it by providing a different value when calling the function.
- If no `taxRate` is provided, the default value of `0.05` is used.

---

## **📌 Key Takeaways**
✔ **Missing arguments** are set to `undefined` by default in JavaScript functions.  
✔ **Default values** can be assigned manually inside the function using an `if` statement, or more conveniently, you can use **default parameters** in the function declaration (ES6).
✔ **ES6 default parameters** simplify the code and make it easier to assign default values directly in the function signature.
✔ Default parameters can also use **expressions**, providing more flexibility in function calls.

🚀 **Using default parameters** helps prevent errors when arguments are missing and ensures more predictable and clean code in JavaScript!"		
132	Function parameters	The Arguments Object	"### **The `arguments` Object in JavaScript**

In JavaScript, **functions** have a built-in object called **`arguments`**. The `arguments` object is an **array-like object** that contains all the **arguments passed to the function**, regardless of the number of parameters defined in the function declaration.

The `arguments` object allows you to work with **variable numbers of arguments** without knowing how many arguments will be passed when calling the function. This can be especially useful when you want to perform operations on all arguments dynamically.

---

## **📌 Using the `arguments` Object**

The `arguments` object is available inside any function and contains an array of values that were passed to the function. It has the following properties:
- **`arguments.length`**: Returns the number of arguments passed to the function.
- **`arguments[i]`**: Allows you to access the individual arguments passed to the function, where `i` is the index.

### **Example: Summing All Arguments Using the `arguments` Object**

```js
function sumAll() {
    var i, sum = 0;
    for (i = 0; i &lt; arguments.length; i++) {
        sum += arguments[i];
    }
    return sum;
}

var x = sumAll(1, 123, 500, 115, 44, 88);
console.log(x);  // Output: 871
```

### **Explanation**:
- The `sumAll` function uses the `arguments` object to access all the arguments passed to it.
- It loops through all arguments and adds them to the `sum` variable.
- The result is returned, which is the sum of all the values passed as arguments.

### **Output**:
- `sumAll(1, 123, 500, 115, 44, 88)` will return `871`, the sum of all these values.

---

## **📌 Accessing Excess Arguments with the `arguments` Object**

If a function is called with **more arguments** than the function’s parameters, you can still access the extra arguments using the `arguments` object. This allows you to **handle variable numbers of arguments**.

### **Example: Function with Extra Arguments**

```js
function greet(name) {
    console.log(""Hello, "" + name);
    console.log(""Arguments passed:"", arguments);
}

greet(""John"", ""extra1"", ""extra2"");
// Output:
// Hello, John
// Arguments passed: [""John"", ""extra1"", ""extra2""]
```

### **Explanation**:
- In the `greet` function, only one parameter `name` is declared, but two extra arguments (`""extra1""` and `""extra2""`) are passed.
- The `arguments` object contains all three values, and we can access them as needed, even though they weren't explicitly declared as parameters.

---

## **📌 Important Considerations with the `arguments` Object**

1. **Array-like, but not an array**:
   - The `arguments` object is **array-like** (it has a `length` property and can be indexed), but it does not have array methods like `push()`, `pop()`, or `map()`. If you need to use array methods, you must convert it to a real array.
   
   ```js
   function example() {
       var argsArray = Array.from(arguments);
       console.log(argsArray.map(num =&gt; num * 2));
   }

   example(1, 2, 3);  // Output: [2, 4, 6]
   ```

2. **Does not work with arrow functions**:
   - **Arrow functions** do not have their own `arguments` object. Instead, they inherit the `arguments` object from the surrounding function (if any). Therefore, you cannot use `arguments` inside an arrow function unless it's within a non-arrow function.
   
   ```js
   const sum = () =&gt; {
       console.log(arguments);  // Error: arguments is not defined
   };
   
   sum(1, 2, 3);  // Will throw an error because arrow functions do not have their own arguments object
   ```

3. **`arguments` is available for all function types**:
   - The `arguments` object works with **function declarations**, **function expressions**, and **constructor functions**, but not with **arrow functions**.

---

### **Key Takeaways**
✔ The **`arguments` object** is available inside all functions, containing all arguments passed to the function, even if they are not declared in the function signature.  
✔ You can use **`arguments.length`** to find how many arguments were passed and **`arguments[i]`** to access each argument.  
✔ If the function receives more arguments than declared, the extra arguments can be accessed via the `arguments` object.  
✔ The `arguments` object is **array-like** but not a true array (it lacks array methods). You can convert it to a real array using `Array.from()`.  
✔ **Arrow functions** do not have their own `arguments` object, unlike regular functions.

🚀 The **`arguments` object** provides a powerful way to handle **variable-length arguments** and gives flexibility in writing functions that can accept any number of parameters!"		
133	Function parameters	Arguments are Passed by Value	"### **Passing Arguments in JavaScript: By Value**

In JavaScript, when you pass **arguments** to a function, they are passed **by value**, meaning that the function only receives a copy of the argument's value, not the original variable. This behavior affects how changes to the arguments inside the function impact the original values outside the function.

---

## **📌 Function Parameters and Arguments**

- **Function parameters** are the names listed in the function definition.
- **Arguments** are the actual values passed to the function when it is called.

### **Example: Function Parameters and Arguments**

```js
function multiply(a, b) {
    return a * b;
}

var result = multiply(5, 3);
console.log(result);  // Output: 15
```

- `a` and `b` are **parameters** of the `multiply` function.
- `5` and `3` are **arguments** passed to the function when it is called.

---

## **📌 JavaScript Arguments are Passed by Value**

When you pass arguments to a JavaScript function, they are **passed by value**. This means that the function gets a copy of the argument's value, not the reference to the variable itself (for primitive types).

### **Example: Passing Primitive Values (Passed by Value)**

```js
function changeValue(x) {
    x = 10;  // Trying to change the value of x
}

let num = 5;
changeValue(num);
console.log(num);  // Output: 5
```

### **Explanation**:
- The function `changeValue` takes a parameter `x` and changes its value to `10`.
- However, `num` outside the function remains `5` because **JavaScript passes the argument by value**. The function modifies the **local copy** of the value, but the **original value** of `num` is not affected.

---

## **📌 Changes to Arguments Do Not Affect the Original Value (Primitive Types)**

Since arguments are passed by value, changes made inside the function do not affect the original value outside the function.

### **Example: Modifying a Primitive Argument**

```js
function modifyValue(a) {
    a = 20;  // Modify the local copy of 'a'
}

let value = 5;
modifyValue(value);
console.log(value);  // Output: 5
```

### **Explanation**:
- Inside the function, `a` is changed to `20`, but `value` remains `5` outside the function.
- This is because the function only receives a **copy** of the value, not a reference to the original variable.

---

## **📌 Passing Objects (Reference Types) by Value**

While **primitive types** (like numbers, strings, and booleans) are passed by value, **objects** (including arrays and functions) are passed by reference. This means that while you still pass the reference by value, the reference points to the original object, and changes to the object's properties will affect the original object.

### **Example: Passing Objects by Reference**

```js
function modifyObject(obj) {
    obj.name = ""John"";  // Modify the object's property
}

let person = { name: ""Alice"" };
modifyObject(person);
console.log(person.name);  // Output: ""John""
```

### **Explanation**:
- The object `person` is passed by reference, so when we modify the `name` property inside the function, the change is reflected outside the function.
- However, the **reference to the object** itself is passed by value (not the object itself), meaning you cannot reassign the **entire object** (i.e., make the object point to something else) inside the function.

---

## **📌 Key Takeaways**

✔ **Function parameters** are the **names** defined in the function. **Arguments** are the **values** passed to the function.  
✔ **Primitive types** (numbers, strings, booleans) are passed **by value**. Changing the argument inside the function does not affect the original value.  
✔ **Objects** (including arrays and functions) are passed **by reference**. Changes to the object's properties inside the function affect the original object.  
✔ **Reassigning an object** inside the function does not affect the original reference outside the function.  
✔ **Changes inside the function are visible only for the passed arguments** and not for the original variables unless they are objects.

🚀 **Understanding passing by value and by reference** is crucial for working with variables and objects effectively in JavaScript!"		
134	Function parameters	Objects are Passed by Reference	"### **JavaScript Objects and Passing by Reference**

In JavaScript, **objects** are handled differently than primitive data types (like numbers and strings). While **primitive values** are passed **by value**, **objects** are passed **by reference**. This means that when you pass an object to a function, the function works with the **original object** itself, not a copy of it. Therefore, changes made to the object inside the function will be reflected outside the function as well.

---

## **📌 Objects are Passed by Reference**

In JavaScript, **objects** (which include arrays, functions, and other complex data types) are **passed by reference**. This means that when you pass an object to a function, the function gets a reference (a pointer) to the original object. If the function modifies the object, those changes will affect the **original object** outside the function.

### **Example: Modifying Object Properties Inside a Function**

```js
function modifyObject(obj) {
    obj.name = ""John"";  // Modify the object's property
}

let person = { name: ""Alice"" };
console.log(person.name);  // Output: ""Alice""

modifyObject(person);      // Modify the object inside the function
console.log(person.name);  // Output: ""John""
```

### **Explanation**:
- The `person` object is passed to the `modifyObject` function.
- Inside the function, we change the `name` property of `person` to `""John""`.
- Since objects are passed by reference, this modification is reflected outside the function, and the `name` property of `person` is now `""John""`.

---

## **📌 Why Objects Behave Like They're Passed by Reference**

When an object is passed to a function in JavaScript, the function receives a **reference to the object**, not a **copy** of it. This reference points to the **original object** in memory, which means that any changes made to the object's properties inside the function will directly modify the original object.

### **Example: Objects Are References, Not Copies**

```js
function changePerson(personObj) {
    personObj.age = 30;  // Change the property of the object
}

let person1 = { name: ""John"", age: 25 };
let person2 = person1;  // Assign person1's reference to person2

changePerson(person2);  // Modify person2's properties

console.log(person1.age);  // Output: 30 (Changes are reflected in person1)
console.log(person2.age);  // Output: 30 (Changes are reflected in person2)
```

### **Explanation**:
- `person2` is assigned the **reference** to `person1`, not a copy of it. Both variables now point to the same object in memory.
- When `person2` is passed to `changePerson()`, it modifies the `age` property of the same object that `person1` refers to.
- As a result, the change to `person2.age` is also reflected in `person1.age` because they both refer to the same object.

---

## **📌 Modifying Object References Inside Functions**

While objects are passed by reference, it's important to note that if you try to reassign the object itself inside the function, the **original reference** (outside the function) will **not be affected**.

### **Example: Reassigning an Object Reference Inside a Function**

```js
function modifyObjectReference(obj) {
    obj = { name: ""Bob"", age: 40 };  // Reassign the reference to a new object
    console.log(obj.name);  // Output: ""Bob"" (local object inside the function)
}

let person = { name: ""Alice"", age: 30 };
modifyObjectReference(person);

console.log(person.name);  // Output: ""Alice"" (original object remains unchanged)
```

### **Explanation**:
- Inside the function, `obj` is reassigned to a **new object** with `name: ""Bob""` and `age: 40`.
- However, this reassignment does **not affect the original `person` object** outside the function.
- The original `person` object still has `name: ""Alice""` because only the **reference** to the object was passed, not the object itself. Reassigning the `obj` variable inside the function does not affect the **original reference**.

---

## **📌 Key Takeaways**
✔ **Objects are passed by reference**: When you pass an object to a function, the function works with the **original object**. Any changes to the object's properties inside the function are reflected outside the function.  
✔ **Changes to object properties are visible outside the function** because the object is passed by reference.  
✔ **Reassigning an object** inside a function does **not affect** the original object outside the function. The reference is passed, but reassigning the variable inside the function does not change the original reference.  
✔ **Primitive values** (numbers, strings, booleans) are passed **by value**, meaning changes to them inside the function do not affect the original value.

🚀 **Understanding how objects are passed by reference** helps you manage data effectively in JavaScript and avoid unintended side effects!"		
135	Function invocation	Invoking a JavaScript Function	"### **Understanding Function Invocation in JavaScript**

In JavaScript, functions are **defined** with specific code inside them, but that code does not execute until the function is **invoked** (or **called**). This allows for reusability and modular code because a function can be defined once and invoked multiple times, whenever needed.

---

## **📌 Function Definition vs. Function Invocation**

- **Function Definition**: This is when the function is created. The code inside the function is **not executed** at this stage.
  
  ```js
  function myFunction() {
    console.log(""Hello, World!"");
  }
  ```

- **Function Invocation (or Call)**: This is when the function is **executed**. The code inside the function is **run** at this point.
  
  ```js
  myFunction();  // Function invocation
  ```

### **Explanation**:
- The function `myFunction` is defined with the code `console.log(""Hello, World!"");`, but it **does not run** until `myFunction()` is **invoked**.

---

## **📌 Why Use ""Invoke"" Instead of ""Call""?**

While **""call""** is the most common term used to describe invoking a function in JavaScript, the term **""invoke""** is also appropriate. This is because a function can be **invoked** in various ways, such as using **`call()`**, **`apply()`**, or directly invoking it with parentheses (`()`).

### **Common Terms for Invoking a Function**:
- **Call a function**
- **Invoke a function**
- **Execute a function**
- **Call upon a function**
- **Start a function**

### **Example of Function Invocation**:

```js
function greet(name) {
    console.log(""Hello, "" + name);
}

// Invoking the function
greet(""Alice"");  // Output: ""Hello, Alice""
```

- In this example, the function `greet(""Alice"")` is invoked (or called), and the code inside the function is executed.

---

## **📌 Using `call()` and `apply()` for Invocation**

JavaScript functions also have **`call()`** and **`apply()`** methods that allow you to **invoke a function** with a specific `this` context and arguments.

### **Using `call()`**:

```js
function greet(name) {
    console.log(""Hello, "" + name);
}

greet.call(this, ""John"");  // Output: ""Hello, John""
```

### **Using `apply()`**:

```js
function greet(name, age) {
    console.log(""Hello, "" + name + "". You are "" + age + "" years old."");
}

greet.apply(this, [""John"", 30]);  // Output: ""Hello, John. You are 30 years old.""
```

- Both `call()` and `apply()` allow for invoking the function with a specific context (`this`) and arguments.
- **`call()`** takes arguments separately, while **`apply()`** takes arguments as an array.

---

## **📌 Key Takeaways**
✔ **Function Definition**: The code inside a function is not executed when the function is defined; it is executed when the function is **invoked**.
  
✔ **Function Invocation**: The function is executed when it is invoked (or called), and this can happen using different methods like direct invocation, `call()`, or `apply()`.

✔ **Common Terminology**: While **""call""** is widely used, **""invoke""** is equally valid, as functions can be invoked in several ways, and it's essential to understand the context of invocation.

🚀 **Understanding when and how to invoke functions** allows you to control the execution flow and behavior of your code, making it more modular and reusable!"		
136	Function invocation	Invoking a Function as a Function	"### **JavaScript Functions and Global Objects**

In JavaScript, functions can exist outside any specific object and still be executed in the global scope. This means that they may belong to a **global object** by default. Understanding how this works, especially in the context of browsers and HTML, helps us avoid potential issues with **name conflicts** and **unintentional overwriting** of global variables or functions.

---

## **📌 Global Functions and the Default Global Object**

### **Global Objects in Different Contexts**:
1. **In a Web Browser**: When JavaScript is run in a browser, the **default global object** is the **`window`** object.
2. **In Node.js**: The default global object is `global`.
3. **In HTML**: When running JavaScript within an HTML page, the global object is the **HTML page** itself, and functions or variables defined in the global scope are attached to this page.

### **Example of a Global Function in a Browser**:

```js
function myFunction(a, b) {
    return a * b;
}

myFunction(10, 2);  // Will return 20
```

- The function `myFunction()` is **global** because it is declared in the global scope (outside any objects).
- In a browser, this function automatically becomes a **property of the `window` object**, which is the global object in browsers.

### **Accessing Global Function through `window`**:

```js
window.myFunction(10, 2);  // Output: 20
```

- Both `myFunction()` and `window.myFunction()` refer to the same function, because global functions are automatically added to the `window` object in a browser.

---

## **📌 Problems with Global Functions and Variables**

While it is common to invoke a global function like `window.myFunction()`, this practice is **not recommended**. Here’s why:

1. **Global Scope Pollution**: Defining too many functions or variables in the global scope can lead to **name conflicts** where one variable or function accidentally overwrites another. This makes it difficult to debug and maintain your code.

2. **Unintentional Overwrites**: If you or other scripts define variables or functions with the same name in the global scope, they can **overwrite each other**, causing unexpected behavior.

### **Example: Name Conflict in the Global Scope**:

```js
var user = ""John""; // Global variable

function sayHello() {
    console.log(""Hello, "" + user);
}

sayHello();  // Output: ""Hello, John""

// Later in the code, overwriting the global variable 'user'
user = ""Alice"";  
sayHello();  // Output: ""Hello, Alice""
```

- The global `user` variable can be unintentionally modified, and this can affect functions that rely on it.
- If there is a naming conflict, the value of the `user` variable might change unexpectedly.

---

## **📌 Best Practices: Avoid Global Functions and Variables**

It’s generally **best practice** to avoid defining functions and variables in the global scope as much as possible. Instead, use more controlled, local scopes to prevent conflicts.

### **1. Use Functions Inside Objects**:

By organizing functions inside objects or classes, you avoid polluting the global scope and prevent conflicts.

```js
const calculator = {
    multiply: function(a, b) {
        return a * b;
    }
};

console.log(calculator.multiply(10, 2));  // Output: 20
```

- The `multiply` function is now a **method of the `calculator` object**, and it's not added to the global scope, reducing the risk of conflicts.

### **2. Use IIFE (Immediately Invoked Function Expressions)**:

An **IIFE** is a function that is defined and executed immediately. This allows you to limit the scope of your variables and functions.

```js
(function() {
    var localVariable = ""I am private"";
    console.log(localVariable);
})();
```

- The variable `localVariable` is **not added to the global scope**, and it's contained within the function.

### **3. Use `let` and `const` for Block Scoping**:

Instead of using `var`, which declares variables in the **global scope or function scope**, use `let` and `const` to declare variables that are scoped to the **block** in which they are defined.

```js
if (true) {
    let blockScoped = ""I am limited to this block"";
    console.log(blockScoped);  // Output: ""I am limited to this block""
}

// Outside the block, 'blockScoped' is not accessible
console.log(blockScoped);  // Error: blockScoped is not defined
```

---

## **📌 Key Takeaways**
✔ **Global functions** and variables are added to the **global object** (`window` in browsers), which can lead to **name conflicts** and **unintended overwriting** of values.  
✔ **Avoid defining functions and variables** in the global scope when possible to reduce the risk of name conflicts.  
✔ Use **objects**, **IIFE**, or **block-scoped variables (`let`/`const`)** to keep functions and variables confined to local scopes, minimizing potential issues.

🚀 By keeping your code modular and properly scoped, you can avoid problems caused by global object pollution and write more maintainable and bug-free JavaScript code!"		
137	Function invocation	The Global Object	"### **The `this` Keyword in JavaScript**

In JavaScript, the **`this`** keyword refers to the **current execution context**. It behaves differently depending on how a function is invoked. When a function is called without an explicit owner object (i.e., when it's invoked as a **global function**), the value of `this` refers to the **global object**.

In a **web browser**, the global object is the **`window`** object. Therefore, when a function is invoked globally, `this` inside that function points to the `window` object.

---

## **📌 Example: `this` in a Global Function**

```js
var x = myFunction();  // x will be the window object

function myFunction() {
    return this;
}

console.log(x);  // Output: [object Window] (The window object)
```

### **Explanation**:
- In the example above, `myFunction()` is invoked **globally** (without an owner object).
- Because it's a global function, the value of `this` inside `myFunction()` points to the **global object**, which is the `window` object in a web browser.
- The variable `x` stores the `window` object, as `this` refers to the global object in this case.

---

## **📌 Why Does This Happen?**

When a function is invoked **globally**, JavaScript's default behavior is to assign `this` to refer to the global object. This can be problematic when you expect `this` to refer to a specific object (like an instance of a class or an object method).

### **Example: `this` in Global Context**

```js
var myVar = ""Hello, world!"";

function showVar() {
    console.log(this.myVar);  // 'this' refers to the global object (window in browsers)
}

showVar();  // Output: Hello, world! (because 'myVar' is a global variable)
```

- In this example, `this.myVar` refers to the **global variable** `myVar` because `this` refers to the global object (`window` in a browser).

---

## **📌 Potential Problems: Using `window` as a Variable**

Using `window` as a variable name in the global scope can lead to unexpected behavior and bugs, as it overwrites the global `window` object. Since `window` is a key part of the browser environment (it represents the browser window), reassigning it can cause issues in your program.

### **Example: Overwriting `window`**

```js
var window = ""Some string"";  // Overwriting the global window object

function testWindow() {
    console.log(window);  // 'window' refers to the string, not the global object
}

testWindow();  // Output: ""Some string""
```

### **Explanation**:
- In this example, `window` is assigned the string `""Some string""`, and it **overwrites** the global `window` object.
- As a result, calling `testWindow()` outputs `""Some string""`, not the actual `window` object.

---

## **📌 Best Practices to Avoid Issues with `this` and Global Objects**

1. **Avoid overwriting the `window` object**: Never assign values to the `window` variable in a browser. It can lead to unexpected behavior and cause your program to break.
  
2. **Use strict mode**: Enabling **strict mode** (`'use strict';`) prevents JavaScript from assigning `this` to the global object when a function is invoked without an owner object. It helps avoid accidental global variable declarations.

    ```js
    'use strict';
    function myFunction() {
        console.log(this);  // undefined, not the global object
    }

    myFunction();  // In strict mode, this will be 'undefined', not the window object
    ```

3. **Use objects and methods**: When invoking functions, it's a good practice to call them within objects or classes to ensure that `this` behaves as expected and points to the correct object.

    ```js
    const myObj = {
        myVar: ""Hello"",
        myFunction: function() {
            console.log(this.myVar);  // 'this' refers to the object (myObj)
        }
    };

    myObj.myFunction();  // Output: ""Hello""
    ```

---

### **Key Takeaways**
✔ When a function is invoked without an owner object (as a global function), the value of `this` refers to the **global object** (`window` in browsers).  
✔ **Using `window` as a variable** in the global scope can overwrite the global object and cause bugs.  
✔ To avoid issues, **use strict mode**, avoid overwriting global objects, and **use methods inside objects** to ensure `this` behaves as expected.

🚀 **Understanding how `this` behaves** and the risks of global object manipulation helps you write more reliable and predictable JavaScript code!"		
138	Function invocation	Invoking a Function as a Method	"### **Functions as Object Methods in JavaScript**

In JavaScript, **functions can be defined as methods of objects**. A function that belongs to an object is called a **method**, and it can use the **`this` keyword** to refer to the object it belongs to.

---

## **📌 Example: Function as an Object Method**

```js
var myObject = {
    firstName: ""John"",
    lastName: ""Doe"",
    fullName: function () {
        return this.firstName + "" "" + this.lastName;
    }
};

console.log(myObject.fullName());  // Output: ""John Doe""
```

### **Explanation**:
- `fullName` is a **method** of `myObject`, meaning it is a function stored as a property of the object.
- The **`this` keyword** inside `fullName()` refers to `myObject`, so it can access `firstName` and `lastName`.
- When calling `myObject.fullName()`, JavaScript treats it as a method, and `this` refers to `myObject`, allowing access to its properties.

---

## **📌 The `this` Keyword in Object Methods**
- When a function is **called as a method of an object**, `this` refers to the **object that owns the function**.
- In the example above, `this` refers to `myObject`.

### **Example: Confirming the Value of `this`**
```js
var myObject = {
    firstName: ""Alice"",
    lastName: ""Johnson"",
    showThis: function() {
        console.log(this);  // Will log myObject
    }
};

myObject.showThis();
```
- This will log the `myObject` itself because `this` inside `showThis()` refers to `myObject`.

---

## **📌 What Happens if `this` is Used Outside an Object?**
When a function is **not** part of an object and is called globally, `this` refers to the **global object** (`window` in browsers).

### **Example: Global Function vs. Object Method**
```js
function globalFunction() {
    console.log(this);  // In a browser, this refers to 'window'
}

globalFunction();  // Logs the global object (window)
```

- Since `globalFunction()` is not called as a method of an object, `this` refers to the **global object** (`window` in browsers).

---

## **📌 Adding Methods to Objects Dynamically**
You can add methods to an existing object **after** it has been created.

### **Example: Adding a Method After Object Creation**
```js
var person = {
    firstName: ""Jane"",
    lastName: ""Smith""
};

// Adding a method dynamically
person.getFullName = function() {
    return this.firstName + "" "" + this.lastName;
};

console.log(person.getFullName());  // Output: ""Jane Smith""
```

- The method `getFullName` is added **after the object was created**.
- It still has access to `this` and can retrieve `firstName` and `lastName`.

---

## **📌 Key Takeaways**
✔ **Functions can be assigned as object methods**, making them behave as part of the object.  
✔ **The `this` keyword inside an object method refers to the object itself**, allowing access to its properties.  
✔ **Calling a function as an object method (`object.method()`) makes `this` refer to the object**.  
✔ **If a function is called globally**, `this` refers to the **global object** (`window` in browsers).  
✔ **Methods can be added dynamically** to objects after they are created.

🚀 **Using methods in objects** is a fundamental part of JavaScript's **object-oriented programming**, allowing you to define reusable, organized, and maintainable code!"		
139	Function invocation	Invoking a Function with a Function Constructor	"### **JavaScript Constructor Invocation (`new` Keyword and `this` in Constructors)**

In JavaScript, when a function is called with the `new` keyword, it is considered a **constructor invocation**. This means the function behaves as a **blueprint** for creating new objects. Since JavaScript functions are also **objects**, calling a function as a constructor actually **creates a new object**.

---

## **📌 What is a Constructor Function?**
A **constructor function** is a function used with the `new` keyword to create new objects. It acts as a **template** for defining object properties and methods.

### **Example: Constructor Function**
```js
function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}
```
- `Person` is a **constructor function**.
- It assigns `firstName` and `lastName` to the `this` object.

---

## **📌 Creating an Object Using a Constructor**
A **constructor invocation** happens when calling a function with the `new` keyword. This creates a **new object** that inherits properties and methods from the constructor.

### **Example: Creating an Object**
```js
var x = new Person(""John"", ""Doe"");

console.log(x.firstName);  // Output: ""John""
console.log(x.lastName);   // Output: ""Doe""
```
### **Explanation**:
- `new Person(""John"", ""Doe"")` creates a new object and assigns it to `x`.
- The **`this` keyword** inside `Person` refers to the newly created object.
- `firstName` and `lastName` are added as properties of the new object.

---

## **📌 How `this` Works in a Constructor**
- When a constructor function is **called with `new`**, the value of `this` inside the function refers to the **newly created object**.
- This allows the function to assign properties to the new object.

### **Example: `this` Inside a Constructor**
```js
function Car(brand, model) {
    console.log(this);  // Before assignment, 'this' is an empty object
    this.brand = brand;
    this.model = model;
    console.log(this);  // After assignment, 'this' has brand and model properties
}

var myCar = new Car(""Toyota"", ""Corolla"");
```
- The first `console.log(this)` prints `{}` (an empty object).
- After assigning `brand` and `model`, the second `console.log(this)` prints `{ brand: ""Toyota"", model: ""Corolla"" }`.

---

## **📌 Constructor Functions vs. Regular Functions**
### **Calling a Function Normally**
If you call a function **without `new`**, `this` refers to the **global object** (or `undefined` in strict mode).

```js
function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}

Person(""John"", ""Doe"");  // Called without `new`

console.log(window.firstName);  // Output: ""John"" (polluted global object in browsers)
```

- Here, `this` refers to the **global object** (`window` in browsers), causing unintended global variables.

### **Calling a Function with `new`**
```js
var person1 = new Person(""John"", ""Doe"");
console.log(person1.firstName);  // Output: ""John""
```
- Using `new` ensures that `this` refers to the **newly created object**.

---

## **📌 Adding Methods to a Constructor Function**
You can define methods inside the constructor, but it is **better to use the prototype** for efficiency.

### **Example: Adding a Method Using Prototype**
```js
function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}

// Adding a method to the prototype
Person.prototype.fullName = function() {
    return this.firstName + "" "" + this.lastName;
};

var person1 = new Person(""Alice"", ""Johnson"");
console.log(person1.fullName());  // Output: ""Alice Johnson""
```
- **Prototype methods** are shared across all instances, making memory usage more efficient.

---

## **📌 Summary of Constructor Invocation**
| Feature                     | Explanation |
|-----------------------------|-------------|
| **Constructor Invocation**   | A function called with `new` creates a new object. |
| **Use of `this`**            | Inside a constructor, `this` refers to the new object. |
| **Inheritance**              | The new object inherits properties from the constructor function. |
| **Global Object Pollution**  | Calling a function without `new` may modify the global object. |

---

### **📌 Key Takeaways**
✔ **Using `new`** creates a new object and assigns `this` to it.  
✔ **Functions without `new`** act as normal functions and may modify the global object.  
✔ **Methods should be added using `prototype`** for better efficiency.  
✔ **Constructors allow object creation** based on a common blueprint.

🚀 **Understanding constructor functions** is essential for **object-oriented programming** in JavaScript and helps you build reusable and scalable code!"		
140	Function call	The JavaScript call() Method	"### **The `call()` Method in JavaScript**

The **`call()`** method is a **built-in JavaScript method** that allows you to invoke a function with a specified `this` value. It enables one object to **use a method** that belongs to another object.

This is useful for **method borrowing**, where objects can share function definitions without duplicating them.

---

## **📌 How `call()` Works**
- The `call()` method allows you to **explicitly set `this`** when invoking a function.
- It takes an **object** as its first argument, which will be used as the `this` value inside the function.

### **Syntax:**
```js
functionName.call(thisArg, arg1, arg2, ...);
```
- `thisArg`: The object to use as `this` inside the function.
- `arg1, arg2, ...`: Additional arguments passed to the function.

---

## **📌 Example: Using `call()` to Use a Method from Another Object**

### **Example 1: Borrowing a Method from Another Object**
```js
var person = {
    fullName: function() {
        return this.firstName + "" "" + this.lastName;
    }
};

var person1 = {
    firstName: ""John"",
    lastName: ""Doe""
};

// Using call() to execute fullName with person1's properties
console.log(person.fullName.call(person1));  // Output: ""John Doe""
```

### **Explanation**:
- `fullName()` is defined inside `person`.
- The function is **not** inside `person1`, but we use `call(person1)` to invoke `fullName()` with `person1` as `this`.
- As a result, `this.firstName` refers to `person1.firstName` (`""John""`), and `this.lastName` refers to `person1.lastName` (`""Doe""`).

---

## **📌 Passing Arguments with `call()`**
The `call()` method also allows passing additional arguments to the function.

### **Example 2: Using `call()` with Arguments**
```js
var person = {
    fullName: function(city, country) {
        return this.firstName + "" "" + this.lastName + "", "" + city + "", "" + country;
    }
};

var person1 = {
    firstName: ""Alice"",
    lastName: ""Smith""
};

// Using call() with additional arguments
console.log(person.fullName.call(person1, ""New York"", ""USA""));
// Output: ""Alice Smith, New York, USA""
```

### **Explanation**:
- `fullName()` now takes `city` and `country` as additional arguments.
- When calling `call()`, we pass `person1` as `this`, followed by `""New York""` and `""USA""`.
- The function executes using `person1`’s properties and the provided arguments.

---

## **📌 Difference Between `call()` and `apply()`**
- Both `call()` and `apply()` allow you to **invoke a function with a specific `this` context**.
- The difference is in **how additional arguments** are passed.

| Method | Syntax | Argument Passing |
|--------|--------|-----------------|
| `call()` | `func.call(thisArg, arg1, arg2, ...)` | Arguments are passed **individually** |
| `apply()` | `func.apply(thisArg, [arg1, arg2, ...])` | Arguments are passed as an **array** |

### **Example: `apply()` Version of Previous Example**
```js
console.log(person.fullName.apply(person1, [""New York"", ""USA""]));
```
- In `apply()`, arguments must be passed inside an **array**.

---

## **📌 When to Use `call()`**
✔ **Method borrowing**: When one object wants to use a method defined in another object.  
✔ **Setting `this` explicitly**: When calling a function with a specific object as its `this` value.  
✔ **Passing arguments individually**: Unlike `apply()`, where arguments must be in an array.

---

### **📌 Key Takeaways**
✔ The **`call()` method** allows you to invoke a function with a specific `this` value.  
✔ It is useful for **method borrowing**, allowing one object to use another object’s method.  
✔ Arguments can be passed **individually** after the `this` value.  
✔ **`call()` vs `apply()`**: `call()` takes individual arguments, while `apply()` takes an array.  

🚀 **Using `call()` efficiently** allows for **code reusability**, avoiding duplicate function definitions while maintaining flexibility in object-oriented JavaScript programming!"		
141	Function call	The call() Method with Arguments	"### **Passing Arguments with `call()` in JavaScript**

The **`call()`** method in JavaScript allows a function to be invoked with a specific `this` value, and it can also accept **additional arguments**.

---

## **📌 Example: Using `call()` with Arguments**

```js
var person = {
    fullName: function(city, country) {
        return this.firstName + "" "" + this.lastName + "", "" + city + "", "" + country;
    }
};

var person1 = {
    firstName: ""John"",
    lastName: ""Doe""
};

// Calling fullName() with person1 as this and passing additional arguments
console.log(person.fullName.call(person1, ""Oslo"", ""Norway""));  
// Output: ""John Doe, Oslo, Norway""
```

### **Explanation**:
- The **`fullName` method** is defined inside `person` and expects **two parameters**: `city` and `country`.
- **`call()`** is used to invoke `fullName` using `person1` as `this`, meaning:
  - `this.firstName` becomes `person1.firstName` (`""John""`)
  - `this.lastName` becomes `person1.lastName` (`""Doe""`)
- `""Oslo""` and `""Norway""` are passed as additional **arguments**, so they replace `city` and `country` in the function.

---

## **📌 `call()` vs. `apply()` for Passing Arguments**
Both `call()` and `apply()` are used to **invoke functions** with a specific `this` value, but they differ in **how arguments are passed**.

| Method | Syntax | Argument Passing |
|--------|--------|-----------------|
| `call()` | `func.call(thisArg, arg1, arg2, ...)` | Arguments are passed **individually** |
| `apply()` | `func.apply(thisArg, [arg1, arg2, ...])` | Arguments are passed as an **array** |

### **Example: Using `apply()` Instead**
```js
console.log(person.fullName.apply(person1, [""Oslo"", ""Norway""]));  
// Output: ""John Doe, Oslo, Norway""
```

- **`call()`** takes arguments **individually**.
- **`apply()`** takes arguments **inside an array**.

---

## **📌 When to Use `call()`**
✔ **Method borrowing**: When one object wants to use a function from another object.  
✔ **Explicitly setting `this`**: When invoking a function with a specific object as its context.  
✔ **Passing multiple arguments**: `call()` lets you pass arguments separately instead of inside an array.

---

### **📌 Key Takeaways**
✔ **`call()` allows functions to be invoked with a specific `this` context and additional arguments.**  
✔ **Arguments are passed individually** in `call()` (unlike `apply()`, which requires an array).  
✔ **This method is useful for method borrowing** and allows objects to share methods without duplicating code.  

🚀 **Using `call()` efficiently** helps you write **more reusable, maintainable, and flexible** JavaScript code!"		
142	Function apply	The JavaScript apply() Method	"### **Using `apply()` in JavaScript**

The **`apply()`** method is a built-in JavaScript method that allows a function to be called with a **specific `this` value**. It is similar to `call()`, but with a key difference: `apply()` takes arguments **as an array**, while `call()` takes them as individual values.

---

## **📌 Example: Using `apply()` to Borrow a Method**
In this example, the `fullName()` method from the `person` object is used on `person1` using `apply()`.

```js
var person = {
    fullName: function() {
        return this.firstName + "" "" + this.lastName;
    }
};

var person1 = {
    firstName: ""Mary"",
    lastName: ""Doe""
};

// Using apply() to call fullName with person1 as this
console.log(person.fullName.apply(person1));  
// Output: ""Mary Doe""
```

### **Explanation**:
- `person` contains the method `fullName()`, which **uses `this`** to refer to an object's `firstName` and `lastName` properties.
- `person1` **does not have a `fullName()` method**, but we use `apply()` to **borrow** the method from `person`.
- `apply(person1)` sets `this` to `person1`, so inside `fullName()`, `this.firstName` refers to `""Mary""` and `this.lastName` refers to `""Doe""`, resulting in `""Mary Doe""`.

---

## **📌 Difference Between `call()` and `apply()`**
Both `call()` and `apply()` invoke a function with a specified `this` value, but they differ in **how arguments are passed**.

| Method | Syntax | Argument Passing |
|--------|--------|-----------------|
| `call()` | `func.call(thisArg, arg1, arg2, ...)` | Arguments are passed **individually** |
| `apply()` | `func.apply(thisArg, [arg1, arg2, ...])` | Arguments are passed as an **array** |

---

## **📌 When to Use `apply()` vs. `call()`**
- **Use `apply()`** when you already have arguments stored in an **array**.
- **Use `call()`** when you want to pass arguments **individually**.

### **Example with Additional Arguments**
If the function takes arguments, `apply()` passes them as an array.

```js
var person = {
    fullName: function(city, country) {
        return this.firstName + "" "" + this.lastName + "", "" + city + "", "" + country;
    }
};

var person1 = {
    firstName: ""John"",
    lastName: ""Doe""
};

// Using apply() to pass arguments as an array
console.log(person.fullName.apply(person1, [""Oslo"", ""Norway""]));  
// Output: ""John Doe, Oslo, Norway""
```

### **Using `call()` Instead**
If using `call()`, the arguments are passed separately.

```js
console.log(person.fullName.call(person1, ""Oslo"", ""Norway""));  
// Output: ""John Doe, Oslo, Norway""
```

---

### **📌 Key Takeaways**
✔ **`apply()` allows a function to be invoked with a specific `this` value.**  
✔ **Arguments in `apply()` must be passed as an array**, unlike `call()`, which takes individual arguments.  
✔ **Method borrowing**: `apply()` allows objects to use methods from other objects without duplicating code.  
✔ **Use `apply()` when arguments are in an array**, and **use `call()` when passing them separately**.

🚀 **Using `apply()` effectively** makes JavaScript code **more reusable and flexible**!"		
143	Function apply	The Difference Between call() and apply()	"### **Difference Between `call()` and `apply()` in JavaScript**

Both `call()` and `apply()` are methods in JavaScript that allow a function to be **invoked** with a specified `this` value. The key difference lies in how they handle additional arguments.

| Method | Syntax | How Arguments Are Passed |
|--------|--------|-------------------------|
| **`call()`** | `func.call(thisArg, arg1, arg2, arg3, ...)` | Arguments are passed **individually** |
| **`apply()`** | `func.apply(thisArg, [arg1, arg2, arg3, ...])` | Arguments are passed as an **array** |

---

## **📌 Example: Using `call()`**
With `call()`, you pass arguments **one by one**.

```js
var person = {
    fullName: function(city, country) {
        return this.firstName + "" "" + this.lastName + "", "" + city + "", "" + country;
    }
};

var person1 = {
    firstName: ""John"",
    lastName: ""Doe""
};

console.log(person.fullName.call(person1, ""Oslo"", ""Norway""));  
// Output: ""John Doe, Oslo, Norway""
```

### **Explanation**:
- `call(person1, ""Oslo"", ""Norway"")` invokes `fullName()` with `this` set to `person1` and passes `""Oslo""` and `""Norway""` **as separate arguments**.

---

## **📌 Example: Using `apply()`**
With `apply()`, you pass **arguments as an array**.

```js
console.log(person.fullName.apply(person1, [""Oslo"", ""Norway""]));  
// Output: ""John Doe, Oslo, Norway""
```

### **Explanation**:
- `apply(person1, [""Oslo"", ""Norway""])` invokes `fullName()` with `this` set to `person1` and passes `[""Oslo"", ""Norway""]` **as an array**.

---

## **📌 When to Use `apply()`**
The `apply()` method is useful when:
- You already have arguments stored in an **array**.
- You don’t want to manually extract individual values.

### **Example: Using `apply()` with `Math.max()`**
A practical use case of `apply()` is when you need to pass an array of numbers to a function that doesn’t normally accept an array.

```js
var numbers = [3, 8, 1, 6, 9];

var maxNumber = Math.max.apply(null, numbers);
console.log(maxNumber);  // Output: 9
```

### **Explanation**:
- `Math.max()` does not accept arrays, but it does accept multiple arguments.
- Using `apply(null, numbers)`, we **spread the array** into separate arguments.

---

## **📌 Key Takeaways**
✔ **`call()`** takes arguments separately, while **`apply()`** takes arguments as an **array**.  
✔ **Use `call()`** when passing arguments **one by one**.  
✔ **Use `apply()`** when you already have arguments stored in an **array**.  
✔ **`apply()` is useful for built-in functions like `Math.max()`**, where an array needs to be passed instead of individual arguments.

🚀 **Understanding `call()` and `apply()`** allows you to write **more flexible and reusable JavaScript code!**"		
144	Function apply	The apply() Method with Arguments	"### **Difference Between `apply()` and `call()` in JavaScript**

Both `apply()` and `call()` are **built-in JavaScript methods** that allow a function to be invoked with a specified `this` value. The key difference between them is **how arguments are passed**.

---

## **📌 Key Differences Between `apply()` and `call()`**
| Method | Syntax | How Arguments Are Passed |
|--------|--------|-------------------------|
| **`call()`** | `func.call(thisArg, arg1, arg2, ...)` | Arguments are passed **individually** |
| **`apply()`** | `func.apply(thisArg, [arg1, arg2, ...])` | Arguments are passed as an **array** |

---

## **📌 Example: Using `apply()`**
With `apply()`, arguments must be passed as an **array**.

```js
var person = {
    fullName: function(city, country) {
        return this.firstName + "" "" + this.lastName + "", "" + city + "", "" + country;
    }
};

var person1 = {
    firstName: ""John"",
    lastName: ""Doe""
};

console.log(person.fullName.apply(person1, [""Oslo"", ""Norway""]));  
// Output: ""John Doe, Oslo, Norway""
```

### **Explanation**:
- `apply(person1, [""Oslo"", ""Norway""])` invokes `fullName()` with `this` set to `person1` and passes `[""Oslo"", ""Norway""]` as an **array of arguments**.

---

## **📌 Example: Using `call()`**
With `call()`, arguments must be passed **individually**.

```js
console.log(person.fullName.call(person1, ""Oslo"", ""Norway""));  
// Output: ""John Doe, Oslo, Norway""
```

### **Explanation**:
- `call(person1, ""Oslo"", ""Norway"")` invokes `fullName()` with `this` set to `person1` and passes `""Oslo""` and `""Norway""` **separately**.

---

## **📌 When to Use `apply()`**
The `apply()` method is useful when:
1. You **already have arguments stored in an array**.
2. You **don’t want to manually extract individual values**.

### **Example: Using `apply()` with `Math.max()`**
A common use case of `apply()` is passing an array of numbers to `Math.max()`, which normally requires separate arguments.

```js
var numbers = [3, 8, 1, 6, 9];

var maxNumber = Math.max.apply(null, numbers);
console.log(maxNumber);  // Output: 9
```

### **Explanation**:
- `Math.max()` does **not** accept arrays, but it does accept multiple arguments.
- Using `apply(null, numbers)`, we **spread the array into individual arguments**.

---

## **📌 Summary: Choosing Between `call()` and `apply()`**
| Use Case | Use `call()` | Use `apply()` |
|----------|------------|------------|
| Arguments passed separately | ✅ Yes | ❌ No |
| Arguments stored in an array | ❌ No | ✅ Yes |
| Works with functions requiring multiple arguments | ✅ Yes | ✅ Yes |

---

### **📌 Key Takeaways**
✔ **`call()` takes arguments separately**, while **`apply()` takes arguments as an array**.  
✔ **Use `apply()` when arguments are already in an array** to avoid manually extracting values.  
✔ **Use `call()` when passing arguments individually** for simplicity.  
✔ **`apply()` is useful for built-in functions like `Math.max()`**, which expect individual arguments.

🚀 **Understanding `call()` and `apply()`** helps you write more flexible and efficient JavaScript code!"		
145	Function apply	JavaScript Strict Mode	"### **Effect of `apply()` First Argument in Strict Mode vs. Non-Strict Mode**

The **first argument** of the `apply()` method determines the `this` context when invoking a function. However, **its behavior changes depending on whether JavaScript is in strict mode (`""use strict""`) or non-strict mode**.

---

## **📌 How `apply()` Handles the First Argument**
- If the **first argument** of `apply()` is **an object**, that object becomes the **`this` context** for the function.
- If the **first argument** is `null` or `undefined`:
  - In **non-strict mode**, `this` defaults to the **global object** (`window` in browsers, `global` in Node.js).
  - In **strict mode**, `this` remains **`null` or `undefined`**, instead of defaulting to the global object.

---

## **📌 Example: `apply()` in Non-Strict Mode**
```js
function showThis() {
    console.log(this);
}

// Calling apply() with `null` in non-strict mode
showThis.apply(null);  
// Output in browsers: Window {...}
// Output in Node.js: global {...}
```

### **Explanation**:
- Since **non-strict mode** is active, `this` is automatically set to the **global object** (`window` in browsers or `global` in Node.js).
- `null` is ignored, and the function is executed as if it were invoked globally.

---

## **📌 Example: `apply()` in Strict Mode**
```js
""use strict"";

function showThis() {
    console.log(this);
}

// Calling apply() with `null` in strict mode
showThis.apply(null);  
// Output: null
```

### **Explanation**:
- In **strict mode**, JavaScript **does not default `this` to the global object**.
- Instead, `this` remains `null`, which prevents accidental modifications of the global object.

---

## **📌 Behavior When First Argument is a Non-Object (e.g., Primitive Values)**

If you pass a **primitive value** (string, number, boolean) as the first argument in **non-strict mode**, JavaScript **converts it into an object**.

### **Example: Primitive Values in Non-Strict Mode**
```js
function showThis() {
    console.log(this);
}

showThis.apply(""hello"");  
// Output: String {""hello""}
```

### **Explanation**:
- The string `""hello""` is **converted into a String object (`new String(""hello"")`)**.
- This happens because JavaScript **automatically wraps primitive values** in their corresponding object types.

### **Example: Primitive Values in Strict Mode**
```js
""use strict"";

function showThis() {
    console.log(this);
}

showThis.apply(""hello"");  
// Output: ""hello"" (Primitive, not an object)
```

### **Explanation**:
- In **strict mode**, `this` does **not** get converted into an object.
- The function still receives `""hello""`, but as a **primitive value**, not an object.

---

## **📌 Summary of `apply()` First Argument Behavior**
| First Argument | **Non-Strict Mode (`this`)** | **Strict Mode (`this`)** |
|---------------|---------------------------|---------------------------|
| `null` or `undefined` | Global Object (`window` in browsers) | `null` or `undefined` remains unchanged |
| Object `{}` | Object itself | Object itself |
| `""string""` | String object (`new String()`) | Primitive `""string""` |
| `123` (number) | Number object (`new Number()`) | Primitive `123` |
| `true` (boolean) | Boolean object (`new Boolean()`) | Primitive `true` |

---

### **📌 Key Takeaways**
✔ **In non-strict mode**, if `apply()` is called with `null` or `undefined`, `this` defaults to the **global object** (`window` in browsers).  
✔ **In strict mode**, if `apply()` is called with `null` or `undefined`, `this` remains `null` or `undefined` instead of defaulting to the global object.  
✔ **Primitive values (strings, numbers, booleans) are converted into their object counterparts** in non-strict mode, but remain primitives in strict mode.  
✔ **Always explicitly set `this` to an object** when using `apply()` to avoid unexpected behavior, especially in strict mode.  

🚀 **Understanding `apply()` behavior in strict and non-strict modes** helps you write safer, more predictable JavaScript code!"		
146	Function closures	Definition	"### **Understanding JavaScript Closures**

A **closure** in JavaScript is a function that **remembers the variables from its parent scope**, even after the parent function has finished executing. This allows for the creation of **private variables** that can only be modified by functions inside the closure.

---

## **📌 Example: Closure with a Counter**
```js
var add = (function () {
    var counter = 0;  // Private variable
    return function () {
        counter += 1;
        return counter;
    };
})();

console.log(add()); // Output: 1
console.log(add()); // Output: 2
console.log(add()); // Output: 3
```

### **Explanation**:
1. **Self-Invoking Function**: The outer function is **immediately invoked**, meaning it executes **once** when the script runs.
2. **Private Variable (`counter`)**:
   - The variable `counter` is defined inside the **outer function** but is **not accessible** outside.
   - This means that **no external code can directly modify `counter`**.
3. **Returning an Inner Function**:
   - The **inner function** (returned by the outer function) has access to `counter` due to **closure**.
   - Each time `add()` is called, the **inner function modifies `counter`** and returns the updated value.
4. **Preserved State**:
   - Even though the outer function has finished executing, `counter` **remains in memory** because the inner function still has access to it.

---

## **📌 Why Are Closures Useful?**
✔ **Data Encapsulation**: Closures allow variables to be **private**, preventing them from being accidentally modified by external code.  
✔ **Stateful Functions**: They help retain data across multiple function calls, even after the original function has executed.  
✔ **Avoiding Global Variables**: Closures help prevent **polluting the global scope**, making code **cleaner and safer**.  

---

## **📌 More Examples of Closures**

### **Example 1: A Function That Generates Counters**
Closures are useful when you need **multiple independent counters**.

```js
function createCounter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

let counter1 = createCounter();
let counter2 = createCounter();

console.log(counter1()); // Output: 1
console.log(counter1()); // Output: 2
console.log(counter2()); // Output: 1 (separate counter)
console.log(counter2()); // Output: 2
```

### **Explanation**:
- `createCounter()` returns a **new function** each time it is called.
- Each returned function **remembers its own `count` variable**, so `counter1` and `counter2` have **independent states**.

---

### **Example 2: Creating a Function with Private Data**
Closures can be used to **protect data** from being accessed or modified outside of the function.

```js
function bankAccount(initialBalance) {
    let balance = initialBalance;  // Private variable

    return {
        deposit: function(amount) {
            balance += amount;
            return `Deposited ${amount}, new balance: ${balance}`;
        },
        withdraw: function(amount) {
            if (amount &gt; balance) {
                return ""Insufficient funds!"";
            }
            balance -= amount;
            return `Withdrew ${amount}, new balance: ${balance}`;
        },
        getBalance: function() {
            return `Balance: ${balance}`;
        }
    };
}

let myAccount = bankAccount(100);
console.log(myAccount.getBalance());  // Output: ""Balance: 100""
console.log(myAccount.deposit(50));   // Output: ""Deposited 50, new balance: 150""
console.log(myAccount.withdraw(30));  // Output: ""Withdrew 30, new balance: 120""
console.log(myAccount.getBalance());  // Output: ""Balance: 120""
```

### **Explanation**:
- The `balance` variable is **private** because it is inside the closure.
- The object returned by `bankAccount()` provides **controlled access** to `balance` through **methods (`deposit`, `withdraw`, `getBalance`)**.
- The balance **cannot be accessed or modified directly** from outside the function.

---

## **📌 Key Takeaways**
✔ **A closure is a function that retains access to variables from its parent scope, even after the parent function has finished executing.**  
✔ **Closures are useful for creating private variables**, preserving state, and preventing unintended modifications.  
✔ **Self-invoking functions** are commonly used to create closures that execute once and **store private data**.  
✔ **Closures help avoid global variables**, making JavaScript code **more modular, reusable, and secure**.  

🚀 **Mastering closures** allows you to write **cleaner, safer, and more efficient** JavaScript code!"		
147	Function closures	Closure concept from other website	"### **Higher-Order Functions and Closures in JavaScript**

A **higher-order function** is a function that either:
- **Takes another function as an argument** or
- **Returns another function**.

Closures form the foundation of **higher-order functions** because they allow inner functions to **remember** variables from their parent scope, even after the parent function has finished executing.

---

## **📌 Example: Function Returning Another Function**
```js
function getGreeter() {
    return function() {
        return 'Hi, Jerome!';
    };
}

// Calling the function once returns another function
console.log(getGreeter());  // Output: [Function (anonymous)]

// Calling it twice invokes the inner function
console.log(getGreeter()());  // Output: ""Hi, Jerome!""
```

### **Explanation**:
1. **First Call**: `getGreeter()` **returns a function** but does not execute it.
2. **Second Call**: `getGreeter()()` **executes the returned function**, which returns `""Hi, Jerome!""`.

---

## **📌 Storing the Returned Function in a Variable**
Instead of calling `getGreeter()` twice, we can **store the returned function in a variable** for easier reuse.

```js
const greetJerome = getGreeter();

console.log(greetJerome());  // Output: ""Hi, Jerome!""
console.log(greetJerome());  // Output: ""Hi, Jerome!""
```

### **Explanation**:
- `greetJerome` now **holds the returned function**.
- Calling `greetJerome()` executes the function and **remembers** the value inside `getGreeter()`.

---

## **📌 Making `getGreeter` Dynamic**
Currently, `getGreeter` **only greets Jerome**. Let's modify it to **accept a `name` parameter** so that we can greet anyone.

```js
function getGreeter(name) {
    return function() {
        return `Hi, ${name}!`;
    };
}

const greetJerome = getGreeter('Jerome');
const greetYazeed = getGreeter('Yazeed');

console.log(greetJerome());  // Output: ""Hi, Jerome!""
console.log(greetYazeed());  // Output: ""Hi, Yazeed!""
```

### **Explanation**:
- The **outer function (`getGreeter`) takes `name` as a parameter** and **returns an inner function**.
- The **inner function** still **has access to `name`**, even after `getGreeter` has finished executing.
- `greetJerome` and `greetYazeed` are now **individual functions** that keep their own memory of `name`.

---

## **📌 How Closures Work in This Example**
1. **When `getGreeter(""Jerome"")` is called**:
   - `name = ""Jerome""` is stored in the outer function.
   - The **inner function is returned**, but `name` is still accessible.
   
2. **When `greetJerome()` is called**:
   - The inner function still **remembers `name`**, even though `getGreeter()` has already completed execution.
   - This is because JavaScript **preserves variables inside closures**.

---

## **📌 More Examples of Closures**

### **Example 1: Counter with Closures**
Closures are commonly used to **store state in a function** without exposing the variable.

```js
function createCounter() {
    let count = 0;  // Private variable

    return function() {
        count++;
        return count;
    };
}

const counter1 = createCounter();
console.log(counter1());  // Output: 1
console.log(counter1());  // Output: 2
console.log(counter1());  // Output: 3

const counter2 = createCounter();
console.log(counter2());  // Output: 1 (separate counter)
```

### **Explanation**:
- Each time `createCounter()` is called, a **new closure is created**, preserving a separate `count` variable.
- `counter1` and `counter2` are **independent** because they were created from separate function calls.

---

### **Example 2: Customizable Greeting Function**
```js
function createGreeting(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

const sayHello = createGreeting(""Hello"");
const sayGoodbye = createGreeting(""Goodbye"");

console.log(sayHello(""Alice""));  // Output: ""Hello, Alice!""
console.log(sayGoodbye(""Bob""));  // Output: ""Goodbye, Bob!""
```

### **Explanation**:
- The **outer function (`createGreeting`) sets the greeting**.
- The **inner function remembers `greeting`** and allows us to reuse different greetings dynamically.

---

### **📌 Key Takeaways**
✔ **Functions that return functions** are called **higher-order functions**.  
✔ **Closures allow inner functions to access variables from the parent scope**, even after the parent function has finished executing.  
✔ **Closures help create private variables** that are protected from modification outside the function.  
✔ **They are useful for state management**, like **counters, function factories, and event handlers**.  

🚀 **Mastering closures** helps you write **efficient, reusable, and modular JavaScript code**!"		
148	Function closures	Currying	"### **Currying in JavaScript: Breaking Down Function Arguments**

**Currying** is a functional programming technique where a function is **transformed** into a sequence of functions, each taking a **single argument** at a time. This approach allows **partial application of functions**, making them more reusable and composable.

---

## **📌 Example: Regular Function vs. Curried Function**

### **Regular Function (Takes All Arguments at Once)**
```js
const add = function(x, y) {
    return x + y;
};

console.log(add(2, 4)); // Output: 6
```
- This function takes **both arguments** (`x` and `y`) at the same time.

---

## **📌 Transforming `add(x, y)` Into a Curried Function**
### **Curried Version of `add`**
```js
const add = function(x) {
    return function(y) {
        return x + y;
    };
};
```
- The function **no longer takes both arguments at once**.
- Instead, the first function **returns another function**, which takes `y` as its argument.

### **Using the Curried `add` Function**
```js
console.log(add(2)(4)); // Output: 6
```
- The first call `add(2)` returns a **new function** waiting for `y`.
- Calling `add(2)(4)` fully evaluates to `2 + 4 = 6`.

---

## **📌 Using Currying for Preloading Arguments**
Currying allows you to **""preload""** arguments, creating reusable functions with predefined values.

### **Example: Creating a Preloaded `add10` Function**
```js
const add10 = add(10); // Preloads `x` with 10

console.log(add10(10)); // Output: 20
console.log(add10(20)); // Output: 30
console.log(add10(30)); // Output: 40
```
- `add10` is a **function that always adds 10** to any argument passed to it.
- This is possible because the **inner function retains access** to `x` through **closures**.

---

## **📌 Benefits of Currying**
✔ **Modular &amp; Reusable**: Preloading arguments makes functions more reusable.  
✔ **Function Composition**: Currying allows functions to be combined easily.  
✔ **Improved Readability**: Creates **self-explanatory** functions like `add10(10)` instead of `add(10, 10)`.  
✔ **Only Possible Through Closures**: The **inner function retains access** to `x` even after the outer function has executed.

---

## **📌 Advanced Example: Auto-Currying with Arrow Functions**
Using **arrow functions**, we can make a more compact **curried version** of `add`:

```js
const add = x =&gt; y =&gt; x + y;

console.log(add(5)(3));  // Output: 8
```
- This syntax removes `return` and `{}` by **implicitly returning the inner function**.

---

## **📌 Example: Currying with More Arguments**
You can extend currying for functions with **more than two arguments**.

### **Example: Curried Function with Three Arguments**
```js
const multiply = x =&gt; y =&gt; z =&gt; x * y * z;

console.log(multiply(2)(3)(4)); // Output: 24
```
- `multiply(2)` returns a function waiting for `y`.
- `multiply(2)(3)` returns a function waiting for `z`.
- `multiply(2)(3)(4)` finally evaluates to `2 * 3 * 4 = 24`.

---

### **📌 Key Takeaways**
✔ **Currying transforms a function** so that it takes arguments **one at a time**.  
✔ **It enables partial application**, allowing preloading of function arguments for better reusability.  
✔ **Closures make currying possible**, as the inner function retains access to the first argument.  
✔ **Arrow functions** make currying even more concise.  
✔ **Great for functional programming**, especially for composing and reusing functions.  

🚀 **Mastering currying** helps you write **more modular, flexible, and reusable** JavaScript functions!"		
149	Function closures	Summary	"### **JavaScript Closures &amp; Stateful Functions - Summary**

✔ **Functions are values**:  
   - In JavaScript, functions can be **assigned to variables, passed as arguments, and returned from other functions**.

✔ **Functions can return other functions**:  
   - This is a core concept of **higher-order functions**.
   - A function that returns another function allows **partial application, currying, and encapsulation**.

✔ **Outer function's variables remain accessible**:  
   - Even after the **outer function has finished execution**, the **inner function retains access** to its variables.  
   - This is possible due to **closures**, which **preserve the lexical scope**.

✔ **Closures maintain state**:  
   - Variables inside the outer function act as **persistent private data** for the inner function.  
   - These variables are known as **state**, making closures useful for **counters, configuration functions, and private variables**.

✔ **Closures are also called stateful functions**:  
   - Since closures allow functions to ""remember"" values from their parent scope, they enable **stateful programming**.

---

### **📌 Example: Closure as a Stateful Function**
```js
function createCounter() {
    let count = 0;  // Private variable (state)
    return function() {
        count++;  
        return count;
    };
}

const counter = createCounter();
console.log(counter());  // Output: 1
console.log(counter());  // Output: 2
console.log(counter());  // Output: 3
```
- The **inner function retains access** to `count`, even after `createCounter()` has finished execution.
- The state (`count`) **persists** between function calls.

---

### **📌 Key Takeaways**
✔ **Functions can be treated as values** in JavaScript.  
✔ **Closures preserve state** even after their parent function has executed.  
✔ **Closures enable encapsulation** by creating **private variables** inside functions.  
✔ **Stateful functions** remember their state and can be used for **counters, event handlers, and memoization**.

🚀 **Closures are one of the most powerful concepts in JavaScript**, enabling **modularity, data privacy, and state management** in functional programming!"		
150	DOM intro	What is the HTML DOM?	"### **Understanding the HTML DOM (Document Object Model)**

The **HTML DOM (Document Object Model)** is a **standardized interface** that allows JavaScript to **interact with and manipulate** HTML elements. It represents the structure of an HTML document as a **tree of objects**, where each element, attribute, and text node is an object that can be accessed and modified.

---

## **📌 The HTML DOM Defines**
1. **HTML elements as objects** → Every HTML tag becomes an object in JavaScript.
2. **Properties of elements** → Elements have properties that define their attributes (e.g., `innerHTML`, `id`, `className`).
3. **Methods to manipulate elements** → JavaScript can use methods like `getElementById()`, `createElement()`, or `appendChild()` to modify HTML elements.
4. **Events for user interactions** → Events like `onclick`, `onchange`, or `onmouseover` allow interactivity.

---

## **📌 Example: Accessing and Modifying an HTML Element**
```html




<p id=""demo"">Hello, World!</p>
<button onclick=""changeText()"">Click Me</button>





```
### **Explanation**:
- `document.getElementById(""demo"")` → Selects the `<p>` element with `id=""demo""`.
- `.innerHTML = ""Hello, JavaScript!""` → Modifies the content of the element.
- When the button is clicked, `changeText()` executes, **modifying the HTML dynamically**.

---

## **📌 Common HTML DOM Methods**
| Method | Description |
|--------|-------------|
| `getElementById(id)` | Selects an element by its `id`. |
| `getElementsByClassName(class)` | Selects all elements with a specific class name. |
| `getElementsByTagName(tag)` | Selects all elements with a specific tag (e.g., `p`, `div`). |
| `querySelector(cssSelector)` | Selects the **first matching** element using CSS selectors. |
| `querySelectorAll(cssSelector)` | Selects **all matching** elements using CSS selectors. |
| `createElement(tagName)` | Creates a new HTML element. |
| `appendChild(node)` | Adds an element as a child of another element. |
| `removeChild(node)` | Removes an element from its parent. |

---

## **📌 Example: Adding a New Element**
```html




</p><ul id=""myList"">
  <li>Item 1</li>
  <li>Item 2</li>
</ul>

<button onclick=""addItem()"">Add Item</button>





```
### **Explanation**:
- `document.createElement(""li"")` → Creates a new `<li>` element.
- `innerHTML = ""New Item""` → Sets its content.
- `appendChild(newItem)` → Adds it to the `<ul>` list.

---

## **📌 Handling Events with the DOM**
JavaScript can listen for **user interactions** (events) such as clicks, key presses, and form submissions.

### **Example: Changing Text on Click**
```html
<button id=""btn"">Click Me</button>
<p id=""text"">Original Text</p>


```
### **Explanation**:
- `.addEventListener(""click"", function() {...})` → Listens for clicks on the button.
- The event modifies the paragraph's content when clicked.

---

## **📌 Summary of the HTML DOM**
✔ The **HTML DOM** allows JavaScript to **access, modify, and manipulate** HTML elements dynamically.  
✔ The DOM represents **HTML elements as objects**, with **properties, methods, and events**.  
✔ The `document` object provides powerful **methods** like `getElementById()`, `createElement()`, and `querySelector()`.  
✔ The DOM enables **event handling**, making web pages interactive and responsive.  

🚀 **Mastering the DOM** is essential for **building dynamic, interactive web applications!**</ul></li>"		
151	DOM methods	The DOM Programming Interface	"### **JavaScript and the HTML DOM: Properties &amp; Methods**

The **HTML DOM (Document Object Model)** allows JavaScript to interact with and manipulate HTML elements dynamically. The DOM provides **properties** and **methods** for each HTML element, enabling developers to access, modify, and control web pages programmatically.

---

## **📌 Difference Between DOM Methods and Properties**

| Feature | Description | Example |
|---------|------------|---------|
| **Methods** | Actions you can perform on HTML elements. | `element.appendChild(newElement)` (Adds an element) |
| **Properties** | Values that you can get or set. | `element.innerHTML` (Modifies content) |

---

## **📌 Common HTML DOM Properties**
DOM **properties** allow you to **get or set** values for HTML elements.

| Property | Description | Example |
|----------|-------------|---------|
| `innerHTML` | Gets or sets the HTML content inside an element. | `element.innerHTML = ""New content"";` |
| `textContent` | Gets or sets only the text inside an element (ignores HTML tags). | `element.textContent = ""Plain text"";` |
| `value` | Gets or sets the value of an input field. | `inputElement.value = ""Hello"";` |
| `src` | Gets or sets the `src` of an image. | `imgElement.src = ""image.jpg"";` |
| `id` | Gets or sets the `id` attribute of an element. | `element.id = ""newID"";` |
| `className` | Gets or sets the class attribute. | `element.className = ""highlight"";` |
| `style` | Gets or sets inline CSS styles. | `element.style.color = ""red"";` |

### **Example: Changing an Element's Content**
```html
<p id=""demo"">Original text</p>
<button onclick=""changeText()"">Change Text</button>


```
- Clicking the button updates the `<p>` content using `innerHTML`.

---

## **📌 Common HTML DOM Methods**
DOM **methods** allow you to **perform actions** on HTML elements.

| Method | Description | Example |
|--------|-------------|---------|
| `getElementById(id)` | Selects an element by its ID. | `document.getElementById(""demo"");` |
| `getElementsByClassName(class)` | Selects elements by class name. | `document.getElementsByClassName(""item"");` |
| `getElementsByTagName(tag)` | Selects elements by tag name. | `document.getElementsByTagName(""p"");` |
| `querySelector(cssSelector)` | Selects the **first matching** element. | `document.querySelector("".btn"");` |
| `querySelectorAll(cssSelector)` | Selects **all matching** elements. | `document.querySelectorAll("".btn"");` |
| `createElement(tag)` | Creates a new HTML element. | `document.createElement(""div"");` |
| `appendChild(node)` | Appends an element as a child. | `parentElement.appendChild(newElement);` |
| `removeChild(node)` | Removes a child element. | `parentElement.removeChild(childElement);` |
| `setAttribute(name, value)` | Sets an attribute. | `element.setAttribute(""class"", ""highlight"");` |

---

## **📌 Example: Adding &amp; Removing Elements**
### **Adding an Element**
```html
</p><ul id=""myList"">
  <li>Item 1</li>
  <li>Item 2</li>
</ul>
<button onclick=""addItem()"">Add Item</button>


```
- Clicking the button **creates a new `<li>`** and adds it to the `<ul>`.

### **Removing an Element**
```js
function removeItem() {
    var list = document.getElementById(""myList"");
    list.removeChild(list.lastElementChild); // Removes the last <li>
}
```

---

## **📌 Summary of DOM Manipulation**
✔ **Properties** allow you to **get and set values** for HTML elements (`innerHTML`, `style`, `value`).  
✔ **Methods** perform **actions** on elements (`appendChild()`, `removeChild()`, `createElement()`).  
✔ The **DOM allows JavaScript to dynamically update HTML pages**.  

🚀 **Mastering DOM properties and methods** lets you build **interactive, dynamic web applications!**</li></ul></li>"		
152	DOM methods	The getElementById Method	"### **Accessing HTML Elements by ID in JavaScript**

The **most common way** to access an HTML element in JavaScript is by using its **`id` attribute**. This is done using the **`document.getElementById()`** method.

---

## **📌 `getElementById()` Method**
The **`getElementById(id)`** method selects the **first HTML element** with the specified `id`.

### **Syntax:**
```js
document.getElementById(""elementID"");
```
- **Returns:** The HTML element with the given `id`.
- **If the `id` does not exist**, it returns `null`.

---

## **📌 Example: Changing Text Content**
```html




<p id=""demo"">Original Text</p>
<button onclick=""changeText()"">Click Me</button>





```

### **Explanation**:
- `getElementById(""demo"")` selects the `<p>` element with `id=""demo""`.
- `.innerHTML = ""New Text!""` changes the text inside the element.
- Clicking the button triggers `changeText()`, modifying the paragraph's content.

---

## **📌 Example: Changing an Element's Style**
```html




</p><p id=""text"">Hello, World!</p>
<button onclick=""changeColor()"">Change Color</button>





```
- `.style.color = ""red""` updates the text color dynamically.

---

## **📌 Best Practices for `getElementById()`**
✔ **Use unique `id` values** → IDs must be unique in a document.  
✔ **Ensure the element exists** → If the `id` is incorrect, `getElementById()` returns `null`, which can cause errors.  
✔ **Use `querySelector()` for more flexibility** → If selecting multiple elements or by class, use `document.querySelector()`.  

---

### **📌 Summary**
✔ **`getElementById()` is the easiest way to access an HTML element using its `id`**.  
✔ It allows you to **read or modify an element’s content, attributes, and styles**.  
✔ **Ensure the `id` exists** to avoid `null` errors.  

🚀 **Using `getElementById()` efficiently** makes JavaScript interactions with HTML **faster and more dynamic**!"		
153	DOM methods	The innerHTML Property	"### **Using the `innerHTML` Property in JavaScript**

The **`innerHTML` property** is the easiest way to **get or modify the content** of an HTML element. It allows JavaScript to dynamically update the text or HTML inside an element.

---

## **📌 What is `innerHTML`?**
- **`innerHTML` gets the content inside an element** (including any child elements).
- **`innerHTML` sets new content**, replacing everything inside the selected element.

### **Syntax**
```js
element.innerHTML;  // Get content
element.innerHTML = ""New Content"";  // Set new content
```

---

## **📌 Example: Getting and Modifying Content**
### **Example 1: Changing an Element's Content**
```html




<p id=""demo"">Hello, World!</p>
<button onclick=""changeText()"">Click Me</button>





```

### **Explanation**:
1. `getElementById(""demo"")` selects the `<p>` element.
2. `.innerHTML = ""Hello, JavaScript!""` **replaces** its content.
3. Clicking the button updates the paragraph dynamically.

---

## **📌 Example 2: Getting Content from an Element**
```html
</p><p id=""info"">This is some text.</p>
<button onclick=""showContent()"">Get Content</button>


```
- Clicking the button **alerts** the current content of the `<p>` element.

---

## **📌 `innerHTML` Works on Any HTML Element**
`innerHTML` can modify any HTML element, including ``, `</p><div>`, `<span>`, and even ``.

### **Example: Modifying `` Using `innerHTML`**
```html
<button onclick=""changeBody()"">Change Body</button>


```
- Clicking the button **replaces everything** inside `` with `<h1>New Page Content</h1>`.

---

## **📌 When to Avoid `innerHTML`**
While `innerHTML` is powerful, it **should not** be used for:
✔ **Handling user input directly** → It can lead to **security risks** like XSS (Cross-Site Scripting).  
✔ **Modifying large parts of the DOM frequently** → It replaces all content inside an element, which can affect performance.  

🔹 **Alternative for Text Content**: Use **`textContent`** to prevent executing HTML inside the string.
```js
element.textContent = ""Plain text only!"";
```

---

## **📌 Summary**
✔ **`innerHTML` is the easiest way to get and modify an element’s content**.  
✔ It **works on all elements**, including `` and ``.  
✔ **Use `textContent`** instead of `innerHTML` when working with text-only updates for **better security**.  

🚀 **Mastering `innerHTML` helps you dynamically update web pages easily!**</span></div>"		
154	DOM document	Definition	"### **The `document` Object in JavaScript (HTML DOM)**

The **`document` object** is the **root of the HTML DOM**. It represents the **entire web page** and provides methods and properties to **access, modify, and manipulate** all elements in an HTML document.

---

## **📌 Why is `document` Important?**
- It is **the starting point** for accessing and modifying HTML elements.
- It **represents the entire web page** and serves as the **owner** of all other elements.
- All DOM methods like `getElementById()`, `querySelector()`, and `createElement()` are called **on the `document` object**.

---

## **📌 Accessing Elements with `document`**
### **Example: Selecting an Element by ID**
```html
<p id=""demo"">Hello, World!</p>
<button onclick=""changeText()"">Click Me</button>


```

### **Explanation**:
- `document.getElementById(""demo"")` selects the `<p>` element.
- `.innerHTML = ""Hello, JavaScript!""` updates its content dynamically.

---

## **📌 Common Methods of the `document` Object**
| Method | Description |
|--------|-------------|
| `getElementById(id)` | Selects an element by its ID. |
| `getElementsByClassName(class)` | Selects all elements with a specific class name. |
| `getElementsByTagName(tag)` | Selects all elements with a specific tag (e.g., `p`, `div`). |
| `querySelector(cssSelector)` | Selects the **first matching** element using CSS selectors. |
| `querySelectorAll(cssSelector)` | Selects **all matching** elements using CSS selectors. |
| `createElement(tagName)` | Creates a new HTML element. |
| `appendChild(node)` | Adds an element as a child of another element. |
| `removeChild(node)` | Removes a child element. |

---

## **📌 Example: Changing Background Color**
```html
<button onclick=""changeBackground()"">Change Background</button>


```
- `document.body.style.backgroundColor = ""lightblue"";` modifies the **entire page’s background**.

---

## **📌 Example: Adding a New Element**
```html
</p><ul id=""myList"">
  <li>Item 1</li>
  <li>Item 2</li>
</ul>
<button onclick=""addItem()"">Add Item</button>


```
- This **creates and appends** a new `<li>` to the list when the button is clicked.

---

## **📌 Summary**
✔ **The `document` object is the root of the HTML DOM** and gives access to all elements on the page.  
✔ **You must start with `document`** when selecting or modifying elements.  
✔ **Common methods** like `getElementById()` and `querySelector()` allow easy element access.  
✔ **You can dynamically modify content**, styles, or even create new elements using `document`.  

🚀 **Understanding the `document` object is essential** for creating dynamic and interactive web pages!</li>"		
155	DOM document	Finding HTML Elements	"### **Common `document` Methods for Accessing HTML Elements in JavaScript**

The **`document` object** provides several methods to **select and manipulate** elements in an HTML document. Below are three commonly used methods:

---

## **📌 `document.getElementById(id)`**
- **Finds an element by its `id`.**
- **Returns a single element** because `id` values must be unique.

### **Example: Selecting an Element by `id`**
```html
<p id=""demo"">Hello, World!</p>
<button onclick=""changeText()"">Click Me</button>


```
✔ `document.getElementById(""demo"")` selects the **`<p>` element** and updates its content.

---

## **📌 `document.getElementsByTagName(name)`**
- **Finds elements by tag name** (e.g., `p`, `div`, `span`).
- **Returns a collection (HTMLCollection)**, similar to an array.

### **Example: Selecting Elements by Tag Name**
```html
</p><p>Hello!</p>
<p>How are you?</p>
<button onclick=""changeParagraphs()"">Click Me</button>


```
✔ **Loops through all `<p>` elements** and changes their color to red.

---

## **📌 `document.getElementsByClassName(name)`**
- **Finds elements by class name**.
- **Returns a collection (HTMLCollection)**.

### **Example: Selecting Elements by Class Name**
```html
</p><p class=""message"">Message 1</p>
<p class=""message"">Message 2</p>
<button onclick=""highlightMessages()"">Click Me</button>


```
✔ **All elements with class `""message""`** will have a yellow background.

---

## **📌 Summary**
| Method | Description | Returns |
|--------|-------------|---------|
| `document.getElementById(id)` | Selects an element by its `id`. | A **single element**. |
| `document.getElementsByTagName(tagName)` | Selects elements by tag name (e.g., `""p""`, `""div""`). | An **HTMLCollection** (like an array). |
| `document.getElementsByClassName(className)` | Selects elements by class name. | An **HTMLCollection**. |

🚀 **Using these methods efficiently helps in dynamically modifying HTML elements!**"		
156	DOM document	Changing HTML Elements	"### **JavaScript DOM Properties and Methods for Modifying HTML Elements**

In JavaScript, the **DOM (Document Object Model)** provides **properties and methods** to dynamically **modify content, attributes, and styles** of HTML elements.

---

## **📌 DOM Properties**
DOM **properties** allow you to **get or set values** of HTML elements.

| **Property** | **Description** |
|-------------|----------------|
| `element.innerHTML = ""New content"";` | Changes the **HTML content** inside an element. |
| `element.attribute = ""new value"";` | Changes an **attribute value** of an element (e.g., `src`, `href`, `id`). |
| `element.style.property = ""new style"";` | Changes an element's **CSS style** dynamically. |

### **Example: Modifying Content, Attributes, and Styles**
```html




<img id=""myImage"" src=""image1.jpg"" width=""200"">
<p id=""demo"">This is a paragraph.</p>
<button onclick=""modifyElement()"">Click Me</button>





```
### **Explanation**:
✔ `innerHTML` **modifies** the text inside the `<p>` tag.  
✔ `.src = ""image2.jpg""` **changes** the image source.  
✔ `.style.color = ""red""` **updates** the text color.

---

## **📌 DOM Methods**
DOM **methods** perform actions on elements.

| **Method** | **Description** |
|------------|----------------|
| `element.setAttribute(attribute, value);` | Changes the **attribute value** of an HTML element. |

### **Example: Using `setAttribute()` to Modify Attributes**
```html
<button id=""myButton"" onclick=""changeButton()"">Click Me</button>


```
### **Explanation**:
✔ `setAttribute(""disabled"", ""true"")` **disables** the button.  
✔ `.innerHTML = ""Updated!""` **updates the button text**.  
✔ `.style.backgroundColor = ""blue""` **changes the button color**.

---

## **📌 Summary**
| **Feature** | **Usage** | **Example** |
|------------|----------|-------------|
| **Modify Content** | `element.innerHTML = ""New content"";` | `document.getElementById(""demo"").innerHTML = ""Hello!"";` |
| **Modify Attributes** | `element.attribute = ""new value"";` | `document.getElementById(""img"").src = ""new.jpg"";` |
| **Modify Style** | `element.style.property = ""new style"";` | `document.getElementById(""demo"").style.color = ""blue"";` |
| **Set Attributes** | `element.setAttribute(""attribute"", ""value"");` | `element.setAttribute(""class"", ""highlight"");` |

🚀 **Using these DOM properties and methods makes web pages dynamic and interactive!**</p>"		
157	DOM document	Adding and Deleting Elements	"### **JavaScript DOM Methods for Creating, Modifying, and Removing Elements**

The **Document Object Model (DOM)** provides methods to **dynamically create, add, modify, or remove** HTML elements using JavaScript.

---

## **📌 Common DOM Methods for Element Manipulation**

| **Method** | **Description** |
|------------|----------------|
| `document.createElement(element)` | Creates a new **HTML element**. |
| `document.removeChild(element)` | Removes an existing **child element** from its parent. |
| `document.appendChild(element)` | Adds a **new element** as a child of an existing element. |
| `document.replaceChild(newElement, oldElement)` | Replaces an **existing element** with a **new element**. |
| `document.write(text)` | Writes **directly into the HTML document** (Not recommended). |

---

## **📌 Example 1: Creating and Adding an Element (`createElement` + `appendChild`)**
```html




<button onclick=""addElement()"">Add New Paragraph</button>
<div id=""container""></div>





```
### **Explanation**:
✔ `document.createElement(""p"")` → Creates a **new paragraph (`<p>`)** element.  
✔ `newPara.innerHTML = ""Text""` → Sets the text inside the new element.  
✔ `appendChild(newPara)` → Adds the new `</p><p>` element inside `#container`.

---

## **📌 Example 2: Removing an Element (`removeChild`)**
```html
</p><ul id=""myList"">
  <li>Item 1</li>
  <li id=""removeMe"">Item 2 (Click to Remove)</li>
  <li>Item 3</li>
</ul>


```
### **Explanation**:
✔ `this.parentNode.removeChild(this)` → Removes **Item 2** when clicked.

---

## **📌 Example 3: Replacing an Element (`replaceChild`)**
```html
<ul id=""list"">
  <li id=""oldItem"">Old Item</li>
</ul>
<button onclick=""replaceItem()"">Replace Item</button>


```
### **Explanation**:
✔ `createElement(""li"")` → Creates a new list item.  
✔ `replaceChild(newItem, oldItem)` → Replaces **""Old Item""** with **""New Item""**.

---

## **📌 Example 4: Writing Directly to the Document (`document.write`)**
```html
<button onclick=""writeText()"">Write to Document</button>


```
### **⚠️ Warning**:
- **`document.write()` replaces the entire page** if used **after the page loads**.
- It is **not recommended** for modern JavaScript applications.

---

## **📌 Summary**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| `createElement(""tag"")` | Creates a new element. | `document.createElement(""p"");` |
| `appendChild(node)` | Adds an element inside another. | `parent.appendChild(child);` |
| `removeChild(node)` | Removes an element. | `parent.removeChild(child);` |
| `replaceChild(new, old)` | Replaces an existing element. | `parent.replaceChild(newElement, oldElement);` |
| `document.write(""text"")` | Writes directly to the document. ⚠️ Not recommended. | `document.write(""Hello!"");` |

🚀 **Mastering these methods** allows you to dynamically **create, modify, and remove elements**, making your web pages interactive and dynamic!"		
158	DOM document	Adding Events Handlers	"### **Adding an `onclick` Event Handler in JavaScript Using `document.getElementById()`**

The **`onclick` event** in JavaScript is used to execute code when an element is clicked. You can attach an event handler dynamically using `document.getElementById(id).onclick`.

---

## **📌 Syntax**
```js
document.getElementById(""elementID"").onclick = function() {
    // Code to execute when the element is clicked
};
```
- `getElementById(""elementID"")` → Selects the element with the given `id`.
- `.onclick = function() {}` → Assigns an **anonymous function** to handle the click event.

---

## **📌 Example: Changing Text When Button is Clicked**
```html




<p id=""text"">Click the button to change this text.</p>
<button id=""myButton"">Click Me</button>





```
### **Explanation**:
✔ `document.getElementById(""myButton"")` → Selects the button.  
✔ `.onclick = function() {}` → Attaches a click event to the button.  
✔ `document.getElementById(""text"").innerHTML = ""Text changed!"";` → Modifies the paragraph content on click.

---

## **📌 Example: Changing Background Color on Click**
```html
<button id=""changeColor"">Change Background</button>


```
✔ Clicking the button **changes the background color** of the page.

---

## **📌 Alternative: Using `addEventListener()` (Recommended)**
While `onclick` works fine, a better practice is to use **`addEventListener()`**, which allows multiple event listeners for the same event.

```js
document.getElementById(""myButton"").addEventListener(""click"", function() {
    document.getElementById(""text"").innerHTML = ""Text changed!"";
});
```
✔ `addEventListener(""click"", function)` is **more flexible** than `.onclick`, as it allows multiple event listeners.

---

## **📌 Summary**
| **Method** | **Description** |
|------------|----------------|
| `element.onclick = function() {}` | Attaches a click event handler to an element. |
| `element.addEventListener(""click"", function() {})` | Recommended way to add click events (supports multiple listeners). |

🚀 **Using JavaScript events dynamically makes web pages interactive and engaging!**"		
159	DOM document	Finding HTML Objects	"### **HTML DOM Properties Overview (Level 1 &amp; Level 3)**

The **HTML DOM (Document Object Model)** provides properties and methods to access and manipulate web pages. The **DOM Levels** indicate the evolution of these properties, with **DOM Level 1 (1998)** introducing the core objects and **DOM Level 3** adding more functionalities.

---

## **📌 Important HTML DOM Properties**
Below is a categorized summary of key **DOM Level 1 and Level 3** properties.

### **📌 DOM Level 1 Properties (Introduced in 1998)**
| Property | Description |
|----------|-------------|
| `document.anchors` | Returns all `<a>` elements **with a `name` attribute**. |
| `document.applets` | Returns all `<applet>` elements (**Deprecated in HTML5**). |
| `document.body` | Returns the `` element of the document. |
| `document.cookie` | Returns the document's **cookies**. |
| `document.domain` | Returns the **domain name** of the web page. |
| `document.forms` | Returns a **collection of all `<form>` elements** in the document. |
| `document.images` | Returns a **collection of all `<img>` elements**. |
| `document.links` | Returns all `<a>` and `<area>` elements **that have an `href` attribute**. |
| `document.referrer` | Returns the **URL of the referrer** (the previous page that linked to the document). |
| `document.title` | Returns the document’s `<title>` tag. |
| `document.URL` | Returns the **full URL** of the document. |

---

### **📌 DOM Level 3 Properties (Enhancements in Later Versions)**
| Property | Description |
|----------|-------------|
| `document.baseURI` | Returns the **absolute base URI** of the document. |
| `document.doctype` | Returns the **document's DOCTYPE**. |
| `document.documentElement` | Returns the `&lt;html&gt;` element. |
| `document.documentMode` | Returns the **browser rendering mode** (quirks or standards mode). |
| `document.documentURI` | Returns the **URI of the document**. |
| `document.embeds` | Returns a **collection of all `&lt;embed&gt;` elements**. |
| `document.head` | Returns the `&lt;head&gt;` element of the document. |
| `document.implementation` | Returns the **DOM implementation object**. |
| `document.inputEncoding` | Returns the **character encoding** of the document. |
| `document.lastModified` | Returns the **last modified date** of the document. |
| `document.readyState` | Returns the **current loading status** (`loading`, `interactive`, `complete`). |
| `document.scripts` | Returns a **collection of all `&lt;script&gt;` elements**. |
| `document.strictErrorChecking` | Indicates whether **strict error checking is enabled** (Boolean). |

---

## **📌 Examples of Common DOM Properties**
### **1️⃣ Get Document Title (`document.title`)**
```js
console.log(document.title); // Returns the title of the document
```

### **2️⃣ Get All Images (`document.images`)**
```js
let images = document.images;
console.log(images.length); // Number of images on the page
```

### **3️⃣ Get Last Modified Date (`document.lastModified`)**
```js
console.log(""Last Modified: "" + document.lastModified);
```

### **4️⃣ Get the Full Page URL (`document.URL`)**
```js
console.log(document.URL); // Returns the full URL of the current page
```

### **5️⃣ Check Page Loading State (`document.readyState`)**
```js
console.log(document.readyState); // Returns ""loading"", ""interactive"", or ""complete""
```

---

## **📌 Summary**
| **DOM Level** | **Properties** | **Examples** |
|--------------|---------------|-------------|
| **DOM 1** | `document.body`, `document.forms`, `document.images`, `document.title`, `document.URL` | Access the `&lt;body&gt;` element, get all forms/images, check title &amp; URL. |
| **DOM 3** | `document.doctype`, `document.head`, `document.readyState`, `document.lastModified` | Get DOCTYPE, check page load status, last modified date. |

🚀 **Understanding DOM properties** allows developers to dynamically **access and manipulate web pages** using JavaScript!&lt;/body&gt;&lt;/html&gt;</title></a></form></applet></a>"		
160	DOM elements	Finding HTML Element by Id	"### **Finding an HTML Element by ID Using `document.getElementById()`**

The **easiest way** to **select an HTML element** in the DOM is by using the **`document.getElementById()`** method. It returns the **first matching element** with the given `id`, or `null` if no matching element exists.

---

## **📌 Syntax**
```js
var myElement = document.getElementById(""intro"");
```
- `document.getElementById(""intro"")` → Searches for an element with `id=""intro""`.
- If found, `myElement` holds the **element object**.
- If not found, `myElement` is `null`.

---

## **📌 Example: Selecting an Element by ID**
```html




<p id=""intro"">Hello, this is an introduction!</p>
<button onclick=""changeText()"">Click Me</button>





```

### **Explanation**:
✔ **Selects the `<p>` element** with `id=""intro""`.  
✔ **Changes its content** when the button is clicked.  
✔ **Checks if the element exists** before modifying it (`if (myElement) {}`).

---

## **📌 Example: Checking If an Element Exists**
If the element does not exist, `getElementById()` returns `null`, which can cause errors if not handled properly.

```js
var element = document.getElementById(""nonExistent"");

if (element === null) {
    console.log(""Element not found!"");
} else {
    console.log(""Element found:"", element);
}
```
✔ Ensures the element **exists before accessing its properties**.

---

## **📌 When to Use `getElementById()`**
✔ When selecting **a single unique element** (`id` must be unique).  
✔ When **modifying content dynamically** (e.g., updating text, changing styles).  
✔ When **checking for element existence** before performing actions.  

🚀 **Mastering `document.getElementById()`** helps in quickly accessing and manipulating HTML elements!</p>"		
161	DOM elements	Finding HTML Elements by Tag Name	"### **Finding HTML Elements Using `getElementsByTagName()` in JavaScript**

The **`document.getElementsByTagName()`** method allows you to **select multiple elements** by their **tag name** (e.g., `p`, `div`, `span`). This method returns a **collection (HTMLCollection)** of matching elements.

---

## **📌 Syntax**
```js
var elements = document.getElementsByTagName(""tagName"");
```
- Returns a **collection (HTMLCollection)** of all elements with the specified tag name.
- If no matching elements are found, it returns an **empty collection**.

---

## **📌 Example 1: Finding All `<p>` Elements**
```html




</p><p>Paragraph 1</p>
<p>Paragraph 2</p>
<p>Paragraph 3</p>
<button onclick=""highlightParagraphs()"">Highlight</button>





```
### **Explanation**:
✔ `document.getElementsByTagName(""p"")` **selects all `<p>` elements**.  
✔ The loop **iterates through the collection** and applies a style change.  
✔ Clicking the button **highlights all paragraphs**.

---

## **📌 Example 2: Finding `</p><p>` Elements Inside a Specific Element**
Instead of selecting all `</p><p>` elements in the document, you can **narrow the search** to a specific container.

```html




</p><div id=""main"">
    <p>Main Paragraph 1</p>
    <p>Main Paragraph 2</p>
</div>

<div id=""secondary"">
    <p>Secondary Paragraph</p>
</div>

<button onclick=""highlightMainParagraphs()"">Highlight Main</button>





```
### **Explanation**:
✔ `document.getElementById(""main"")` **selects the `<div>` with `id=""main""`**.  
✔ `.getElementsByTagName(""p"")` **finds all `<p>` elements inside** the `main` div.  
✔ Clicking the button **only changes the text color of paragraphs inside `main`**, leaving other paragraphs unaffected.

---

## **📌 `getElementsByTagName()` vs. `querySelectorAll()`**
While `getElementsByTagName()` is useful, **`querySelectorAll()`** provides more flexibility by allowing **CSS selectors**.

| Method | Returns | Supports CSS Selectors? |
|--------|---------|------------------------|
| `getElementsByTagName(""tag"")` | **HTMLCollection** (live) | ❌ No |
| `querySelectorAll(""tag"")` | **NodeList** (static) | ✅ Yes |

✔ **Use `getElementsByTagName()` when you need a live collection of elements.**  
✔ **Use `querySelectorAll()` when selecting elements with more complex CSS selectors.**  

---

### **📌 Summary**
| **Method** | **Description** |
|------------|----------------|
| `document.getElementsByTagName(""p"")` | Selects **all** `</p><p>` elements in the document. |
| `element.getElementsByTagName(""p"")` | Selects `</p><p>` elements **inside a specific element**. |

🚀 **Using `getElementsByTagName()` effectively helps you manipulate groups of elements dynamically!**</p></div>"		
162	DOM elements	Finding HTML Elements by Class Name	"### **Finding Elements by Class Name Using `getElementsByClassName()` in JavaScript**

The **`document.getElementsByClassName()`** method allows you to **select multiple elements** by their **class name**. It returns an **HTMLCollection** of all elements that share the specified class.

---

## **📌 Syntax**
```js
var elements = document.getElementsByClassName(""className"");
```
- **Returns** an **HTMLCollection** (a live collection of matching elements).
- **If no elements match**, it returns an **empty collection**.
- **Works in modern browsers**, but **not supported in Internet Explorer 8 or earlier**.

---

## **📌 Example 1: Selecting All Elements with a Specific Class**
```html




<p class=""intro"">First intro paragraph.</p>
<p class=""intro"">Second intro paragraph.</p>
<p>Another paragraph.</p>

<button onclick=""highlightIntro()"">Highlight Intro</button>





```
### **Explanation**:
✔ `document.getElementsByClassName(""intro"")` selects **all** elements with `class=""intro""`.  
✔ The **loop iterates** through the collection and **applies a yellow background**.  
✔ Clicking the button **highlights only elements with the `""intro""` class**.

---

## **📌 Example 2: Finding Elements Inside a Specific Container**
Instead of searching the **entire document**, you can limit the search to a **specific parent element**.

```html




<div id=""content"">
    <p class=""intro"">Inside content div.</p>
    <p class=""intro"">Another intro inside content.</p>
</div>

<div>
    <p class=""intro"">Outside content div.</p>
</div>

<button onclick=""highlightContentIntro()"">Highlight Content Intro</button>





```
### **Explanation**:
✔ `document.getElementById(""content"")` **selects the `<div>`** with `id=""content""`.  
✔ `.getElementsByClassName(""intro"")` finds **only elements inside `content`**.  
✔ Clicking the button **only changes the text color of paragraphs inside `content`**, leaving other `.intro` elements unchanged.

---

## **📌 `getElementsByClassName()` vs. `querySelectorAll()`**
Since `getElementsByClassName()` is **not supported in Internet Explorer 8 or earlier**, an alternative is **`querySelectorAll()`**.

| Method | Returns | Supports IE8? |
|--------|---------|--------------|
| `getElementsByClassName(""class"")` | **HTMLCollection** (live) | ❌ No |
| `querySelectorAll("".class"")` | **NodeList** (static) | ✅ Yes |

✔ **Use `querySelectorAll("".class"")`** if you need compatibility with older browsers.

### **Example Using `querySelectorAll()`**
```js
var elements = document.querySelectorAll("".intro"");
```
- This selects **all elements** with `class=""intro""`, just like `getElementsByClassName()` but works in **all modern browsers**.

---

## **📌 Summary**
| **Method** | **Description** |
|------------|----------------|
| `document.getElementsByClassName(""class"")` | Selects **all** elements with the given class. |
| `element.getElementsByClassName(""class"")` | Selects elements **inside a specific element**. |
| `document.querySelectorAll("".class"")` | Alternative that works in **older browsers**. |

🚀 **Using `getElementsByClassName()` efficiently helps in selecting multiple elements dynamically and making web pages interactive!**</div>"		
163	DOM elements	Finding HTML Elements by CSS Selectors	"### **Using `querySelectorAll()` to Select Elements in JavaScript**

The **`querySelectorAll()`** method allows you to **select multiple elements** that match a specified **CSS selector**. Unlike `getElementById()` or `getElementsByClassName()`, **this method supports all CSS selectors**, including **tag names, class names, attributes, and more**.

---

## **📌 Syntax**
```js
var elements = document.querySelectorAll(""CSS selector"");
```
- **Returns a `NodeList`** (a static list of elements matching the selector).
- **If no elements match**, it returns an **empty NodeList**.
- **Not supported in Internet Explorer 8 or earlier**.

---

## **📌 Example 1: Selecting All `<p>` Elements with a Class**
```html




</p><p class=""intro"">Paragraph 1 with class intro.</p>
<p class=""intro"">Paragraph 2 with class intro.</p>
<p>Another paragraph without class.</p>

<button onclick=""highlightParagraphs()"">Highlight Intro</button>





```
### **Explanation**:
✔ `document.querySelectorAll(""p.intro"")` selects **all `<p>` elements with class `""intro""`**.  
✔ The loop applies a **yellow background** to each selected element.

---

## **📌 Example 2: Selecting Elements Using Different CSS Selectors**
### **Selecting Elements by ID, Class, and Attributes**
```js
document.querySelectorAll(""#myId""); // Selects the element with id=""myId""
document.querySelectorAll("".myClass""); // Selects all elements with class=""myClass""
document.querySelectorAll(""input[type='text']""); // Selects all <input> elements with type=""text""
document.querySelectorAll(""div &gt; p""); // Selects all </p><p> elements that are direct children of a </p><div>
```

---

## **📌 Example 3: Selecting Elements Inside a Specific Container**
```html
<div id=""container"">
    <p class=""intro"">Inside container</p>
    <p class=""intro"">Another inside container</p>
</div>

<p class=""intro"">Outside container</p>

<button onclick=""highlightContainerIntro()"">Highlight Container Intro</button>


```
✔ **Only paragraphs inside `#container` with class `""intro""` are affected**.

---

## **📌 `querySelectorAll()` vs. `getElementsByClassName()`**
| Method | Returns | Supports CSS Selectors? | Live or Static Collection? |
|--------|---------|------------------------|----------------------------|
| `getElementsByClassName(""class"")` | **HTMLCollection** | ❌ No | **Live** |
| `querySelectorAll("".class"")` | **NodeList** | ✅ Yes | **Static** |

### **Key Differences**:
- `querySelectorAll()` **supports all CSS selectors** (`.class`, `#id`, `[attribute]`, `:nth-child()`, etc.).
- `getElementsByClassName()` only works for **class names**.
- `querySelectorAll()` returns a **static NodeList** (does not update if elements are added/removed later).
- `getElementsByClassName()` returns a **live HTMLCollection** (updates dynamically).

---

## **📌 Summary**
✔ **`querySelectorAll()` selects multiple elements matching a CSS selector**.  
✔ **Works with any valid CSS selector**, including **classes, IDs, attributes, and child selectors**.  
✔ **Returns a `NodeList` (not live)**, meaning it doesn’t update when elements are added or removed dynamically.  
✔ **Not supported in Internet Explorer 8 or earlier** (use `getElementsByClassName()` for compatibility).  

🚀 **Using `querySelectorAll()` provides a powerful and flexible way to select multiple elements dynamically!**</div>"		
164	DOM elements	Finding HTML Elements by HTML Object Collections	"### **Accessing Forms and Their Elements Using `document.forms` in JavaScript**

The **`document.forms`** collection allows you to access **all `<form>` elements** in an HTML document. Using this, you can iterate through form elements and retrieve their values dynamically.

---

## **📌 Example: Accessing Form Elements by ID**
This example retrieves all input values from a form with `id=""frm1""` and displays them.

```html





    First name: <input type=""text"" name=""fname"" value=""John""><br>
    Last name: <input type=""text"" name=""lname"" value=""Doe""><br>
    Age: <input type=""number"" name=""age"" value=""30""><br>
    <button type=""button"" onclick=""displayValues()"">Submit</button>
</form>

<p id=""demo""></p>





```

### **Explanation**:
✔ `document.forms[""frm1""]` → Selects the form with `id=""frm1""`.  
✔ `x.elements[i].value` → Retrieves each form element’s value.  
✔ The values are displayed inside the `<p>` tag with `id=""demo""`.

---

## **📌 Alternative: Using `querySelector` for Better Selection**
While `document.forms` works well, `document.querySelector()` can also be used for better flexibility.

```js
var x = document.querySelector(""#frm1"");
```
✔ This **selects the form directly using CSS selectors**.

---

## **📌 Summary**
| **Method** | **Description** |
|------------|----------------|
| `document.forms` | Returns a collection of all forms in the document. |
| `document.forms[""frmID""]` | Retrieves a specific form by its `id` or `name`. |
| `form.elements[i]` | Accesses individual form elements. |
| `form.elements[i].value` | Retrieves the value of an input field. |

🚀 **Using `document.forms` helps efficiently retrieve and manipulate form data dynamically!**</p>"		
165	DOM elements	The following HTML objects (and object collections) are also accessible	"### **Common `document` Properties in JavaScript DOM**

The `document` object provides several **built-in properties** to access various elements in an HTML document. These properties help retrieve different parts of a web page dynamically.

---

## **📌 List of Common `document` Properties and Their Descriptions**

| **Property** | **Description** |
|-------------|----------------|
| `document.anchors` | Returns all `<a>` elements that have a `name` attribute (deprecated in HTML5). |
| `document.body` | Returns the `` element of the document. |
| `document.documentElement` | Returns the **root** `` element of the document. |
| `document.embeds` | Returns all `<embed>` elements in the document. |
| `document.forms` | Returns all `</a><form><a>` elements in the document. |
| `document.head` | Returns the `` element of the document. |
| `document.images` | Returns all `<img>` elements in the document. |
| `document.links` | Returns all `</a><a>` and `<area>` elements that have an `href` attribute. |
| `document.scripts` | Returns all `</a></form>"		
166	DOM HTML	Changing the HTML Output Stream	"### **Using `document.write()` in JavaScript**

The **`document.write()`** method allows JavaScript to **directly write content into the HTML document**. While it can be useful for quickly inserting content during page loading, it has significant **limitations**.

---

## **📌 Syntax**
```js
document.write(""Hello, World!"");
```
- The above line **writes directly** into the HTML page.

---

## **📌 Example: Writing the Current Date**
```html








```
✔ This **displays the current date** inside the page.

---

## **⚠️ Warning: `document.write()` Overwrites the Entire Page**
Using `document.write()` **after the page has loaded** will erase all existing content.

### **Example: `document.write()` Overwriting Page Content**
```html




<h1>Original Content</h1>
<button onclick=""overwriteContent()"">Click Me</button>





```
✔ **Clicking the button clears everything** and replaces it with `""All content is erased!""`.

---

## **📌 When to Avoid `document.write()`**
❌ **Never use it after the page is loaded** → It erases the entire document.  
❌ **Not recommended for dynamic updates** → Use `innerHTML` or `appendChild()` instead.  
❌ **Not suitable for modern JavaScript practices** → Avoid in interactive web applications.

---

## **📌 Alternative: Using `innerHTML` Instead of `document.write()`**
A better approach is **modifying an existing element** using `.innerHTML`.

### **Example: Updating Content Without Overwriting**
```html




<p id=""output"">Original text</p>
<button onclick=""updateText()"">Click Me</button>





```
✔ The button updates text **without erasing the page**.

---

## **📌 Summary**
| **Method** | **Description** | **Recommended?** |
|------------|----------------|-----------------|
| `document.write(""text"")` | Writes directly to the document **(can erase content if used after load)** | ❌ No |
| `element.innerHTML = ""text""` | Updates the content of an existing element | ✅ Yes |
| `document.createElement()` + `appendChild()` | Dynamically adds new elements | ✅ Yes |

🚀 **Use `document.write()` only for quick debugging, but avoid it in modern web development!**"		
167	DOM HTML	Changing HTML Content	"### **Modifying HTML Content Using `innerHTML` in JavaScript**

The **easiest way** to modify the content of an HTML element is by using the **`innerHTML` property**. This allows JavaScript to **dynamically update** the HTML content inside an element.

---

## **📌 Syntax**
```js
document.getElementById(""elementID"").innerHTML = ""New HTML content"";
```
- **`getElementById(""elementID"")`** → Selects the HTML element by `id`.
- **`.innerHTML`** → Sets or retrieves the **HTML content** inside the element.

---

## **📌 Example 1: Changing Text Inside a `<p>` Element**
```html




</p><p id=""demo"">Original Text</p>
<button onclick=""changeText()"">Click Me</button>





```
✔ Clicking the button **updates the paragraph's content**.

---

## **📌 Example 2: Adding New HTML Content**
You can also **insert HTML elements** using `innerHTML`.

```html




<div id=""container"">This is a div.</div>
<button onclick=""addContent()"">Add Content</button>





```
✔ This **replaces** the content inside `<div id=""container"">` with a new `<p>` element.

---

## **📌 Example 3: Appending Content Without Overwriting**
Using **`innerHTML +=`** allows you to **append content instead of replacing** it.

```js
document.getElementById(""container"").innerHTML += ""</p><p>Additional content.</p>"";
```

---

## **⚠️ Warning: Avoid `innerHTML` for User Input**
Using `innerHTML` with **user-generated content** can lead to **Cross-Site Scripting (XSS) attacks**.

✔ **Use `textContent` instead** to insert text safely:
```js
document.getElementById(""demo"").textContent = ""Safe text content."";
```
🚀 **`textContent` does not interpret HTML**, making it a safer alternative.

---

## **📌 Summary**
| **Property** | **Description** | **Example** |
|-------------|----------------|-------------|
| `innerHTML` | **Gets or sets** an element’s HTML content | `element.innerHTML = ""New Content"";` |
| `textContent` | **Gets or sets text only** (ignores HTML) | `element.textContent = ""Plain text"";` |

🚀 **Use `innerHTML` for inserting HTML dynamically, but always sanitize input to prevent security risks!**</div>"		
168	DOM HTML	Changing the Value of an Attribute	"### **Modifying HTML Attributes Using JavaScript**

In JavaScript, you can change the **value of an HTML attribute** using the **`attribute` property** or the **`setAttribute()` method**.

---

## **📌 Syntax**
```js
document.getElementById(""elementID"").attribute = ""newValue"";
```
- **`getElementById(""elementID"")`** → Selects the HTML element by `id`.
- **`attribute = ""newValue""`** → Updates the value of the specified attribute.

---

## **📌 Example 1: Changing an Image `src` Attribute**
```html




<img id=""myImage"" src=""image1.jpg"" width=""200"">
<button onclick=""changeImage()"">Change Image</button>





```
✔ Clicking the button **updates the image source** from `image1.jpg` to `image2.jpg`.

---

## **📌 Alternative: Using `setAttribute()`**
Instead of directly modifying properties, you can use **`setAttribute()`**, which works for any attribute.

### **Example 2: Changing an Attribute Using `setAttribute()`**
```html
<button id=""myButton"" onclick=""disableButton()"">Click Me</button>


```
✔ Clicking the button **disables itself** using `setAttribute(""disabled"", ""true"")`.

---

## **📌 Example 3: Changing Multiple Attributes**
You can modify multiple attributes at once.

```js
let link = document.getElementById(""myLink"");
link.href = ""https://www.google.com"";
link.target = ""_blank"";  // Opens in a new tab
link.title = ""Go to Google"";
```

---

## **📌 `setAttribute()` vs. Direct Property Assignment**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| `element.attribute = value;` | Works for **common attributes** (like `src`, `href`, `id`). | `element.src = ""newImage.jpg"";` |
| `element.setAttribute(name, value);` | Works for **any attribute**, even custom ones. | `element.setAttribute(""data-value"", ""123"");` |

🚀 **Use `setAttribute()` when modifying custom attributes, and direct property assignment for common attributes like `src`, `href`, or `class`.**"		
169	DOM CSS	Changing HTML Style	"### **Modifying an HTML Element’s Style Using JavaScript**

In JavaScript, you can dynamically change the **CSS styles** of an HTML element using the **`style` property**.

---

## **📌 Syntax**
```js
document.getElementById(""elementID"").style.property = ""newStyle"";
```
- **`getElementById(""elementID"")`** → Selects the HTML element by `id`.
- **`.style.property = ""newStyle""`** → Updates the specified CSS property.

---

## **📌 Example 1: Changing Text Color**
```html




<p id=""demo"">This is a paragraph.</p>
<button onclick=""changeColor()"">Change Color</button>





```
✔ Clicking the button **changes the text color** of the paragraph to red.

---

## **📌 Example 2: Changing Background Color**
```html
<button onclick=""changeBackground()"">Change Background</button>


```
✔ Clicking the button **changes the page background** to light blue.

---

## **📌 Example 3: Changing Multiple Styles**
You can modify **multiple CSS properties** by assigning each property separately.

```js
document.getElementById(""box"").style.width = ""200px"";
document.getElementById(""box"").style.height = ""100px"";
document.getElementById(""box"").style.backgroundColor = ""yellow"";
```

Or, use **`cssText`** to update multiple styles at once:
```js
document.getElementById(""box"").style.cssText = ""width: 200px; height: 100px; background-color: yellow;"";
```

---

## **📌 Example 4: Toggling Styles with JavaScript**
You can **toggle styles dynamically** using JavaScript.

```html
<p id=""text"">Click the button to toggle text color.</p>
<button onclick=""toggleColor()"">Toggle Color</button>


```
✔ Clicking the button **toggles the text color** between black and blue.

---

## **📌 Summary**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| `element.style.property = ""value"";` | Changes a **single CSS property**. | `element.style.color = ""red"";` |
| `element.style.cssText = ""prop: value; prop: value;""` | Changes **multiple styles** at once. | `element.style.cssText = ""color: blue; font-size: 20px;""` |

🚀 **Using JavaScript to modify styles dynamically enhances interactivity and user experience on web pages!**"		
170	DOM animations	Animation Code	"### **Creating JavaScript Animations Using `setInterval()`**

JavaScript **animations** work by **gradually changing an element's style** over time. This is done by calling a **timer function (`setInterval()`)** that updates the style at small time intervals, creating a smooth motion.

---

## **📌 Basic Animation Structure Using `setInterval()`**
```js
var id = setInterval(frame, 5);  // Call the `frame` function every 5 milliseconds

function frame() {
    if (/* test for finished */) {
        clearInterval(id);  // Stop the animation when done
    } else {
        /* code to change the element's style */
    }
}
```
- **`setInterval(frame, 5)`** → Calls the `frame` function every 5 milliseconds.
- **Inside `frame()`**:
  - A condition checks if the animation is **finished** (`if (...)`).
  - If finished, `clearInterval(id)` stops the animation.
  - Otherwise, the element's style is updated gradually.

---

## **📌 Example: Moving a Box Across the Screen**
```html




<div id=""box"" style=""width:50px;height:50px;background:red;position:absolute;""></div>
<button onclick=""startAnimation()"">Start Animation</button>





```
✔ Clicking the button **moves the box 300px to the right**.

---

## **📌 Example: Expanding a Box (Width Animation)**
```html




<div id=""box"" style=""width:50px;height:50px;background:blue;""></div>
<button onclick=""expandBox()"">Expand</button>





```
✔ Clicking the button **smoothly expands the box width from 50px to 200px**.

---

## **📌 Stopping the Animation**
You can **stop an animation** by calling `clearInterval(id)`, as seen in the examples above.

If you want to manually stop an animation, store the interval ID and use a **stop button**:
```js
var id;

function startMoving() {
    var elem = document.getElementById(""box"");
    var position = 0;
    id = setInterval(frame, 5);

    function frame() {
        if (position &gt;= 300) {
            clearInterval(id);
        } else {
            position++;
            elem.style.left = position + ""px"";
        }
    }
}

function stopMoving() {
    clearInterval(id);
}
```
✔ This allows you to **start and stop** animations dynamically.

---

## **📌 Summary**
| **Method** | **Description** |
|------------|----------------|
| `setInterval(function, time)` | Calls a function repeatedly every `time` milliseconds. |
| `clearInterval(id)` | Stops the interval with the given ID. |

🚀 **Using `setInterval()` enables smooth animations by continuously updating element styles!**"		
171	DOM events	Reacting to Events	"### **JavaScript Event Handling: Executing Code on User Actions**

JavaScript allows code execution **when an event occurs**, such as **clicks, mouse movements, form submissions, and keypresses**. This makes web pages **interactive** and **dynamic**.

---

## **📌 How to Execute JavaScript on Events**
You can execute JavaScript **in different ways** when an event occurs:

1. **Inline HTML Event Attributes** (Not recommended for complex scripts)
2. **JavaScript Event Properties**
3. **`addEventListener()` Method** (Recommended)

---

## **📌 Example: Using `onclick` to Run JavaScript**
```html
<button onclick=""alert('Button clicked!')"">Click Me</button>
```
✔ Clicking the button **triggers an alert**.

---

## **📌 Common HTML Events**
| **Event** | **Description** | **Example Trigger** |
|-----------|----------------|---------------------|
| `onclick` | When an element is clicked. | `<button onclick=""myFunction()"">` |
| `onload` | When a webpage finishes loading. | `` |
| `onmouseover` | When the mouse hovers over an element. | `<p onmouseover=""myFunction()"">` |
| `onmouseout` | When the mouse leaves an element. | `</p><p onmouseout=""myFunction()"">` |
| `onchange` | When an input value changes. | `<input onchange=""myFunction()"">` |
| `onsubmit` | When a form is submitted. | `</p><form onsubmit=""myFunction()"">` |
| `onkeydown` | When a key is pressed. | `<input onkeydown=""myFunction()"">` |

---

## **📌 Example 1: Using `onclick` to Change Content**
```html




<p id=""text"">Click the button to change this text.</p>
</form></button><button onclick=""changeText()"">Click Me</button>





```
✔ Clicking the button **updates the paragraph text**.

---

## **📌 Example 2: Using `onmouseover` to Change Background**
```html
<p onmouseover=""this.style.backgroundColor='yellow'"" onmouseout=""this.style.backgroundColor='white'"">
   Hover over me!
</p>
```
✔ When the mouse **hovers over the text**, the **background turns yellow**.

---

## **📌 Example 3: Using `onchange` to Detect Input Changes**
```html
<input type=""text"" id=""name"" onchange=""showValue()"">
<p id=""output""></p>


```
✔ When the user **types something and moves out of the input field**, the paragraph updates.

---

## **📌 Recommended: Using `addEventListener()`**
Instead of inline attributes, use **`addEventListener()`**, which is more flexible.

```js
document.getElementById(""myButton"").addEventListener(""click"", function() {
    alert(""Button Clicked!"");
});
```
✔ This keeps HTML **clean** and allows **multiple event listeners** on the same element.

---

## **📌 Summary**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| **Inline Event Attribute** | Adds an event directly in HTML (**not recommended for complex scripts**). | `<button onclick=""myFunction()"">Click</button>` |
| **Event Property** | Assigns an event in JavaScript (**overwrites previous event**). | `element.onclick = function() {...}` |
| **`addEventListener()`** | Attaches multiple event listeners (**recommended approach**). | `element.addEventListener(""click"", function() {...})` |

🚀 **Mastering event handling in JavaScript** allows for creating **dynamic, interactive, and responsive web pages!**"		
172	DOM events	HTML Event Attributes	"### **Assigning Events to HTML Elements Using Event Attributes**

JavaScript allows you to **assign events** to HTML elements using **event attributes**, making web pages interactive. The most common example is the **`onclick` event**, which runs a function when a user clicks a button.

---

## **📌 Example: Assigning `onclick` to a Button**
```html




<button onclick=""displayDate()"">Try it</button>
<p id=""demo""></p>





```
✔ Clicking the button **displays the current date and time** inside the `<p>` element.

---

## **📌 Other Common Event Attributes**
You can assign different **event attributes** to HTML elements.

| **Event Attribute** | **Description** |
|-----------------|-----------------|
| `onclick` | Runs a function when the element is clicked. |
| `onmouseover` | Runs when the mouse hovers over an element. |
| `onmouseout` | Runs when the mouse moves away from an element. |
| `onchange` | Runs when an input value changes. |
| `onsubmit` | Runs when a form is submitted. |
| `onkeydown` | Runs when a key is pressed. |

---

## **📌 Example 2: Using `onmouseover` and `onmouseout`**
```html
</p><p onmouseover=""this.style.color='red'"" onmouseout=""this.style.color='black'"">
   Hover over me!
</p>
```
✔ The **text turns red** when the mouse hovers and **returns to black** when the mouse leaves.

---

## **📌 Example 3: Using `onchange` to Detect Input Changes**
```html
<input type=""text"" id=""name"" onchange=""showValue()"">
<p id=""output""></p>


```
✔ When the user **types something and moves out of the input field**, the paragraph updates.

---

## **📌 Alternative: Using `addEventListener()` (Recommended)**
Instead of writing events directly in HTML, you can **assign them using JavaScript** for better organization.

### **Example: Using `addEventListener()` Instead of `onclick`**
```html
<button id=""myButton"">Click Me</button>


```
✔ **This keeps the HTML clean** and allows **multiple event listeners** on the same element.

---

## **📌 Summary**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| **Inline Event Attribute** | Assigns an event directly in HTML (**not recommended for complex scripts**). | `<button onclick=""myFunction()"">Click</button>` |
| **Event Property** | Assigns an event in JavaScript (**overwrites previous event**). | `element.onclick = function() {...}` |
| **`addEventListener()`** | Attaches multiple event listeners (**recommended approach**). | `element.addEventListener(""click"", function() {...})` |

🚀 **Using JavaScript events makes your web pages interactive and dynamic!**"		
173	DOM events	Assign Events Using the HTML DOM	"### **Assigning Events to HTML Elements Using JavaScript (`onclick` Property)**

The **HTML DOM** allows you to **assign events to HTML elements dynamically** using JavaScript. Instead of using inline event attributes (`onclick` inside HTML), you can assign events in JavaScript for better organization and flexibility.

---

## **📌 Assigning `onclick` Using JavaScript**
### **Example: Assigning `onclick` to a Button**
```html




<button id=""myBtn"">Click Me</button>
<p id=""demo""></p>





```
✔ Clicking the button **displays the current date and time** inside the `<p>` element.

---

## **📌 Explanation**
1. `document.getElementById(""myBtn"")` → Selects the button.
2. `.onclick = displayDate;` → Assigns the function `displayDate` to the `onclick` event.
3. When the button is clicked, `displayDate()` **updates the content** of `</p><p id=""demo"">`.

---

## **📌 Alternative: Using `addEventListener()` (Recommended)**
Using `.onclick` **overwrites** previous event handlers. A better approach is **`addEventListener()`**, which allows multiple events.

### **Example: Using `addEventListener()`**
```html
<button id=""myBtn"">Click Me</button>


```
✔ This **keeps the HTML clean** and allows **multiple event listeners**.

---

## **📌 Summary**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| **`onclick` Property** | Assigns an event directly (**overwrites previous events**). | `element.onclick = function() {...};` |
| **`addEventListener()`** | Allows multiple event listeners (**recommended**). | `element.addEventListener(""click"", function() {...});` |

🚀 **Using JavaScript to assign events dynamically improves code maintainability and interactivity!**</p>"		
174	DOM events	The onload and onunload Events	"### **Using `onload` and `onunload` Events in JavaScript**

The **`onload` and `onunload`** events allow JavaScript to execute code when a user **enters or leaves** a web page.

---

## **📌 `onload` Event**
- **Triggered when a webpage has fully loaded**.
- Useful for:
  - Running scripts **after all content** (HTML, images, styles) has loaded.
  - Checking **browser type** and loading different versions of a page.
  - **Handling cookies** when the page loads.

### **Example 1: Running a Function When the Page Loads**
```html








```
✔ When the page loads, an **alert message appears**.

---

## **📌 `onunload` Event**
- **Triggered when the user leaves the page** (navigating away or closing the browser).
- Useful for:
  - Saving **user data before exit**.
  - **Confirming exit actions**.

### **Example 2: Alerting When the User Leaves**
```html








```
✔ The **alert appears when the user leaves the page**.

---

## **📌 Example 3: Checking Browser Type with `onload`**
You can check the **visitor’s browser type** when the page loads.

```html



```
✔ **Detects the browser type** and alerts the user.

---

## **📌 Example 4: Checking Cookies with `onload`**
Cookies can store **user preferences** and load them when the page opens.

```html



```
✔ **Checks if cookies are enabled** and alerts the user.

---

## **📌 Alternative: Using `addEventListener()` for `onload`**
Instead of writing `onload` inside ``, use JavaScript:

```js
window.addEventListener(""load"", function() {
    alert(""Page has loaded successfully!"");
});
```
✔ **Keeps HTML clean** and allows multiple event listeners.

---

## **📌 Summary**
| **Event** | **Triggers When...** | **Common Uses** |
|-----------|----------------------|----------------|
| **`onload`** | The page **fully loads** | Check **browser type**, **load cookies**, run scripts **after page load**. |
| **`onunload`** | The user **leaves the page** | Save user data, **confirm exit actions**, clean up resources. |

🚀 **Using `onload` and `onunload` helps improve user experience by handling page load events efficiently!**"		
175	DOM events	The onchange event	"### **Using the `onchange` Event for Input Validation in JavaScript**

The **`onchange` event** triggers when the value of an input field **changes** and the user moves away (blurs out) from the field. It is commonly used for **input validation, formatting, and auto-correction**.

---

## **📌 Syntax**
```html
<input type=""text"" id=""fname"" onchange=""upperCase()"">
```
- **Triggers `upperCase()`** when the user **types in the field** and then **clicks away**.
- Useful for **formatting input dynamically**.

---

## **📌 Example 1: Converting Input to Uppercase**
```html




Enter name: <input type=""text"" id=""fname"" onchange=""upperCase()"">





```
✔ When the user **types in lowercase and moves out of the input field**, the **text is converted to uppercase**.

---

## **📌 Example 2: Validating an Email Input**
```html




Email: <input type=""email"" id=""email"" onchange=""validateEmail()"">
<p id=""message""></p>





```
✔ **Checks if the email contains ""@"" and ""."" when the user moves out of the input field.**

---

## **📌 Example 3: Using `addEventListener()` for `onchange`**
Instead of using the `onchange` attribute in HTML, you can use JavaScript for **better structure**.

```html
<input type=""text"" id=""username"">
<p id=""output""></p>


```
✔ This **updates the paragraph text when the input changes**.

---

## **📌 When to Use `onchange`**
✔ When validating **form inputs** (email, phone, username).  
✔ When formatting text (converting to **uppercase, trimming spaces**).  
✔ When dynamically **updating elements based on user input**.  

🚀 **Using `onchange` makes form validation and real-time input formatting smoother!**"		
176	DOM events	The onmouseover and onmouseout Events	"### **Using `onmouseover` and `onmouseout` Events in JavaScript**

The **`onmouseover` and `onmouseout`** events allow JavaScript to detect when the mouse **enters** (`onmouseover`) or **leaves** (`onmouseout`) an element. These events are commonly used for **hover effects, tooltips, and dynamic styling**.

---

## **📌 Syntax**
```html
element.onmouseover = function() { /* Code when mouse enters */ };
element.onmouseout = function() { /* Code when mouse leaves */ };
```
- **`onmouseover`** → Triggers when the mouse enters the element.
- **`onmouseout`** → Triggers when the mouse leaves the element.

---

## **📌 Example 1: Changing Background Color on Hover**
```html




<p id=""hoverText"" onmouseover=""changeColor()"" onmouseout=""resetColor()"">Hover over me!</p>





```
✔ **When the user hovers over the text, the background turns yellow; when they leave, it resets.**

---

## **📌 Example 2: Displaying a Tooltip on Hover**
```html




<p id=""tooltip"" onmouseover=""showTooltip()"" onmouseout=""hideTooltip()"">Hover over me for info!</p>
<span id=""info"" style=""display:none; color:blue;"">This is additional information.</span>





```
✔ **When the user hovers, extra information appears; when they move away, it disappears.**

---

## **📌 Example 3: Using `addEventListener()` (Recommended)**
Instead of using `onmouseover` and `onmouseout` in HTML, you can assign them using JavaScript.

```html
<p id=""hoverText"">Hover over me!</p>


```
✔ **Keeps HTML clean and allows multiple event listeners on the same element.**

---

## **📌 Summary**
| **Event** | **Description** | **Example** |
|-----------|----------------|-------------|
| `onmouseover` | Triggers when the mouse enters an element. | `element.onmouseover = function() {...};` |
| `onmouseout` | Triggers when the mouse leaves an element. | `element.onmouseout = function() {...};` |

🚀 **Using hover events improves interactivity and user experience on web pages!**"		
177	DOM events	The onmousedown, onmouseup and onclick Events	"### **Understanding `onmousedown`, `onmouseup`, and `onclick` Events in JavaScript**

A **mouse click** consists of three key events:
1. **`onmousedown`** → Fires when the mouse button is **pressed down**.
2. **`onmouseup`** → Fires when the mouse button is **released**.
3. **`onclick`** → Fires when the **click action is completed** (after both `mousedown` and `mouseup`).

---

## **📌 Event Execution Order**
1️⃣ **User presses the mouse button** → `onmousedown` fires  
2️⃣ **User releases the mouse button** → `onmouseup` fires  
3️⃣ **Click action completes** → `onclick` fires  

---

## **📌 Example 1: Logging Each Mouse Event**
```html




<button id=""myButton"">Click Me</button>





```
✔ **Opens the console and click the button to see the event sequence.**

---

## **📌 Example 2: Changing Button Color on Press and Release**
```html




<button id=""myButton"">Press Me</button>





```
✔ The **button changes color when pressed and released**, and **shows an alert on full click**.

---

## **📌 Example 3: Using `addEventListener()` (Recommended)**
Instead of assigning events directly, **use `addEventListener()`** for better structure and flexibility.

```html
<button id=""myBtn"">Click Me</button>


```
✔ **Keeps HTML clean and allows multiple event listeners on the same element.**

---

## **📌 Summary**
| **Event** | **Triggers When...** | **Common Uses** |
|-----------|----------------------|----------------|
| `onmousedown` | The mouse button is **pressed down**. | Start animations, change styles. |
| `onmouseup` | The mouse button is **released**. | Stop animations, reset styles. |
| `onclick` | A full click event occurs (**mousedown + mouseup**). | Execute functions on click. |

🚀 **Using mouse events dynamically improves interactivity and user experience on web pages!**"		
178	DOM event listener	The addEventListener() method	"### **Using `addEventListener()` to Attach Events in JavaScript**

The **`addEventListener()`** method is the preferred way to attach event handlers to elements because it:
✔ **Does not overwrite existing event handlers**  
✔ **Allows multiple event handlers for the same event**  
✔ **Can be applied to any DOM object (not just HTML elements)**  
✔ **Provides better control over event bubbling**  
✔ **Keeps JavaScript separate from HTML for cleaner code**  

---

## **📌 Example 1: Adding an Event Listener to a Button**
```html




<button id=""myBtn"">Click Me</button>
<p id=""demo""></p>





```
✔ Clicking the button **displays the current date and time** inside `<p id=""demo"">`.

---

## **📌 Example 2: Adding Multiple Event Listeners to the Same Element**
Unlike `onclick`, which **overwrites previous event handlers**, `addEventListener()` allows **multiple handlers** for the same event.

```html
<button id=""myButton"">Click Me</button>


```
✔ **Both alerts will fire when the button is clicked**.

---

## **📌 Example 3: Removing an Event Listener (`removeEventListener()`)**
You can **remove an event listener** using `removeEventListener()`, but **the function must be named** (anonymous functions cannot be removed).

```html
<button id=""stopBtn"">Click Me</button>
<button onclick=""removeHandler()"">Remove Click Event</button>


```
✔ Clicking ""Click Me"" **shows an alert**.  
✔ Clicking ""Remove Click Event"" **disables the click functionality**.

---

## **📌 Example 4: Adding an Event Listener to the Window Object**
You can attach event listeners **not just to HTML elements but also to the `window` object**.

```js
window.addEventListener(""resize"", function() {
    console.log(""Window resized!"");
});
```
✔ This **logs a message whenever the window is resized**.

---

## **📌 Controlling Event Bubbling and Capturing**
By default, event listeners use **bubbling** (events propagate from child to parent). You can **set the third parameter to `true` to use capturing**.

```html
</p><div id=""parent"">
    <button id=""child"">Click Me</button>
</div>


```
✔ When clicking **Child**, the **Parent event fires first** due to **capturing mode (`true`)**.

---

## **📌 Summary**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| `addEventListener(event, function)` | Attaches an event without overwriting existing ones. | `element.addEventListener(""click"", myFunction);` |
| `removeEventListener(event, function)` | Removes an event listener (**requires named function**). | `element.removeEventListener(""click"", myFunction);` |
| `window.addEventListener(event, function)` | Adds an event to the window object. | `window.addEventListener(""resize"", myFunction);` |

🚀 **Using `addEventListener()` is the best way to attach events dynamically, allowing multiple handlers and better control over event flow!**"		
179	DOM event listener	Syntax	"### **Using `addEventListener(event, function, useCapture)` in JavaScript**

The **`addEventListener()`** method allows you to attach an event handler to an element. It provides flexibility by:
✔ **Allowing multiple event handlers on the same element**  
✔ **Providing access to the event object**  
✔ **Controlling event bubbling or capturing**  

---

## **📌 Syntax**
```js
element.addEventListener(event, function, useCapture);
```
- **`event`** → The type of event (`""click""`, `""mouseover""`, `""keydown""`, etc.).
- **`function`** → The function to execute when the event occurs.
- **`useCapture` (optional, default = `false`)** →  
  - `true` → Event captured **during capturing phase** (from parent to child).  
  - `false` → Event captured **during bubbling phase** (child to parent).  

---

## **📌 Example 1: Adding a Click Event Using an Anonymous Function**
```html
<button id=""myBtn"">Click Me</button>


```
✔ Clicking the button **shows an alert message**.

---

## **📌 Example 2: Using an External Named Function**
Instead of using an anonymous function, you can refer to a **named function**.

```html
<button id=""myBtn"">Click Me</button>


```
✔ Keeps the code **organized and reusable**.

---

## **📌 Example 3: Handling an Event with the Event Object**
When an event occurs, an **event object** is passed to the function, containing details about the event.

```html
<button id=""myBtn"">Click Me</button>


```
✔ Clicking the button **displays the event type (`click`) and the clicked element (`BUTTON`)**.

---

## **📌 Example 4: Controlling Event Bubbling vs. Capturing**
By default, event listeners **use bubbling (`false`)**, but you can enable **capturing (`true`)**.

```html
<div id=""parent"">
    <button id=""child"">Click Me</button>
</div>


```
✔ Since **capturing (`true`)** is enabled, clicking the button **first triggers the parent event, then the child**.

---

## **📌 Example 5: Removing an Event Listener**
To **remove an event listener**, you need to use a **named function**.

```html
<button id=""myBtn"">Click Me</button>
<button onclick=""removeHandler()"">Remove Event</button>


```
✔ Clicking ""Click Me"" **triggers the alert**, but clicking ""Remove Event"" **disables further clicks**.

---

## **📌 Summary**
| **Feature** | **Description** | **Example** |
|------------|----------------|-------------|
| **Attach an Event** | Adds an event without overwriting existing ones. | `element.addEventListener(""click"", myFunction);` |
| **Remove an Event** | Removes an event listener (**requires a named function**). | `element.removeEventListener(""click"", myFunction);` |
| **Event Object** | Provides event details like `target`, `type`, etc. | `event.target.tagName;` |
| **Bubbling (`false`)** | Events propagate **from child to parent** (default). | `element.addEventListener(""click"", func, false);` |
| **Capturing (`true`)** | Events propagate **from parent to child**. | `element.addEventListener(""click"", func, true);` |

🚀 **Using `addEventListener()` makes event handling flexible, efficient, and interactive!**"		
180	DOM event listener	Add Many Event Handlers to the Same Element	"### **Using `addEventListener()` to Attach Multiple Events to an Element**

The **`addEventListener()`** method allows you to:
✔ **Attach multiple event handlers to the same element** without overwriting previous ones.  
✔ **Add multiple types of events** (e.g., `click`, `mouseover`, `mouseout`) to a single element.  
✔ **Provide better event management** compared to `onclick`, which replaces previous event handlers.  

---

## **📌 Attaching Multiple Event Listeners to the Same Element**
You can **add multiple event handlers of the same type** to an element.

### **Example 1: Assigning Multiple `click` Handlers**
```html




<button id=""myBtn"">Click Me</button>





```
✔ Clicking the button **executes both `myFunction()` and `mySecondFunction()`**.

---

## **📌 Adding Different Events to the Same Element**
You can **assign multiple event types** (e.g., `mouseover`, `click`, `mouseout`) to a single element.

### **Example 2: Handling Multiple Event Types**
```html




<p id=""myText"">Hover or Click Me!</p>





```
✔ **Hovering over** the text turns it **blue**.  
✔ **Clicking** the text **increases its font size**.  
✔ **Moving the mouse out** restores the original **black color**.

---

## **📌 Removing an Event Listener (`removeEventListener()`)**
You can **remove an event listener**, but the function **must be named**.

### **Example 3: Removing an Event Listener**
```html




<button id=""myBtn"">Click Me</button>
<button onclick=""removeHandler()"">Remove Event</button>





```
✔ Clicking ""Click Me"" **triggers the alert**.  
✔ Clicking ""Remove Event"" **disables the click event**.

---

## **📌 Summary**
| **Feature** | **Description** | **Example** |
|------------|----------------|-------------|
| **Multiple Events on the Same Element** | Allows multiple event handlers of the **same event type** on an element. | `element.addEventListener(""click"", func1); element.addEventListener(""click"", func2);` |
| **Different Events on the Same Element** | Adds different event types to the same element. | `element.addEventListener(""mouseover"", func1); element.addEventListener(""mouseout"", func2);` |
| **Remove an Event Listener** | Requires a **named function** to remove. | `element.removeEventListener(""click"", func);` |

🚀 **Using `addEventListener()` provides better control over events, making interactions more dynamic and flexible!**"		
181	DOM event listener	Add an Event Handler to the window Object	"### **Using `addEventListener()` on Various DOM Objects in JavaScript**

The **`addEventListener()`** method allows you to attach events not only to HTML elements but also to other **DOM objects** such as:
✔ The **`window` object**  
✔ The **document**  
✔ The **XMLHttpRequest object**  
✔ Any object that supports events  

---

## **📌 Example 1: Detecting Window Resize**
You can use the **`resize` event** on the `window` object to **detect changes in window size**.

```html




<p id=""demo"">Resize the window to see the effect.</p>





```
✔ When the user **resizes the browser window**, it updates the **width and height** dynamically.

---

## **📌 Example 2: Using `addEventListener()` on `document`**
The `document` object can also listen for events such as `DOMContentLoaded`, which fires when the page **fully loads**.

```html

```
✔ Logs **""Page fully loaded!""** when the **HTML content is fully parsed**.

---

## **📌 Example 3: Using `addEventListener()` with `XMLHttpRequest`**
The `XMLHttpRequest` object supports events like `""load""`, `""error""`, and `""progress""`.

```html

```
✔ Fetches data from an API and logs it when **loading completes**.

---

## **📌 Example 4: Handling Key Presses in `window`**
You can capture **keyboard events** using `window.addEventListener()`.

```html
<input type=""text"" id=""myInput"" placeholder=""Type something..."">
<p id=""output""></p>


```
✔ Displays **the key pressed** in real-time.

---

## **📌 Summary**
| **Target Object** | **Event Example** | **Usage** |
|------------------|------------------|----------|
| `window` | `""resize""`, `""scroll""`, `""keydown""` | Detect window interactions. |
| `document` | `""DOMContentLoaded""`, `""click""` | Handle document-wide events. |
| `XMLHttpRequest` | `""load""`, `""error""` | Monitor HTTP requests. |
| **Any DOM Element** | `""click""`, `""mouseover""`, `""change""` | Add interactions to elements. |

🚀 **Using `addEventListener()` on different DOM objects enhances interactivity and dynamic behavior on web pages!**"		
182	DOM event listener	Passing Parameters	"### **Passing Parameters in `addEventListener()` Using an Anonymous Function**

By default, when you assign an event listener using `addEventListener()`, the event-handling function is called **without arguments**. If you need to pass parameters, you must **wrap the function call inside an anonymous function**.

---

## **📌 Syntax: Using an Anonymous Function to Pass Arguments**
```js
element.addEventListener(""click"", function() {
    myFunction(p1, p2);
});
```
✔ This ensures that `myFunction(p1, p2)` is only **executed when the event occurs**, instead of running immediately.

---

## **📌 Example 1: Passing Parameters to a Function on Click**
```html




<button id=""myButton"">Click Me</button>
<p id=""demo""></p>





```
✔ Clicking the button **displays a name and age** inside the paragraph.

---

## **📌 Example 2: Passing the Clicked Element as a Parameter**
```html




<button id=""btn1"">Button 1</button>
<button id=""btn2"">Button 2</button>





```
✔ Clicking **each button** changes its own text to `""Clicked!""`.

---

## **📌 Example 3: Using `this` to Pass the Event Target**
If you want to pass the **clicked element itself**, use `this`.

```html
<button id=""myButton"">Click Me</button>


```
✔ Clicking the button **alerts its own text content**.

---

## **📌 Summary**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| **Direct Function Reference** | Runs without parameters. | `element.addEventListener(""click"", myFunction);` |
| **Anonymous Function with Parameters** | Calls function with arguments. | `element.addEventListener(""click"", function(){ myFunction(p1, p2); });` |
| **Using `this`** | Passes the clicked element. | `element.addEventListener(""click"", function(){ myFunction(this); });` |

🚀 **Using an anonymous function inside `addEventListener()` allows dynamic event handling with arguments!**"		
183	DOM event listener	Event Bubbling or Event Capturing?	"### **Event Propagation in JavaScript: Bubbling vs. Capturing**

Event propagation determines **the order in which events fire** when multiple elements are nested. The **two phases** of event propagation are:

1️⃣ **Bubbling (default, `false`)** → The **inner element's event fires first**, then propagates outward to the parent elements.  
2️⃣ **Capturing (`true`)** → The **outer element's event fires first**, then propagates inward to the target element.

---

## **📌 Understanding Event Propagation**
Imagine the following HTML structure:
```html
<div id=""myDiv"">
    <p id=""myP"">Click me!</p>
</div>
```
If the user clicks on `<p>`, should **`</p><p>` or `</p><div>` handle the event first**? The answer depends on **bubbling** or **capturing**.

---

## **📌 Example 1: Event Bubbling (Default)**
```html




<div id=""myDiv"" style=""width:200px;height:100px;background-color:lightgray;"">
    <p id=""myP"">Click me!</p>
</div>





```
✔ Clicking on `<p>` first triggers `""Paragraph Clicked!""`, then **bubbles up** to `</p><div>` showing `""Div Clicked!""`.

---

## **📌 Example 2: Event Capturing (Setting `true`)**
To **capture the event from the parent first**, set the `useCapture` parameter to `true`.

```html

```
✔ Clicking on `<p>` now **first triggers `""Div Clicked!""`**, then `""Paragraph Clicked!""`.

---

## **📌 Example 3: Stopping Propagation**
If you want to **prevent an event from propagating** further, use `event.stopPropagation()`.

```html

```
✔ Clicking on `</p><p>` **only triggers `""Paragraph Clicked!""`**, stopping the event from reaching `</p><div>`.

---

## **📌 Summary**
| **Propagation Type** | **Order of Event Execution** | **Default?** | **Example** |
|--------------------|----------------------|------------|-----------|
| **Bubbling (`false`)** | **Inner to Outer** (`<p>` → `</p><div>`) | ✅ Yes | `element.addEventListener(""click"", func, false);` |
| **Capturing (`true`)** | **Outer to Inner** (`<div>` → `<p>`) | ❌ No | `element.addEventListener(""click"", func, true);` |
| **Stopping Propagation** | Stops event from moving further | ❌ No | `event.stopPropagation();` |

🚀 **Understanding event propagation helps manage event flow efficiently, preventing unintended interactions!**</p></div></div></div></div></div>"		
184	DOM event listener	The removeEventListener() method	"### **Removing Event Listeners in JavaScript Using `removeEventListener()`**

The **`removeEventListener()`** method allows you to remove an event listener that was previously attached using **`addEventListener()`**. This is useful when you want to stop event execution dynamically.

---

## **📌 Syntax**
```js
element.removeEventListener(""event"", functionName);
```
- **`event`** → The type of event to remove (e.g., `""click""`, `""mousemove""`, `""keydown""`).
- **`functionName`** → The **same function reference** used in `addEventListener()`.

✔ **Important:** The function **must be named** to be removable.

---

## **📌 Example 1: Removing a `mousemove` Event**
```html




<p>Move your mouse over this area to see coordinates.</p>
<p id=""demo""></p>
<button onclick=""removeMouseMove()"">Stop Tracking</button>





```
✔ **While moving the mouse, coordinates are displayed.**  
✔ **Clicking ""Stop Tracking"" removes the event listener, stopping updates.**

---

## **📌 Example 2: Removing a Click Event from a Button**
```html
<button id=""myBtn"">Click Me</button>
<button onclick=""disableClick()"">Disable Click Event</button>


```
✔ **Clicking ""Disable Click Event"" stops the button from showing alerts.**

---

## **📌 Example 3: Why Anonymous Functions Cannot Be Removed**
```js
element.addEventListener(""click"", function() {
    alert(""Hello"");
});

element.removeEventListener(""click"", function() {
    alert(""Hello"");
});
```
❌ **The event is not removed** because the function references are different.  
✔ **Solution:** Use a **named function** instead.

---

## **📌 Summary**
| **Feature** | **Description** | **Example** |
|------------|----------------|-------------|
| **Removing an Event Listener** | Works only with named functions. | `element.removeEventListener(""click"", myFunction);` |
| **Anonymous Functions** | Cannot be removed. | ❌ `element.removeEventListener(""click"", function() {});` |
| **Stopping Dynamic Events** | Useful for stopping tracking, clicks, keypresses, etc. | `removeEventListener(""mousemove"", showCoords);` |

🚀 **Use `removeEventListener()` to dynamically control event execution, improving interactivity and efficiency!**"		
185	DOM event listener	The addEventListener() object interface (no w3)	"### **Using `handleEvent()` in `addEventListener()`**

The **`addEventListener()`** method usually takes a **function** as an event handler. However, it can also accept an **object** that has a `handleEvent(event)` method. This allows for **object-oriented event handling** where an object itself can manage multiple events.

---

## **📌 Syntax Using `handleEvent`**
```js
element.addEventListener(""eventType"", {
    handleEvent: function(event) {
        // Handle event here
    }
});
```
- The object **must have a `handleEvent()` method**.
- When the event occurs, **`handleEvent()` is automatically called**.

---

## **📌 Example 1: Using an Object with `handleEvent()`**
```html




<button id=""myButton"">Click Me</button>





```
✔ **Clicking the button triggers `handleEvent()` inside the object.**

---

## **📌 Example 2: Using a Constructor Function**
You can create **custom objects** to manage events dynamically.

```html




<button id=""myButton"">Click Me</button>





```
✔ **Clicking the button changes its text to `""Clicked!""`**.

---

## **📌 Example 3: Using a Class with `handleEvent()`**
A **better way** to manage event listeners **is with ES6 classes**.

```html




<button id=""myButton"">Click Me</button>





```
✔ The **button text changes when clicked**, and the handler is **an object instead of a function**.

---

## **📌 When to Use `handleEvent()` Instead of a Regular Function**
| **Feature** | **Function in `addEventListener()`** | **Object with `handleEvent()`** |
|------------|----------------------------------|------------------------------|
| **Ease of use** | Simple and widely used | More structured for complex scenarios |
| **Handles multiple events** | Requires multiple functions | Can be managed inside one object |
| **State Management** | No built-in state | Can store state inside object properties |
| **Reusability** | Can reuse functions | More reusable for multiple event types |

---

## **📌 Summary**
✔ **`handleEvent()` allows objects to act as event listeners**, making them more structured and reusable.  
✔ **Useful for managing multiple event types inside a single object**.  
✔ **Works well with ES6 classes**, allowing stateful event handling.  

🚀 **Using `handleEvent()` is useful for structured, object-oriented event management in JavaScript!**"		
186	DOM navigation	DOM Nodes	"### **Understanding the HTML DOM Node Tree in JavaScript**

The **HTML DOM (Document Object Model)** represents an HTML document as a **tree structure**, where everything in the document is a **node**. This allows JavaScript to **access, create, modify, and delete nodes dynamically**.

---

## **📌 Types of Nodes in the DOM**
| **Node Type** | **Description** |
|--------------|----------------|
| **Document Node** | Represents the **entire document**. (`document`) |
| **Element Nodes** | Represent **HTML elements** (e.g., `<div>`, `<p>`, `</p><h1>`). |
| **Text Nodes** | Contain **text inside an element** (e.g., `""Hello World""` inside `<p>Hello World</p>`). |
| **Attribute Nodes** (**Deprecated**) | Represent attributes (e.g., `class=""example""`). Attributes are now accessed as properties. |
| **Comment Nodes** | Represent **comments** in the HTML document (e.g., `<!-- This is a comment -->`). |

---

## **📌 Example: HTML DOM Node Tree**
Consider the following HTML:

```html



    <div id=""container"">
        <p>Hello World!</p>
    </div>


```

The **DOM node tree** for this document:

```
Document (document)
 ├──  (Element Node)
      ├──  (Element Node)
           ├── <div id=""container""> (Element Node)
                ├── <p> (Element Node)
                     ├── ""Hello World!"" (Text Node)
```
✔ The `document` is the **root node** containing **element nodes**, which contain **text nodes**.

---

## **📌 Accessing Nodes Using JavaScript**
JavaScript allows you to **traverse** the DOM and access different types of nodes.

### **Example 1: Accessing an Element Node**
```js
var element = document.getElementById(""container"");
console.log(element.nodeName);  // Output: DIV
console.log(element.nodeType);  // Output: 1 (Element Node)
```
✔ `nodeName` returns the **tag name**.  
✔ `nodeType` returns the **numeric node type** (`1 = Element Node`).

---

## **📌 Creating, Modifying, and Deleting Nodes**
### **Example 2: Creating and Appending a New Node**
```js
var newParagraph = document.createElement(""p""); // Create a </p><p> element
var textNode = document.createTextNode(""This is new!""); // Create a text node
newParagraph.appendChild(textNode); // Append text to </p><p>

document.getElementById(""container"").appendChild(newParagraph); // Add to </p><div>
```
✔ **Dynamically adds** `<p>This is new!</p>` inside `<div id=""container"">`.

---

### **Example 3: Removing a Node**
```js
var parent = document.getElementById(""container"");
var child = document.querySelector(""p""); // Select first <p>
parent.removeChild(child); // Remove the paragraph
```
✔ This **removes** the first `</p><p>` inside `</p><div id=""container"">`.

---

## **📌 Special Nodes: Comments and Attributes**
### **Example 4: Adding a Comment Node**
```js
var comment = document.createComment(""This is a comment"");
document.body.appendChild(comment);
```
✔ Creates and **appends a comment** (`<!-- This is a comment -->`) inside ``.

### **Example 5: Modifying an Attribute Node (Modern Approach)**
```js
document.getElementById(""container"").setAttribute(""class"", ""newClass"");
```
✔ **Sets the `class` attribute** on `<div id=""container"">`.

---

## **📌 Summary**
| **Node Type** | **Example** | **JavaScript Access** |
|--------------|------------|----------------------|
| **Document Node** | The entire page | `document` |
| **Element Node** | `<p>`, `</p><div>` | `document.getElementById(""id"")` |
| **Text Node** | `""Hello World""` inside `<p>` | `.textContent` |
| **Attribute Node** | `class=""example""` (**deprecated**) | `.setAttribute(""class"", ""newClass"")` |
| **Comment Node** | `<!-- Comment -->` | `document.createComment(""text"")` |

🚀 **Understanding the HTML DOM Node Tree allows full control over web page structure using JavaScript!**</p></div></div></div></div></div></div></h1></div>"		
187	DOM navigation	Node Relationships	"### **Understanding Parent, Child, and Sibling Nodes in the HTML DOM Tree**

In the **DOM (Document Object Model)**, elements are arranged in a **hierarchical tree structure**, where each element is related to others through **parent-child** and **sibling** relationships.

---

## **📌 DOM Node Relationships**
| **Term** | **Description** |
|----------|---------------|
| **Root Node** | The **top node** of the document tree (``). |
| **Parent Node** | A node **that contains other nodes** inside it. |
| **Child Nodes** | Nodes **directly inside** a parent node. |
| **Sibling Nodes** | Nodes **on the same level**, sharing the same parent. |

---

## **📌 Example: DOM Tree Structure**
### **HTML Code**
```html


    
        <title>DOM Tutorial</title>
    
    
        <h1>DOM Lesson one</h1>
        <p>Hello world!</p>
    

```
### **DOM Hierarchy Representation**
```
Document (document)
 ├──  (Root Node)
      ├──  (Child of )
      │    ├── <title> (Child of &lt;head&gt;)
      │         ├── ""DOM Tutorial"" (Text Node)
      ├── &lt;body&gt; (Child of &lt;html&gt;)
           ├── &lt;h1&gt; (Child of &lt;body&gt;)
           │    ├── ""DOM Lesson one"" (Text Node)
           ├── &lt;p&gt; (Child of &lt;body&gt;)
                ├── ""Hello world!"" (Text Node)
```

---

## **📌 Understanding the Node Relationships**
- **`&lt;html&gt;` is the root node** and has **two children**: `&lt;head&gt;` and `&lt;body&gt;`.
- **`&lt;head&gt;` has one child**: `&lt;title&gt;`.
- **`&lt;title&gt;` has one text child**: `""DOM Tutorial""`.
- **`&lt;body&gt;` has two children**: `&lt;h1&gt;` and `&lt;p&gt;`.
- **`&lt;h1&gt;` has one text child**: `""DOM Lesson one""`.
- **`&lt;p&gt;` has one text child**: `""Hello world!""`.
- **`&lt;h1&gt;` and `&lt;p&gt;` are siblings**, sharing `&lt;body&gt;` as their parent.

---

## **📌 JavaScript Methods for Traversing the DOM**
You can **navigate the DOM tree** using various properties.

| **Property** | **Description** |
|-------------|----------------|
| `element.parentNode` | Returns the **parent node** of an element. |
| `element.childNodes` | Returns a **NodeList** of an element's children (including text nodes). |
| `element.children` | Returns a **collection of child elements** (ignores text nodes). |
| `element.firstChild` | Returns the **first child** (includes text nodes). |
| `element.firstElementChild` | Returns the **first child element** (excludes text nodes). |
| `element.lastChild` | Returns the **last child** (includes text nodes). |
| `element.lastElementChild` | Returns the **last child element** (excludes text nodes). |
| `element.nextSibling` | Returns the **next sibling** (includes text nodes). |
| `element.nextElementSibling` | Returns the **next sibling element** (excludes text nodes). |
| `element.previousSibling` | Returns the **previous sibling** (includes text nodes). |
| `element.previousElementSibling` | Returns the **previous sibling element** (excludes text nodes). |

---

## **📌 Example 1: Getting the Parent Node**
```html
&lt;p id=""myParagraph""&gt;Hello World!&lt;/p&gt;

&lt;script&gt;
let p = document.getElementById(""myParagraph"");
console.log(p.parentNode.nodeName); // Output: BODY
&lt;/script&gt;
```
✔ Returns `""BODY""` because `&lt;p&gt;` is inside `&lt;body&gt;`.

---

## **📌 Example 2: Getting All Child Elements**
```html
&lt;div id=""container""&gt;
    &lt;p&gt;First paragraph&lt;/p&gt;
    &lt;p&gt;Second paragraph&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
let container = document.getElementById(""container"");
console.log(container.children.length);  // Output: 2
console.log(container.firstElementChild.innerHTML); // Output: ""First paragraph""
console.log(container.lastElementChild.innerHTML);  // Output: ""Second paragraph""
&lt;/script&gt;
```
✔ **`children` ignores text nodes** and only counts actual elements.

---

## **📌 Example 3: Getting Sibling Nodes**
```html
&lt;h1 id=""heading""&gt;Heading&lt;/h1&gt;
&lt;p&gt;Paragraph 1&lt;/p&gt;
&lt;p id=""target""&gt;Paragraph 2&lt;/p&gt;

&lt;script&gt;
let p2 = document.getElementById(""target"");
console.log(p2.previousElementSibling.nodeName); // Output: ""P""
&lt;/script&gt;
```
✔ Finds the **previous sibling** of `&lt;p id=""target""&gt;`, which is another `&lt;p&gt;`.

---

## **📌 Summary**
| **Concept** | **Example Usage** |
|-------------|----------------|
| **Get Parent Node** | `element.parentNode` |
| **Get Child Nodes** | `element.childNodes` (includes text) |
| **Get Child Elements** | `element.children` (only elements) |
| **Get First Child** | `element.firstChild` / `element.firstElementChild` |
| **Get Last Child** | `element.lastChild` / `element.lastElementChild` |
| **Get Next Sibling** | `element.nextSibling` / `element.nextElementSibling` |
| **Get Previous Sibling** | `element.previousSibling` / `element.previousElementSibling` |

🚀 **Mastering the DOM hierarchy allows you to manipulate and traverse the document effectively!**&lt;/body&gt;&lt;/html&gt;</title>"		
188	DOM navigation	Navigating Between Nodes	"### **Navigating the DOM Using Node Properties in JavaScript**

The HTML **DOM (Document Object Model)** provides several **node properties** that allow you to **traverse the node tree** and access elements dynamically.

---

## **📌 Node Properties for Traversing the DOM**
| **Property** | **Description** |
|-------------|----------------|
| `parentNode` | Returns the **parent node** of an element. |
| `childNodes[nodenumber]` | Returns a **NodeList** of all child nodes (including text nodes). |
| `firstChild` | Returns the **first child node** (including text nodes). |
| `lastChild` | Returns the **last child node** (including text nodes). |
| `nextSibling` | Returns the **next sibling node** (including text nodes). |
| `previousSibling` | Returns the **previous sibling node** (including text nodes). |

**Important:** `childNodes`, `firstChild`, `lastChild`, `nextSibling`, and `previousSibling` include **text nodes** (whitespace between elements is counted as a text node).

To work only with **elements**, use:
- `children` instead of `childNodes`
- `firstElementChild` instead of `firstChild`
- `lastElementChild` instead of `lastChild`
- `nextElementSibling` instead of `nextSibling`
- `previousElementSibling` instead of `previousSibling`

---

## **📌 Example: Basic HTML Structure**
```html




<div id=""container"">
    <h2>Title</h2>
    <p>First paragraph</p>
    <p id=""target"">Second paragraph</p>
    <p>Third paragraph</p>
</div>



```
---

## **📌 Example 1: Getting the Parent Node**
```js
let target = document.getElementById(""target"");
console.log(target.parentNode.nodeName); // Output: DIV
```
✔ Returns `""DIV""` because `<p>` is inside `</p><div id=""container"">`.

---

## **📌 Example 2: Accessing Child Nodes**
```js
let container = document.getElementById(""container"");
console.log(container.childNodes.length); // Output: Number of all child nodes (including text)
console.log(container.childNodes[1].nodeName); // Output: ""H2""
```
✔ `childNodes` includes **text nodes**, so the actual elements may not be at expected indexes.

**Use `children` to get only elements**:
```js
console.log(container.children.length); // Output: 3 (Only elements)
console.log(container.children[0].nodeName); // Output: ""H2""
```

---

## **📌 Example 3: Getting the First and Last Child**
```js
console.log(container.firstChild.nodeName); // Output: #text (due to whitespace)
console.log(container.lastChild.nodeName); // Output: #text (due to whitespace)
```
✔ **Use `firstElementChild` and `lastElementChild` to ignore text nodes**:
```js
console.log(container.firstElementChild.nodeName); // Output: ""H2""
console.log(container.lastElementChild.nodeName); // Output: ""P""
```

---

## **📌 Example 4: Getting Next and Previous Sibling**
```js
let target = document.getElementById(""target"");
console.log(target.nextSibling.nodeName); // Output: #text (whitespace)
console.log(target.previousSibling.nodeName); // Output: #text (whitespace)
```
✔ **Use `nextElementSibling` and `previousElementSibling` to skip text nodes**:
```js
console.log(target.nextElementSibling.nodeName); // Output: ""P""
console.log(target.previousElementSibling.nodeName); // Output: ""P""
```

---

## **📌 Summary**
| **Method** | **Includes Text Nodes?** | **Example Usage** |
|------------|----------------|-------------|
| `parentNode` | No | `element.parentNode` |
| `childNodes[n]` | ✅ Yes | `element.childNodes[1]` |
| `firstChild` | ✅ Yes | `element.firstChild` |
| `lastChild` | ✅ Yes | `element.lastChild` |
| `nextSibling` | ✅ Yes | `element.nextSibling` |
| `previousSibling` | ✅ Yes | `element.previousSibling` |
| `children` | ❌ No (Only elements) | `element.children[1]` |
| `firstElementChild` | ❌ No | `element.firstElementChild` |
| `lastElementChild` | ❌ No | `element.lastElementChild` |
| `nextElementSibling` | ❌ No | `element.nextElementSibling` |
| `previousElementSibling` | ❌ No | `element.previousElementSibling` |

🚀 **Understanding DOM navigation helps in dynamically modifying and interacting with HTML elements efficiently!**</div>"		
189	DOM navigation	Child Nodes and Node Values	"### **Understanding Text Nodes in the DOM and How to Access Text Content**

A **common mistake** in DOM processing is assuming that an **element node** directly contains text. In reality:
✔ **An element node (`<title>`, `&lt;p&gt;`, `&lt;h1&gt;`, etc.) contains a text node.**  
✔ **The actual text is stored inside a `text node` as its child.**  

---

## **📌 Example: Understanding Text Nodes**
Consider the following HTML:
```html
&lt;title id=""demo""&gt;DOM Tutorial</title>
```
Here, `<title>` is an **element node**, but `""DOM Tutorial""` is a **text node** inside it.

The **DOM structure looks like this:**
```
&lt;title&gt; (Element Node)
 ├── ""DOM Tutorial"" (Text Node)
```

---

## **📌 How to Access the Text Node Value**
| **Method** | **Description** | **Example** |
|------------|----------------|-------------|
| `element.innerHTML` | Retrieves the inner HTML content (text included). | `element.innerHTML` |
| `element.firstChild.nodeValue` | Retrieves the **text content** inside the first child (text node). | `element.firstChild.nodeValue` |
| `element.childNodes[0].nodeValue` | Another way to get the **first text node** content. | `element.childNodes[0].nodeValue` |

---

## **📌 Example 1: Accessing the Text Content**
```html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title id=""demo""&gt;DOM Tutorial</title>



<p id=""output""></p>





```
✔ **Retrieves `""DOM Tutorial""` using `innerHTML` and displays it inside `<p>`**.

---

## **📌 Example 2: Using `firstChild.nodeValue`**
```js
var myTitle = document.getElementById(""demo"").firstChild.nodeValue;
console.log(myTitle); // Output: ""DOM Tutorial""
```
✔ This **accesses the text node's value directly**.

---

## **📌 Example 3: Using `childNodes[0].nodeValue`**
```js
var myTitle = document.getElementById(""demo"").childNodes[0].nodeValue;
console.log(myTitle); // Output: ""DOM Tutorial""
```
✔ This **accesses the first child node**, which is the **text node**.

---

## **📌 Why Use `firstChild.nodeValue` Instead of `innerHTML`?**
| **Method** | **Best Use Case** |
|------------|------------------|
| `innerHTML` | When working with **both text and HTML elements inside an element**. |
| `firstChild.nodeValue` | When **you specifically want the text content only** (avoids reading HTML tags). |
| `childNodes[0].nodeValue` | Alternative way to access the first child text node. |

🚀 **Understanding text nodes in the DOM helps avoid errors when extracting text content dynamically!**</p>"		
190	DOM navigation	DOM Root Nodes	"### **Accessing the Full Document Using `document.body` and `document.documentElement`**

JavaScript provides **two special properties** that allow access to different parts of an HTML document:

| **Property** | **Description** |
|-------------|----------------|
| `document.body` | Returns the `` element (excluding ``). |
| `document.documentElement` | Returns the **entire document**, including ``. |

---

## **📌 Example: Accessing the ``**
```html



    <title>DOM Example</title>



<p id=""demo""></p>





```
✔ Retrieves **everything inside ``**, including elements and text.

---

## **📌 Example: Accessing the Entire Document (``)**
```js
console.log(document.documentElement.innerHTML);
```
✔ Logs the **entire HTML document**, including `` and ``.

---

## **📌 Example: Modifying the Body**
```js
document.body.style.backgroundColor = ""lightblue"";
```
✔ Changes the **background color** of the whole page.

---

## **📌 Example: Getting the Page Scroll Position**
These properties are useful when handling **scroll events**.

```js
console.log(""Page Scroll Y:"", document.documentElement.scrollTop);  // Scroll position (Y-axis)
console.log(""Page Height:"", document.documentElement.scrollHeight);  // Full height of document
```
✔ Useful for **infinite scrolling** or **detecting when the user reaches the bottom** of a page.

---

## **📌 Summary**
| **Property** | **Description** | **Example** |
|-------------|----------------|-------------|
| `document.body` | Accesses the **``** element only. | `document.body.innerHTML` |
| `document.documentElement` | Accesses the **entire document (``)**. | `document.documentElement.innerHTML` |
| `.scrollTop` | Gets **vertical scroll position**. | `document.documentElement.scrollTop` |
| `.scrollHeight` | Gets **total height of document**. | `document.documentElement.scrollHeight` |

🚀 **Using `document.body` and `document.documentElement` allows you to manipulate and interact with the full webpage dynamically!**"		
191	DOM navigation	The nodeName Property	"### **Understanding the `nodeName` Property in JavaScript**

The **`nodeName`** property returns the **name of a node** and is **read-only**. It helps identify different types of nodes in the **DOM (Document Object Model)**.

---

## **📌 Key Points About `nodeName`**
| **Node Type** | **Returned Value** |
|--------------|----------------|
| **Element Node** (`<h1>`, `<p>`) | Returns the **uppercase tag name** (e.g., `""H1""`, `""P""`). |
| **Attribute Node** (`id=""example""`) | Returns the **attribute name** (e.g., `""id""`). |
| **Text Node** (`""Hello World""`) | Always returns `""#text""`. |
| **Document Node** (`document`) | Always returns `""#document""`. |

---

## **📌 Example 1: Getting the Node Name of an HTML Element**
```html




</p></h1><h1 id=""title"">My First Page</h1>
<p id=""output""></p>





```
✔ **Displays `""Node Name: H1""`**, since `nodeName` returns the **tag name in uppercase**.

---

## **📌 Example 2: Getting the Node Name of a Text Node**
```html
<p id=""textNode"">Hello World!</p>
<p id=""output""></p>


```
✔ Returns `""Node Name: #text""`, since the **text inside a `<p>` is a text node**.

---

## **📌 Example 3: Getting the Node Name of the Document**
```html
</p><p id=""output""></p>


```
✔ Returns `""Node Name: #document""` because `document` is the **root node**.

---

## **📌 Example 4: Getting the Node Name of an Attribute**
```html
<p id=""myPara"" class=""example"">Hello</p>
<p id=""output""></p>


```
✔ Returns `""Node Name: class""`, since `nodeName` of an attribute returns **the attribute name**.

---

## **📌 Summary**
| **Node Type** | **Example** | **Returned `nodeName`** |
|--------------|------------|----------------|
| **Element Node** | `<h1>` | `""H1""` |
| **Attribute Node** | `class=""example""` | `""class""` |
| **Text Node** | `""Hello World!""` inside `<p>` | `""#text""` |
| **Document Node** | `document` | `""#document""` |

🚀 **Understanding `nodeName` helps in dynamically checking node types when working with the DOM!**</p></h1>"		
192	DOM navigation	The nodeValue Property	"### **Understanding the `nodeValue` Property in JavaScript**

The **`nodeValue`** property returns the **value of a node**. It behaves differently based on the **node type**.

---

## **📌 Key Points About `nodeValue`**
| **Node Type** | **Returned Value (`nodeValue`)** |
|--------------|-------------------------------|
| **Element Node** (`<p>`, `</p><h1>`) | `null` (Elements do not have values) |
| **Text Node** (`""Hello World""`) | The **text content** of the node |
| **Attribute Node** (`id=""example""`) | The **attribute value** (`""example""`) |

---

## **📌 Example 1: `nodeValue` of an Element Node**
```html
<p id=""myPara"">Hello World!</p>
<p id=""output""></p>


```
✔ **Returns `""Node Value: null""`** because **element nodes do not have a value**.

---

## **📌 Example 2: `nodeValue` of a Text Node**
```html
<p id=""myPara"">Hello World!</p>
<p id=""output""></p>


```
✔ **Returns `""Node Value: Hello World!""`** because **text nodes contain the actual text content**.

---

## **📌 Example 3: `nodeValue` of an Attribute Node**
```html
<p id=""myPara"" class=""example"">Hello</p>
<p id=""output""></p>


```
✔ **Returns `""Node Value: example""`** because **attribute nodes return the attribute's value**.

---

## **📌 Summary**
| **Node Type** | **Example** | **Returned `nodeValue`** |
|--------------|------------|----------------|
| **Element Node** | `<p>Hello</p>` | `null` |
| **Text Node** | `""Hello World!""` inside `<p>` | `""Hello World!""` |
| **Attribute Node** | `class=""example""` | `""example""` |

🚀 **Understanding `nodeValue` helps in dynamically retrieving text and attribute values when working with the DOM!**</p></h1>"		
193	DOM navigation	The nodeType Property	"### **Understanding the `nodeType` Property in JavaScript**

The **`nodeType`** property is **read-only** and returns a **numeric value** representing the type of a node. This helps in **differentiating between elements, text, comments, and document nodes**.

---

## **📌 Example: Checking the `nodeType` of an Element Node**
```html




<h1 id=""id01"">My First Page</h1>
<p id=""id02""></p>





```
✔ **Displays `""Node Type: 1""`**, since `<h1>` is an **element node (`1`)**.

---

## **📌 `nodeType` Values**
| **Type** | **Node Type** | **Example** |
|----------|-------------|-------------|
| **1** | **ELEMENT_NODE** | `</h1><h1>Title</h1>` |
| **2** (Deprecated) | **ATTRIBUTE_NODE** | `class=""heading""` |
| **3** | **TEXT_NODE** | `""Hello World!""` inside `<p>` |
| **8** | **COMMENT_NODE** | `<!-- This is a comment -->` |
| **9** | **DOCUMENT_NODE** | The entire **HTML document (`document`)** |
| **10** | **DOCUMENT_TYPE_NODE** | `` |

🚨 **Type 2 (ATTRIBUTE_NODE) is deprecated in the HTML DOM but still used in the XML DOM.**

---

## **📌 Example 1: Checking `nodeType` for Different Nodes**
```html




</p><h1 id=""title"">DOM Example</h1>
<p id=""output""></p>





```
✔ Returns:
```
Element Node Type: 1
Text Node Type: 3
Document Node Type: 9
```
---

## **📌 Example 2: Checking a Comment Node**
```html




<!-- This is a comment -->
<p id=""output""></p>





```
✔ Returns **""Comment Node Type: 8""**.

---

## **📌 Summary**
| **Node Type** | **Example** | **Returns (`nodeType`)** |
|--------------|------------|-----------------|
| **Element Node** | `<h1>Title</h1>` | `1` |
| **Attribute Node** (Deprecated) | `class=""heading""` | `2` |
| **Text Node** | `""Hello World!""` inside `<p>` | `3` |
| **Comment Node** | `<!-- Comment -->` | `8` |
| **Document Node** | `document` | `9` |
| **Document Type Node** | `` | `10` |

🚀 **Using `nodeType` helps identify different node types while working with the DOM dynamically!**</p>"		
194	DOM nodes	Creating New HTML Elements (Nodes)	"### **Creating and Appending New Elements in the DOM Using JavaScript**

JavaScript allows you to **dynamically create new elements**, add text to them, and insert them into an existing HTML document. This is useful for dynamically updating content without modifying the original HTML.

---

## **📌 Steps to Create and Append an Element**
1️⃣ **Create a new element** → `document.createElement(""tag"")`  
2️⃣ **Create a text node** → `document.createTextNode(""text content"")`  
3️⃣ **Append the text node to the new element** → `element.appendChild(textNode)`  
4️⃣ **Append the new element to an existing element** → `parent.appendChild(newElement)`

---

## **📌 Example 1: Creating and Adding a New `<p>` Element**
```html




</p><div id=""div1"">This is a container.</div>
<button onclick=""addParagraph()"">Add Paragraph</button>





```
✔ Clicking the **""Add Paragraph""** button inserts **`<p>This is a new paragraph.</p>`** inside `<div id=""div1"">`.

---

## **📌 Example 2: Adding Multiple Elements Dynamically**
You can create multiple elements dynamically and add them to an existing container.

```html




<ul id=""myList"">
    <li>Item 1</li>
    <li>Item 2</li>
</ul>
<button onclick=""addListItem()"">Add List Item</button>





```
✔ Clicking **""Add List Item""** dynamically adds a new `<li>` inside `<ul id=""myList"">`.

---

## **📌 Example 3: Removing an Element Dynamically**
To remove an element, use **`removeChild()`**.

```html
<button onclick=""removeLastItem()"">Remove Last Item</button>


```
✔ Clicking **""Remove Last Item""** deletes the last `<li>` inside `<ul id=""myList"">`.

---

## **📌 Summary**
| **Action** | **JavaScript Code** |
|------------|------------------|
| **Create a new element** | `var newElement = document.createElement(""tag"");` |
| **Create a text node** | `var textNode = document.createTextNode(""text"");` |
| **Append text to an element** | `newElement.appendChild(textNode);` |
| **Find an existing element** | `var element = document.getElementById(""id"");` |
| **Append the new element** | `element.appendChild(newElement);` |
| **Remove an element** | `element.removeChild(childElement);` |

🚀 **Using `createElement()` and `appendChild()` enables dynamic content creation in JavaScript, making web pages more interactive!**</ul></li></ul></li></div>"		
195	DOM nodes	Creating new HTML Elements - insertBefore()	"### **Using `insertBefore()` to Insert Elements in JavaScript**

By default, **`appendChild()`** adds a new element **as the last child** of a parent.  
If you want to insert an element **before an existing element**, use **`insertBefore(newElement, referenceElement)`**.

---

## **📌 Syntax**
```js
parentElement.insertBefore(newElement, referenceElement);
```
- **`parentElement`** → The element containing the new and reference elements.
- **`newElement`** → The element you want to insert.
- **`referenceElement`** → The element before which the new element is inserted.

---

## **📌 Example 1: Inserting an Element Before an Existing Element**
```html




<div id=""div1"">
    <p id=""p1"">This is a paragraph.</p>
    <p id=""p2"">This is another paragraph.</p>
</div>
<button onclick=""insertParagraph()"">Insert Before First Paragraph</button>





```
✔ Clicking **""Insert Before First Paragraph""** inserts `""This is new.""` **before** the first `<p>` inside `</p><div>`.

---

## **📌 Example 2: Inserting a List Item at a Specific Position**
```html




<ul id=""myList"">
    <li id=""item1"">Item 1</li>
    <li id=""item2"">Item 2</li>
</ul>
<button onclick=""insertListItem()"">Insert Before Item 2</button>





```
✔ Clicking **""Insert Before Item 2""** inserts `""New Item""` **before** `""Item 2""` in the list.

---

## **📌 Example 3: Inserting an Element at the Beginning**
If you want to insert a new element **at the beginning of a parent**, use:
```js
parentElement.insertBefore(newElement, parentElement.firstChild);
```
✔ This ensures that the **new element is always the first child**.

---

## **📌 Summary**
| **Method** | **Action** | **Example** |
|------------|------------|-------------|
| `appendChild(newElement)` | Adds **as the last child** | `parent.appendChild(newElement);` |
| `insertBefore(newElement, referenceElement)` | Inserts **before an existing element** | `parent.insertBefore(newElement, reference);` |

🚀 **Using `insertBefore()` allows precise control over where new elements are added dynamically!**</div>"		
196	DOM nodes	Removing Existing HTML Elements	"### **Removing an HTML Element Using `removeChild()` in JavaScript**

To remove an HTML element dynamically, you need to:
1. **Select the parent element** that contains the child.
2. **Select the child element** that needs to be removed.
3. **Use `removeChild(childElement)`** on the parent.

---

## **📌 Syntax**
```js
parentElement.removeChild(childElement);
```
- **`parentElement`** → The element containing the child.
- **`childElement`** → The element to be removed.

---

## **📌 Example 1: Removing a Paragraph Dynamically**
```html




<div id=""div1"">
    <p id=""p1"">This is a paragraph.</p>
    <p id=""p2"">This is another paragraph.</p>
</div>
<button onclick=""removeParagraph()"">Remove First Paragraph</button>





```
✔ Clicking **""Remove First Paragraph""** deletes **`<p id=""p1"">`**.

---

## **📌 Example 2: Removing List Items**
```html




</p><ul id=""myList"">
    <li id=""item1"">Item 1</li>
    <li id=""item2"">Item 2</li>
    <li id=""item3"">Item 3</li>
</ul>
<button onclick=""removeItem()"">Remove Last Item</button>





```
✔ Clicking **""Remove Last Item""** removes the last `<li>` inside `<ul>`.

---

## **📌 Example 3: Removing an Element Using `remove()`**
Instead of `removeChild()`, you can directly use `.remove()`.

```js
document.getElementById(""p1"").remove(); // Removes <p id=""p1"">
```
✔ No need to reference the **parent element**.

---

## **📌 Summary**
| **Method** | **Action** | **Example** |
|------------|-----------|-------------|
| `parent.removeChild(child)` | Removes a specific child from the parent | `parent.removeChild(child);` |
| `element.remove()` | Removes the element itself | `element.remove();` |

🚀 **Using `removeChild()` and `remove()` allows dynamic element removal, making web pages interactive!**</p></ul></li>"		
197	DOM nodes	Replacing HTML Elements	"### **Replacing an HTML Element Using `replaceChild()` in JavaScript**

The **`replaceChild()`** method allows you to replace an **existing child element** with a **new element** dynamically.

---

## **📌 Syntax**
```js
parentElement.replaceChild(newChild, oldChild);
```
- **`parentElement`** → The element that contains the child.
- **`newChild`** → The new element that will replace the existing child.
- **`oldChild`** → The existing element to be replaced.

---

## **📌 Example 1: Replacing a Paragraph Dynamically**
```html




<div id=""div1"">
    <p id=""p1"">This is a paragraph.</p>
</div>
<button onclick=""replaceParagraph()"">Replace Paragraph</button>





```
✔ Clicking **""Replace Paragraph""** replaces **`<p id=""p1"">`** with **new content**.

---

## **📌 Example 2: Replacing a List Item**
```html




</p><ul id=""myList"">
    <li id=""item1"">Item 1</li>
    <li id=""item2"">Item 2</li>
</ul>
<button onclick=""replaceItem()"">Replace First Item</button>





```
✔ Clicking **""Replace First Item""** replaces `""Item 1""` with `""New Item""`.

---

## **📌 Summary**
| **Method** | **Action** | **Example** |
|------------|-----------|-------------|
| `parent.replaceChild(newChild, oldChild)` | Replaces a child element | `parent.replaceChild(newElement, oldElement);` |

🚀 **Using `replaceChild()` allows dynamic content updates, improving interactivity and user experience!**"		
198	DOM collections	The HTMLCollection Object	"### **Understanding `getElementsByTagName()` and `HTMLCollection` in JavaScript**

The **`getElementsByTagName()`** method returns an **HTMLCollection**, which is an **array-like list** of elements matching the specified tag name.

---

## **📌 Key Features of `HTMLCollection`**
✔ **Live Collection** → Automatically updates if elements are added/removed.  
✔ **Indexed Access** → Elements can be accessed using `collection[index]`.  
✔ **Looping** → Can be looped using `for` or `forEach` (after converting to an array).

---

## **📌 Example 1: Selecting All `<p>` Elements**
```html




</p><p>Paragraph 1</p>
<p>Paragraph 2</p>
<p>Paragraph 3</p>

<button onclick=""changeText()"">Change Second Paragraph</button>





```
✔ Clicking **""Change Second Paragraph""** updates the **second `<p>`**.

---

## **📌 Example 2: Looping Through `HTMLCollection`**
```html




</p><p>Item 1</p>
<p>Item 2</p>
<p>Item 3</p>

<button onclick=""highlightText()"">Highlight All</button>





```
✔ Clicking **""Highlight All""** changes **background color for all `<p>` elements**.

---

## **📌 Example 3: Converting `HTMLCollection` to an Array**
Since `HTMLCollection` **does not support `forEach()`**, you need to **convert it into an array** first.

```js
var elements = Array.from(document.getElementsByTagName(""p""));
elements.forEach(el =&gt; el.style.color = ""blue"");
```
✔ Changes **text color of all `</p><p>` elements to blue**.

---

## **📌 Summary**
| **Method** | **Returns** | **Supports `forEach()`?** |
|------------|------------|----------------|
| `getElementsByTagName(""p"")` | **HTMLCollection** (Live) | ❌ No (Convert to array first) |
| `querySelectorAll(""p"")` | **NodeList** (Static) | ✅ Yes |

🚀 **Using `getElementsByTagName()` allows you to efficiently select and modify multiple elements dynamically!**</p>"		
199	DOM collections	HTML HTMLCollection Length	"### **Using the `length` Property with `HTMLCollection` in JavaScript**

The **`length`** property returns the **number of elements** in an **`HTMLCollection`**, which is a list of elements retrieved by methods like `getElementsByTagName()` and `getElementsByClassName()`.

---

## **📌 Syntax**
```js
var elements = document.getElementsByTagName(""p"");
console.log(elements.length); // Outputs the number of <p> elements
```
✔ This returns the **total number of `</p><p>` elements** in the document.

---

## **📌 Example 1: Counting Elements in an `HTMLCollection`**
```html




</p><p>Paragraph 1</p>
<p>Paragraph 2</p>
<p>Paragraph 3</p>

<button onclick=""countParagraphs()"">Count Paragraphs</button>
<p id=""output""></p>





```
✔ Clicking **""Count Paragraphs""** displays the **total number of `<p>` elements**.

---

## **📌 Example 2: Looping Through `HTMLCollection` Using `length`**
```html




</p><div class=""box"">Box 1</div>
<div class=""box"">Box 2</div>
<div class=""box"">Box 3</div>

<button onclick=""highlightBoxes()"">Highlight Boxes</button>





```
✔ Clicking **""Highlight Boxes""** changes the **background color of all `.box` elements**.

---

## **📌 Example 3: Checking If Any Elements Exist**
```js
var items = document.getElementsByTagName(""li"");

if (items.length &gt; 0) {
    console.log(""List items found: "" + items.length);
} else {
    console.log(""No list items found."");
}
```
✔ Prevents errors by **checking if elements exist before accessing them**.

---

## **📌 Summary**
| **Property** | **Description** | **Example** |
|-------------|----------------|-------------|
| `.length` | Returns the **number of elements** in an `HTMLCollection`. | `document.getElementsByTagName(""p"").length;` |

🚀 **Using `length` with `HTMLCollection` helps in looping and dynamically counting elements!**"		
200	DOM collections	An HTMLCollection is NOT an array!	"### **Understanding `HTMLCollection` and Its Limitations Compared to Arrays**

An **`HTMLCollection`** is **not an array**, but it behaves **like an array** in some ways:
✔ **You can loop through it using a `for` loop**.  
✔ **You can access elements using an index (`collection[index]`)**.  
❌ **You cannot use array methods like `push()`, `pop()`, or `join()` directly**.  

---

## **📌 Example 1: Looping Through an `HTMLCollection`**
```html




<p>Item 1</p>
<p>Item 2</p>
<p>Item 3</p>

<button onclick=""showElements()"">Show Elements</button>
<p id=""output""></p>





```
✔ Clicking **""Show Elements""** lists all `<p>` elements dynamically.

---

## **📌 Example 2: Converting `HTMLCollection` to an Array**
Since `HTMLCollection` **does not support array methods**, you can **convert it to an array** using `Array.from()`.

```html




</p><div class=""box"">Box 1</div>
<div class=""box"">Box 2</div>
<div class=""box"">Box 3</div>

<button onclick=""convertToArray()"">Convert &amp; Modify</button>





```
✔ Converts `HTMLCollection` to an **array**, allowing **`forEach()` and other array methods**.

---

## **📌 Example 3: `HTMLCollection` Does Not Support Array Methods**
```js
var items = document.getElementsByTagName(""p"");

// ❌ This will NOT work:
items.push(""New Item"");  // Error: push() is not a function
items.pop();             // Error: pop() is not a function
items.join("", "");        // Error: join() is not a function
```
✔ **Convert to an array before using array methods:**
```js
var itemsArray = Array.from(items);
itemsArray.push(""New Item"");
console.log(itemsArray.join("", ""));
```

---

## **📌 Summary**
| **Feature** | **`HTMLCollection`** | **Array** |
|------------|----------------|------------|
| Indexed Access (`collection[0]`) | ✅ Yes | ✅ Yes |
| Looping (`for` or `forEach`) | ✅ Yes (for loop) ❌ No (`forEach` without conversion) | ✅ Yes |
| Array Methods (`push()`, `pop()`, `join()`) | ❌ No | ✅ Yes |
| Conversion to Array | ✅ Use `Array.from()` | N/A |

🚀 **Convert `HTMLCollection` to an array when you need advanced array methods!**"		
201	DOM node list	The HTML DOM NodeList Object	"### **Understanding `NodeList` in JavaScript**

A **`NodeList`** is a **collection of nodes** extracted from an HTML document. It is **similar to an `HTMLCollection`**, but with key differences.

---

## **📌 Key Differences Between `NodeList` and `HTMLCollection`**
| Feature | `NodeList` | `HTMLCollection` |
|------------|--------------|----------------|
| **Returned by** | `querySelectorAll()`, `childNodes` | `getElementsByTagName()`, `getElementsByClassName()` |
| **Supports `forEach()`** | ✅ Yes (except in very old browsers) | ❌ No |
| **Live Collection?** | ❌ No (Static) | ✅ Yes (Updates dynamically) |
| **Indexed Access (`[i]`)** | ✅ Yes | ✅ Yes |
| **Convert to Array?** | ✅ Yes, use `Array.from()` | ✅ Yes, use `Array.from()` |

🚀 **`NodeList` is preferred when using `querySelectorAll()` because it supports `forEach()`.**

---

## **📌 Example 1: Selecting All `<p>` Elements Using `querySelectorAll()`**
```html




</p><p>Paragraph 1</p>
<p>Paragraph 2</p>
<p>Paragraph 3</p>

<button onclick=""showParagraphs()"">Show Paragraphs</button>
<p id=""output""></p>





```
✔ Clicking **""Show Paragraphs""** displays the **total number of `<p>` elements**.

---

## **📌 Example 2: Accessing a Specific Node Using an Index**
```js
var myNodeList = document.querySelectorAll(""p"");
console.log(myNodeList[1].innerHTML); // Output: ""Paragraph 2""
```
✔ `myNodeList[1]` **selects the second `</p><p>` node**.

---

## **📌 Example 3: Looping Through a `NodeList` Using `forEach()`**
Unlike `HTMLCollection`, `NodeList` **supports `forEach()`**.

```html




</p><div class=""box"">Box 1</div>
<div class=""box"">Box 2</div>
<div class=""box"">Box 3</div>

<button onclick=""highlightBoxes()"">Highlight Boxes</button>





```
✔ Clicking **""Highlight Boxes""** changes the **background color of all `.box` elements**.

---

## **📌 Example 4: Converting `NodeList` to an Array**
Although `NodeList` supports `forEach()`, you may need to use **array methods like `map()`**. To do this, **convert `NodeList` to an array**.

```js
var myNodeList = document.querySelectorAll(""p"");
var myArray = Array.from(myNodeList);

myArray.map(el =&gt; el.style.color = ""blue""); // Changes text color to blue
```
✔ Now we can **use array methods** like `map()`.

---

## **📌 Example 5: Difference Between `NodeList` and `HTMLCollection`**
```js
var nodelist = document.querySelectorAll(""p""); // Returns a static NodeList
var htmlCollection = document.getElementsByTagName(""p""); // Returns a live HTMLCollection

document.body.appendChild(document.createElement(""p"")); // Add a new <p>

// Check lengths after adding a new </p><p>
console.log(nodelist.length); // ❌ Stays the same (Static)
console.log(htmlCollection.length); // ✅ Updates dynamically (Live)
```
✔ **`NodeList` does NOT update when elements are added/removed**, but **`HTMLCollection` updates live**.

---

## **📌 Summary**
| Feature | `NodeList` (`querySelectorAll()`) | `HTMLCollection` (`getElementsByTagName()`) |
|------------|----------------------|------------------|
| **Supports `forEach()`** | ✅ Yes | ❌ No |
| **Live Collection?** | ❌ No (Static) | ✅ Yes (Live) |
| **Convert to Array?** | ✅ Yes (`Array.from()`) | ✅ Yes (`Array.from()`) |
| **Returned by** | `querySelectorAll()`, `childNodes` | `getElementsByTagName()`, `getElementsByClassName()` |

🚀 **Use `querySelectorAll()` (NodeList) for static selections and `getElementsByClassName()` (HTMLCollection) for live updates!**</p>"		
202	DOM node list	HTML DOM Node List Length	"### **Using the `length` Property in a `NodeList` in JavaScript**

The **`length`** property of a `NodeList` returns the **number of nodes** (elements) inside the list.

---

## **📌 Syntax**
```js
var myNodeList = document.querySelectorAll(""p"");
console.log(myNodeList.length); // Outputs the number of <p> elements
```
✔ This returns the **total number of `</p><p>` elements** in the document.

---

## **📌 Example 1: Counting Nodes in a `NodeList`**
```html




</p><p>Paragraph 1</p>
<p>Paragraph 2</p>
<p>Paragraph 3</p>

<button onclick=""countParagraphs()"">Count Paragraphs</button>
<p id=""output""></p>





```
✔ Clicking **""Count Paragraphs""** displays the **total number of `<p>` elements**.

---

## **📌 Example 2: Using `length` to Loop Through a `NodeList`**
```html




</p><div class=""box"">Box 1</div>
<div class=""box"">Box 2</div>
<div class=""box"">Box 3</div>

<button onclick=""highlightBoxes()"">Highlight Boxes</button>





```
✔ Clicking **""Highlight Boxes""** changes the **background color of all `.box` elements**.

---

## **📌 Example 3: Checking If Elements Exist**
```js
var items = document.querySelectorAll(""li"");

if (items.length &gt; 0) {
    console.log(""List items found: "" + items.length);
} else {
    console.log(""No list items found."");
}
```
✔ Prevents errors by **checking if elements exist before accessing them**.

---

## **📌 Summary**
| **Property** | **Description** | **Example** |
|-------------|----------------|-------------|
| `.length` | Returns the **number of nodes** in a `NodeList`. | `document.querySelectorAll(""p"").length;` |

🚀 **Using `length` with `NodeList` helps in dynamically counting and looping through elements!**"		
203	DOM node list	The Difference Between an HTMLCollection and a NodeList	"HTMLCollection vs. NodeList in JavaScript: Key Differences

Both HTMLCollection and NodeList are array-like collections of elements in the DOM. While they are similar, they have key differences.

📌 Key Differences Between HTMLCollection and NodeList

Feature	HTMLCollection	NodeList
Returned by	getElementsByTagName(), getElementsByClassName()	querySelectorAll(), childNodes
Access by Name or ID	✅ Yes (collection[""id""])	❌ No (Only index-based)
Supports forEach()	❌ No (Convert to array first)	✅ Yes
Live Collection?	✅ Yes (Updates dynamically)	❌ No (Static)
Contains Attribute &amp; Text Nodes?	❌ No	✅ Yes (If childNodes is used)

🚀 Use querySelectorAll() for NodeList when working with modern JavaScript!

📌 Example 1: HTMLCollection Can Be Accessed by Index, Name, or ID





<p id=""p1"">Paragraph 1</p>
<p id=""p2"">Paragraph 2</p>

<button onclick=""showParagraphs()"">Show Paragraphs</button>
<p id=""output""></p>






✔ HTMLCollection supports access by name (collection[""id""]).

📌 Example 2: NodeList Only Supports Index-Based Access





<p>Paragraph 1</p>
<p>Paragraph 2</p>






✔ NodeList only supports index-based access.

📌 Example 3: NodeList Can Contain Text Nodes (childNodes)





<div id=""container"">
    <p>First Paragraph</p>
    <!-- This is a comment -->
    <p>Second Paragraph</p>
</div>






✔ NodeList includes text nodes and comment nodes when using childNodes.

📌 Example 4: NodeList Supports forEach() But HTMLCollection Does Not

var nodeList = document.querySelectorAll(""p"");
nodeList.forEach(p =&gt; p.style.color = ""red""); // ✅ Works

var htmlCollection = document.getElementsByTagName(""p"");
htmlCollection.forEach(p =&gt; p.style.color = ""blue""); // ❌ Error (HTMLCollection does not support forEach)

✔ Convert HTMLCollection to an array before using forEach():

Array.from(htmlCollection).forEach(p =&gt; p.style.color = ""blue"");

📌 Example 5: HTMLCollection Is Live, NodeList Is Not

var collection = document.getElementsByTagName(""p""); // Live HTMLCollection
var nodeList = document.querySelectorAll(""p""); // Static NodeList

document.body.appendChild(document.createElement(""p"")); // Add new <p>

console.log(collection.length); // ✅ Updated count (Live)
console.log(nodeList.length); // ❌ Stays the same (Static)

✔ HTMLCollection updates dynamically, but NodeList remains unchanged.

📌 Summary

Feature	HTMLCollection (getElementsByTagName())	NodeList (querySelectorAll())
Supports forEach()?	❌ No (Convert first)	✅ Yes
Live Collection?	✅ Yes	❌ No
Includes Text/Comment Nodes?	❌ No	✅ Yes (with childNodes)
Access by Name or ID?	✅ Yes	❌ No

🚀 Use querySelectorAll() (NodeList) for modern static selections and getElementsByClassName() (HTMLCollection) for live updates!</p>"		
204	DOM node list	A node list is not an array!	"### **Understanding `NodeList` and Its Limitations Compared to Arrays in JavaScript**

A **`NodeList`** is **not a true array**, even though it behaves similarly in some ways:
✔ **You can loop through it using `for` or `forEach()`.**  
✔ **You can access elements using an index (`nodeList[index]`).**  
❌ **You cannot use array methods like `push()`, `pop()`, or `join()` directly.**  

---

## **📌 Example 1: Looping Through a `NodeList` Using `for`**
```html




<p>Paragraph 1</p>
<p>Paragraph 2</p>
<p>Paragraph 3</p>

<button onclick=""showParagraphs()"">Show Paragraphs</button>





```
✔ Clicking **""Show Paragraphs""** displays **the total number of `<p>` elements**.

---

## **📌 Example 2: Using `forEach()` on a `NodeList`**
Unlike `HTMLCollection`, `NodeList` **supports `forEach()`**.

```html




</p><div class=""box"">Box 1</div>
<div class=""box"">Box 2</div>
<div class=""box"">Box 3</div>

<button onclick=""highlightBoxes()"">Highlight Boxes</button>





```
✔ Clicking **""Highlight Boxes""** changes the **background color of all `.box` elements**.

---

## **📌 Example 3: `NodeList` Does Not Support Array Methods**
```js
var nodeList = document.querySelectorAll(""p"");

// ❌ These will NOT work:
nodeList.push(""New Item"");  // Error: push() is not a function
nodeList.pop();             // Error: pop() is not a function
nodeList.join("", "");        // Error: join() is not a function
```
✔ **Convert to an array before using array methods:**
```js
var array = Array.from(nodeList);
array.push(""New Item""); // ✅ Works
console.log(array.join("", "")); // ✅ Works
```

---

## **📌 Example 4: Converting `NodeList` to an Array**
If you need array methods, **convert the `NodeList` to an array**.

```js
var nodeList = document.querySelectorAll(""p"");
var myArray = Array.from(nodeList);

myArray.map(el =&gt; el.style.color = ""blue""); // ✅ Now we can use array methods like map()
```
✔ This **changes the text color of all `<p>` elements to blue**.

---

## **📌 Summary**
| **Feature** | **`NodeList`** | **Array** |
|------------|--------------|------------|
| Indexed Access (`nodeList[0]`) | ✅ Yes | ✅ Yes |
| Looping (`forEach()`, `for`) | ✅ Yes | ✅ Yes |
| Array Methods (`push()`, `pop()`, `join()`) | ❌ No | ✅ Yes |
| Conversion to Array | ✅ Use `Array.from()` | N/A |

🚀 **Convert `NodeList` to an array when you need advanced array methods!**</p>"		
205	BOM window	Definition	"The **Browser Object Model (BOM)** allows JavaScript to interact with the browser.  

There are no official standards for the BOM. However, modern browsers have implemented nearly identical methods and properties for JavaScript interactivity, which are commonly referred to as BOM methods and properties."		
206	BOM window	The Window Object	"The **window** object is a global object supported by all browsers. It represents the browser window and provides access to various browser-related functions and properties.  

### Key Features of the `window` Object:
- All **global JavaScript objects, functions, and variables** automatically become members of `window`.
- Global **variables** are stored as **properties** of `window`.
- Global **functions** are stored as **methods** of `window`.

### Example:  
The **document** object (from the HTML DOM) is a property of the `window` object:  

```javascript
window.document.getElementById(""header"");
```
This is equivalent to:  
```javascript
document.getElementById(""header"");
```

Since `window` is the global scope in browsers, referencing it is often optional."		
207	BOM window	Window Size	"Two properties can be used to determine the size of the browser’s viewport (the visible area of the webpage).  

### `window` Object Properties for Window Size:
Both properties return values in pixels:  

- **`window.innerHeight`** – The height of the browser’s viewport (excluding toolbars and scrollbars).  
- **`window.innerWidth`** – The width of the browser’s viewport (excluding toolbars and scrollbars).  

These properties measure only the **visible area** of the webpage, not including the browser's UI elements like toolbars or scrollbars."		
208	BOM window	Other Window Methods	"### Common `window` Methods  

The `window` object provides several methods to control the browser window:  

- **`window.open(url, name, specs)`** – Opens a new browser window or tab.  
  ```javascript
  window.open(""https://example.com"", ""_blank"", ""width=600,height=400"");
  ```
  *Opens a new window with a specified URL, name, and size.*  

- **`window.close()`** – Closes the current browser window.  
  ```javascript
  window.close();
  ```
  *Only works if the window was opened via JavaScript.*  

- **`window.moveTo(x, y)`** – Moves the browser window to a specific screen position.  
  ```javascript
  window.moveTo(100, 200);
  ```
  *Moves the window to coordinates (100, 200) on the screen.*  

- **`window.resizeTo(width, height)`** – Resizes the browser window to the specified dimensions.  
  ```javascript
  window.resizeTo(800, 600);
  ```
  *Resizes the window to 800x600 pixels.*  

&gt; **Note:** Modern browsers often block or limit these methods for security and usability reasons, especially when used without user interaction."		
209	BOM screen	Window Screen	"### The `window.screen` Object  

The `screen` object provides information about the user's screen and can be accessed **without** the `window` prefix.  

### Key Properties of the `screen` Object:  

- **`screen.width`** – Returns the total screen width (in pixels).  
- **`screen.height`** – Returns the total screen height (in pixels).  
- **`screen.availWidth`** – Returns the width of the screen **excluding** the taskbar or other UI elements.  
- **`screen.availHeight`** – Returns the height of the screen **excluding** the taskbar or other UI elements.  
- **`screen.colorDepth`** – Returns the number of bits used per pixel for color representation (e.g., 24 or 32).  
- **`screen.pixelDepth`** – Returns the number of bits per pixel (usually the same as `colorDepth`).  

### Example Usage:  
```javascript
console.log(""Screen Width: "" + screen.width);
console.log(""Available Height: "" + screen.availHeight);
console.log(""Color Depth: "" + screen.colorDepth);
```

&gt; **Note:** The `screen` object is **read-only**, meaning you cannot modify these values."		
210	BOM screen	Window Screen Width and height	"### `screen.width` and `screen.height`  

The **`screen.width`** and **`screen.height`** properties return the total width and height of the visitor's screen in pixels.  

### Example:  
```javascript
console.log(""Screen Width: "" + screen.width + ""px"");
console.log(""Screen Height: "" + screen.height + ""px"");
```

These values represent the **entire screen size**, including areas occupied by the taskbar or other system UI elements."		
211	BOM screen	Window Screen Available Width and Height	"### `screen.availWidth` and `screen.availHeight`  

The **`screen.availWidth`** and **`screen.availHeight`** properties return the width and height of the visitor's screen **excluding** interface elements like the taskbar or dock.  

### Example:  
```javascript
console.log(""Available Screen Width: "" + screen.availWidth + ""px"");
console.log(""Available Screen Height: "" + screen.availHeight + ""px"");
```

These values represent the **usable screen area** for the browser window, accounting for system UI elements."		
212	BOM location	Window Location	"### The `window.location` Object  

The `location` object provides information about the current page's URL and allows navigation to a new page. It can be used **without** the `window` prefix.  

### Common `location` Properties and Methods  

- **`location.href`** – Returns the full URL of the current page.  
  ```javascript
  console.log(location.href); // Example: ""https://example.com/page.html""
  ```

- **`location.hostname`** – Returns the domain name of the web host.  
  ```javascript
  console.log(location.hostname); // Example: ""example.com""
  ```

- **`location.pathname`** – Returns the path and filename of the current page.  
  ```javascript
  console.log(location.pathname); // Example: ""/page.html""
  ```

- **`location.protocol`** – Returns the web protocol used (`http:` or `https:`).  
  ```javascript
  console.log(location.protocol); // Example: ""https:""
  ```

- **`location.assign(url)`** – Loads a new page.  
  ```javascript
  location.assign(""https://example.com""); // Redirects the browser
  ```

&gt; **Note:** `location.assign()` functions similarly to setting `location.href`, but using `assign()` allows navigation history tracking."		
213	BOM location	Window Location Href	"### `window.location.href` – Get the Current Page URL  

The **`window.location.href`** property returns the full URL of the current page. It can be used to display or manipulate the page’s address.  

### Example – Display the Current Page URL:  
```javascript
document.getElementById(""demo"").innerHTML = ""Page location is: "" + window.location.href;
```
#### Output:
&gt; Page location is: `https://www.w3schools.com/js/js_window_location.asp`  

&gt; **Note:** The `window` prefix is optional; you can simply use `location.href`."		
214	BOM location	Window Location Hostname	"### `window.location.hostname` – Get the Hostname of the Current Page  

The **`window.location.hostname`** property returns the domain name (hostname) of the current page's URL.  

### Example – Display the Hostname:  
```javascript
document.getElementById(""demo"").innerHTML = ""Page hostname is: "" + window.location.hostname;
```
#### Output:
&gt; Page hostname is: `www.w3schools.com`

&gt; **Note:** The `window` prefix is optional, so `location.hostname` would work as well."		
215	BOM location	Window Location Pathname	"### `window.location.pathname` – Get the Pathname of the Current Page  

The **`window.location.pathname`** property returns the pathname of the current page’s URL, which is everything after the domain name.  

### Example – Display the Pathname:  
```javascript
document.getElementById(""demo"").innerHTML = ""Page path is: "" + window.location.pathname;
```
#### Output:
&gt; Page path is: `/js/js_window_location.asp`

&gt; **Note:** The `window` prefix is optional; you can simply use `location.pathname`."		
216	BOM location	Window Location Protocol	"### `window.location.protocol` – Get the Web Protocol of the Current Page  

The **`window.location.protocol`** property returns the web protocol used for the current page, such as `http:` or `https:`.  

### Example – Display the Web Protocol:  
```javascript
document.getElementById(""demo"").innerHTML = ""Page protocol is: "" + window.location.protocol;
```
#### Output:
&gt; Page protocol is: `https:`

&gt; **Note:** The `window` prefix is optional; you can simply use `location.protocol`."		
217	BOM location	Window Location Port	"### `window.location.port` – Get the Port Number of the Current Page  

The **`window.location.port`** property returns the port number of the internet host in the current page’s URL. If no specific port is specified in the URL, it will return an empty string.  

### Example – Display the Port Number:  
```javascript
document.getElementById(""demo"").innerHTML = ""Port number is: "" + window.location.port;
```
#### Output:
&gt; Port number is: *(empty string)*

&gt; **Note:** Most browsers will not display the default port numbers (80 for HTTP and 443 for HTTPS). If the page is using one of these default ports, the `port` property will be an empty string."		
218	BOM location	Window Location Assign	"### `window.location.assign()` – Load a New Document  

The **`window.location.assign()`** method is used to load a new document in the browser. It can redirect the user to a specified URL.

### Example – Load a New Document:  

```html




<p>Click the button to load a new document.</p>

<input type=""button"" value=""Load new document"" onclick=""newDoc()"">





```

#### Description:  
- When the user clicks the button, the `newDoc()` function is called, and the page will be redirected to `https://www.w3schools.com`.
- The `window.location.assign()` method updates the browser's history, so the user can navigate back to the original page using the browser's back button."		
219	BOM history	Window History	"### The `window.history` Object  

The **`history`** object allows access to the browser's history, enabling navigation through previously visited pages. It can be used **without** the `window` prefix.  

### Limitations:  
Due to privacy concerns, JavaScript has limited access to the `history` object, and it cannot manipulate the user's entire browsing history.  

### Common Methods of the `history` Object:

- **`history.back()`** – Moves the browser back to the previous page, just like clicking the browser's back button.  
  ```javascript
  history.back();
  ```

- **`history.forward()`** – Moves the browser forward to the next page, just like clicking the browser's forward button.  
  ```javascript
  history.forward();
  ```  

These methods allow users to navigate between pages in the current session's history, but they cannot be used to jump to arbitrary pages outside of the current browsing session."		
220	BOM navigator	Window Navigator	"### The `window.navigator` Object  

The **`navigator`** object contains information about the visitor's browser and operating system. It can be used **without** the `window` prefix.  

### Common Properties of the `navigator` Object:

- **`navigator.appName`** – Returns the name of the browser.  
  ```javascript
  console.log(navigator.appName); // Example: ""Netscape""
  ```

- **`navigator.appCodeName`** – Returns the code name of the browser.  
  ```javascript
  console.log(navigator.appCodeName); // Example: ""Mozilla""
  ```

- **`navigator.platform`** – Returns the platform (operating system) on which the browser is running.  
  ```javascript
  console.log(navigator.platform); // Example: ""Win32""
  ```

These properties provide basic information about the browser, but keep in mind that modern browsers may mask or modify some values for privacy and compatibility reasons."		
221	BOM navigator	Browser Cookies enabled	"### `navigator.cookieEnabled` – Check If Cookies Are Enabled  

The **`navigator.cookieEnabled`** property returns a boolean value indicating whether cookies are enabled in the browser.  

- **`true`** – Cookies are enabled.  
- **`false`** – Cookies are not enabled.  

### Example – Check If Cookies Are Enabled:  
```javascript
if (navigator.cookieEnabled) {
    console.log(""Cookies are enabled."");
} else {
    console.log(""Cookies are disabled."");
}
```

This property helps determine if the browser supports cookies or if the user has disabled them in their settings."		
222	BOM navigator	Browser Application Name	"### `navigator.appName` – Get the Browser's Application Name  

The **`navigator.appName`** property returns the application name of the browser.  

Interestingly, most modern browsers, including **Internet Explorer (IE11)**, **Chrome**, **Firefox**, and **Safari**, return the string **""Netscape""** as the application name, even though they are not based on Netscape.

### Example – Display the Application Name:  
```javascript
console.log(navigator.appName); // Example: ""Netscape""
```

### Note:  
While the `appName` property can be useful, its value is often outdated and does not always accurately reflect the actual browser being used, as most browsers report themselves as ""Netscape"" for compatibility reasons."		
223	BOM navigator	Browser Application Code Name	"### `navigator.appCodeName` – Get the Browser's Application Code Name  

The **`navigator.appCodeName`** property returns the application code name of the browser.  

Interestingly, regardless of the actual browser, most modern browsers (such as **Chrome**, **Firefox**, **Internet Explorer**, **Safari**, and **Opera**) return **""Mozilla""** as the application code name for compatibility reasons.

### Example – Display the Application Code Name:  
```javascript
console.log(navigator.appCodeName); // Example: ""Mozilla""
```

### Note:  
Like `navigator.appName`, the `appCodeName` property is also largely used for historical and compatibility reasons and may not accurately represent the actual browser."		
224	BOM navigator	The Browser Engine	"### `navigator.product` – Get the Browser Engine's Product Name  

The **`navigator.product`** property returns the product name of the browser engine.  

Most modern browsers return **""Gecko""** as the product name, even though they may not actually use the Gecko engine (which is primarily used by Firefox). This is for compatibility purposes and should not be relied upon for identifying the actual browser engine.

### Example – Display the Product Name:  
```javascript
console.log(navigator.product); // Example: ""Gecko""
```

### Note:  
Do not rely on the `navigator.product` property to determine the browser engine, as it may return misleading information due to the use of compatibility strings."		
225	BOM navigator	The Browser Version	"### `navigator.appVersion` – Get the Browser's Version Information  

The **`navigator.appVersion`** property returns version information about the browser, including the browser version, operating system details, and other relevant information.

### Example – Display the Browser's Version Information:  
```javascript
console.log(navigator.appVersion); // Example: ""5.0 (Windows) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36""
```

### Note:  
The version information returned by `navigator.appVersion` can vary significantly between different browsers and platforms, and it may include details about the operating system and browser engine. For accurate browser version detection, it's recommended to use feature detection rather than relying on version strings."		
226	BOM navigator	The Browser Agent	"### `navigator.userAgent` – Get the User-Agent String  

The **`navigator.userAgent`** property returns the **user-agent string** sent by the browser to the server. This string contains information about the browser, operating system, and device, which can be used for detecting the user's environment.

### Example – Display the User-Agent String:  
```javascript
console.log(navigator.userAgent); // Example: ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36""
```

### Note:  
The `userAgent` string is often used for browser detection, but it is not always reliable since browsers can modify or mask their user-agent strings. It is generally recommended to use feature detection over user-agent detection for better accuracy and cross-browser compatibility."		
227	BOM navigator	The Browser Platform	"### `navigator.platform` – Get the Browser's Platform (Operating System)  

The **`navigator.platform`** property returns a string that represents the platform (operating system) on which the browser is running. This can provide information about whether the user is on Windows, macOS, Linux, iOS, Android, etc.

### Example – Display the Platform:  
```javascript
console.log(navigator.platform); // Example: ""Win32"", ""MacIntel"", ""Linux x86_64"", ""iPhone""
```

### Note:  
While this property gives a general idea of the user's operating system, it may not always be completely accurate or consistent, especially on mobile devices or platforms with multiple OS versions."		
228	BOM navigator	The Browser Language	"### `navigator.language` – Get the Browser's Language  

The **`navigator.language`** property returns a string representing the preferred language of the browser, usually in the format of a language code (e.g., ""en"" for English, ""fr"" for French).  

### Example – Display the Browser's Language:  
```javascript
console.log(navigator.language); // Example: ""en-US""
```

### Note:  
The value returned by `navigator.language` represents the user's primary language preference for the browser and may include regional information (e.g., `en-US` for English (United States) or `en-GB` for English (United Kingdom))."		
229	BOM navigator	Is The Browser Online?	"### `navigator.onLine` – Check If the Browser Is Online  

The **`navigator.onLine`** property returns a boolean value indicating whether the browser is currently online.  

- **`true`** – The browser is online and has network connectivity.  
- **`false`** – The browser is offline or does not have network connectivity.  

### Example – Check if the Browser Is Online:  
```javascript
if (navigator.onLine) {
    console.log(""The browser is online."");
} else {
    console.log(""The browser is offline."");
}
```

### Note:  
This property checks the browser's network status, but it may not always indicate the actual availability of internet services (e.g., it might return `true` even if the user has a local network connection but no internet access)."		
230	BOM navigator	Is Java Enabled?	"### `navigator.javaEnabled()` – Check if Java is Enabled  

The **`navigator.javaEnabled()`** method returns a boolean value indicating whether Java is enabled in the browser.  

- **`true`** – Java is enabled in the browser.  
- **`false`** – Java is not enabled or not supported.  

### Example – Check if Java is Enabled:  
```javascript
if (navigator.javaEnabled()) {
    console.log(""Java is enabled."");
} else {
    console.log(""Java is not enabled."");
}
```

### Note:  
Most modern browsers no longer support Java plugins due to security and compatibility concerns. Therefore, this method may often return `false` on current browsers."		
231	BOM popup alert	Alert Box	"### `window.alert()` – Display an Alert Box  

The **`window.alert()`** method is commonly used to display a simple alert box with a message to the user. When the alert box pops up, the user must click **""OK""** to proceed.  

### Example – Display an Alert Box:  
```javascript
alert(""This is an alert message!"");
```

### Note:  
- The `window` prefix is optional, so you can simply use `alert()` instead of `window.alert()`.  
- The alert box is **modal**, meaning it blocks user interaction with the page until dismissed."		
232	BOM popup alert	Confirm Box	"### `window.confirm()` – Display a Confirm Box  

The **`window.confirm()`** method is used to display a confirmation dialog to the user, asking for a verification or response. When the confirm box pops up, the user can click **""OK""** or **""Cancel""** to proceed.  

- If the user clicks **""OK""**, the method returns **`true`**.  
- If the user clicks **""Cancel""**, the method returns **`false`**.  

### Example – Display a Confirm Box:  
```javascript
let txt;
if (confirm(""Press a button!"")) {
    txt = ""You pressed OK!"";
} else {
    txt = ""You pressed Cancel!"";
}
console.log(txt);
```

### Note:  
- The `window` prefix is optional, so you can use `confirm()` instead of `window.confirm()`.  
- The `confirm()` method is **modal**, meaning it blocks interaction with the page until the user responds."		
233	BOM popup alert	Prompt Box	"### `window.prompt()` – Display a Prompt Box  

The **`window.prompt()`** method is used to display a prompt box that asks the user to input a value before proceeding. The user can either provide an input or click **""Cancel""**.  

- If the user clicks **""OK""**, the method returns the input value provided.  
- If the user clicks **""Cancel""**, the method returns **`null`**.  

### Example – Display a Prompt Box:  
```javascript
var person = prompt(""Please enter your name"", ""Harry Potter"");
if (person == null || person == """") {
    txt = ""User cancelled the prompt."";
} else {
    txt = ""Hello "" + person + ""! How are you today?"";
}
console.log(txt);
```

### Note:  
- The `window` prefix is optional, so you can use `prompt()` instead of `window.prompt()`.  
- The prompt box is **modal**, meaning it blocks interaction with the page until the user provides input or cancels."		
234	BOM popup alert	Line Breaks	"### Display Line Breaks in a Popup Box

To display line breaks inside a popup box (such as an alert), you can use the **backslash (`\`)** followed by the character **`n`** (`\n`), which represents a newline.

### Example – Display Line Breaks in an Alert Box:  
```javascript
alert(""Hello\nHow are you?"");
```

### Output:  
The alert box will display:

```
Hello
How are you?
```

### Note:  
The `\n` creates a line break, allowing the message to appear on multiple lines in the alert box."		
235	BOM timing	Timing Events	"### Timing Events in JavaScript

The **window** object allows you to execute code at specified time intervals. These intervals are referred to as **timing events**.

### Key Methods for Timing Events:

- **`setTimeout(function, milliseconds)`**  
  Executes a function **once** after waiting a specified number of milliseconds.
  - **Example:**  
    ```javascript
    setTimeout(function() {
        alert(""This message will appear after 3 seconds!"");
    }, 3000); // 3000 milliseconds = 3 seconds
    ```

- **`setInterval(function, milliseconds)`**  
  Executes a function **repeatedly** at the specified interval (in milliseconds).
  - **Example:**  
    ```javascript
    setInterval(function() {
        console.log(""This message will repeat every 2 seconds."");
    }, 2000); // 2000 milliseconds = 2 seconds
    ```

### Note:
- Both `setTimeout()` and `setInterval()` are methods of the **HTML DOM Window** object and can be used to schedule code execution with precise timing.
- `setTimeout()` executes the function once, while `setInterval()` keeps executing the function at the specified interval until stopped."		
236	BOM timing	The setTimeout() Method	"### `window.setTimeout()` – Execute a Function After a Delay

The **`setTimeout()`** method allows you to execute a function after a specified number of milliseconds. The `window` prefix is optional, so you can simply use `setTimeout()`.

- **First parameter:** The function to be executed.
- **Second parameter:** The number of milliseconds to wait before executing the function.

### Example – Click a Button, Wait 3 Seconds, and Show an Alert:

```html
<button onclick=""setTimeout(myFunction, 3000)"">
    Try it
</button>


```

### How It Works:
- When the button is clicked, it triggers the `setTimeout()` method.
- The `myFunction()` function will execute after a 3-second delay, showing an alert with the message ""Hello"".

&gt; **Note:** You can omit the `window` prefix and use `setTimeout()` directly."		
237	BOM timing	How to Stop the Execution? setTimeout()	"### `clearTimeout()` – Stop a Timed Function Execution

The **`clearTimeout()`** method is used to stop the execution of a function that was scheduled with **`setTimeout()`**. The `clearTimeout()` method takes the variable returned by `setTimeout()` to identify which timeout to clear.

- **First parameter:** The variable returned by `setTimeout()`.

### Example – Stop the Execution of a Timed Function:

```html
<button onclick=""myVar = setTimeout(myFunction, 3000)"">
    Try it
</button>
<button onclick=""clearTimeout(myVar)"">
    Stop it
</button>


```

### How It Works:
- The **""Try it""** button starts a timeout, scheduling the `myFunction()` function to execute after 3 seconds (3000 milliseconds).
- The **""Stop it""** button calls `clearTimeout()`, passing in the `myVar` variable (which holds the timeout ID), preventing the function from being executed if the user clicks it before 3 seconds.

&gt; **Note:** You can omit the `window` prefix and use `clearTimeout()` directly."		
238	BOM timing	The setInterval() Method	"### `setInterval()` – Repeatedly Execute a Function at Intervals

The **`setInterval()`** method allows you to repeatedly execute a given function at specified time intervals. The method can be written without the `window` prefix.

- **First parameter:** The function to be executed.
- **Second parameter:** The time interval (in milliseconds) between each execution.

### Example – Display the Current Time Like a Digital Watch:

```html
<p id=""demo""></p>


```

### How It Works:
- The **`setInterval()`** method is called with a time interval of 1000 milliseconds (1 second), so it will repeatedly execute the `myTimer()` function every second.
- The `myTimer()` function gets the current time using `new Date()` and displays it in the element with the ID ""demo"" in a digital-clock format.
- `toLocaleTimeString()` is used to format the time according to the user's locale.

&gt; **Note:** There are 1000 milliseconds in one second. You can adjust the interval as needed by changing the milliseconds value."		
239	BOM timing	How to Stop the Execution? setInterval()	"### `clearInterval()` – Stop the Repeated Execution of a Function

The **`clearInterval()`** method stops the repeated execution of a function that was set using **`setInterval()`**. It requires the variable returned by `setInterval()` as its parameter.

- **First parameter:** The variable returned by `setInterval()`.

### Example – Stop the Time Display with a ""Stop Time"" Button:

```html
<p id=""demo""></p>
<button onclick=""clearInterval(myVar)"">
    Stop time
</button>


```

### How It Works:
- The **`setInterval()`** method starts a timer and runs the `myTimer()` function every second (1000 milliseconds), displaying the current time in the `demo` element.
- When the **""Stop time""** button is clicked, it triggers **`clearInterval(myVar)`**, which stops the repeated execution of the `myTimer()` function.

&gt; **Note:** You can omit the `window` prefix and use `clearInterval()` directly."		
240	BOM cookies	What are Cookies?	"### Cookies – Storing Data on the User's Computer

**Cookies** are small text files stored on the user's computer, containing data that can be accessed by both the browser and the web server. They are commonly used to remember information about the user across sessions.

### How Cookies Work:

- When a web server sends a page to a browser, the connection is closed, and the server forgets everything about the user. 
- **Cookies** allow web servers to ""remember"" user-specific data by storing this data in a text file on the user's computer. 

### Example Use Case:
- When a user visits a web page, their name (or other data) can be stored in a cookie.
- The next time the user visits the page, the cookie ""remembers"" their name and can display it, or send it back to the server for personalized content.

### Format:
Cookies are stored as **name-value pairs**:
```
username = John Doe
```

### How Cookies Work:
- When the browser requests a web page, cookies related to that page are sent to the server with the request. This allows the server to retrieve user-specific data (such as preferences or login information) and provide personalized experiences.
  
### Important Note:
Cookies will only work if the browser supports them, and if the browser's **cookie support** is enabled. If cookies are disabled in the browser settings, they will not be used or sent to the server.

"		
241	BOM cookies	Create a Cookie with JavaScript	"### Creating, Reading, and Deleting Cookies in JavaScript

JavaScript provides the **`document.cookie`** property to create, read, and delete cookies.

### Creating a Cookie

To create a simple cookie, you can assign a string to **`document.cookie`** in the format of a **name-value** pair.

```javascript
document.cookie = ""username=John Doe"";
```

### Adding Expiry Date

By default, cookies are deleted when the browser is closed. However, you can specify an **expiry date** for a cookie using the **`expires`** attribute, which must be in UTC time format.

```javascript
document.cookie = ""username=John Doe; expires=Thu, 18 Dec 2023 12:00:00 UTC"";
```

In this case, the cookie will expire at **12:00:00 UTC on December 18, 2023**.

### Specifying a Path for the Cookie

By default, a cookie belongs to the page that created it. However, you can specify a **`path`** parameter to define the scope of the cookie, indicating which pages or paths the cookie applies to.

```javascript
document.cookie = ""username=John Doe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/"";
```

This means the cookie will be available for all pages on the domain, starting from the root (`/`).

### Summary:
- **Create a cookie:** `document.cookie = ""name=value"";`
- **Add expiry date:** `expires=Thu, 18 Dec 2023 12:00:00 UTC;`
- **Set a path:** `path=/;` (cookie applies to the entire domain)

By using these properties, you can control cookie behavior, including expiry time and scope."		
242	BOM cookies	Read a Cookie with JavaScript	"### Reading Cookies in JavaScript

In JavaScript, you can read all cookies associated with the current document using the **`document.cookie`** property.

### Example of Reading Cookies:

```javascript
var x = document.cookie;
```

The **`document.cookie`** property will return all cookies in a single string, with each cookie separated by a semicolon (`;`).

For example, if you have the following cookies:
```
username=JohnDoe;
theme=dark;
preferences=english;
```

The **`document.cookie`** will return the following string:
```
""username=JohnDoe; theme=dark; preferences=english""
```

### Important Notes:
- **`document.cookie`** returns all cookies as a single string, making it necessary to parse the string to access individual cookies.
- The returned cookies do not include the **expiry date** or **path**; it only returns the name-value pairs. If you want to retrieve a specific cookie, you will need to extract it from the string manually or with a function.

#### Example of Extracting a Specific Cookie:

```javascript
function getCookie(name) {
    var cookieArray = document.cookie.split(';');
    for(var i = 0; i &lt; cookieArray.length; i++) {
        var cookie = cookieArray[i].trim();
        if (cookie.indexOf(name + ""="") == 0) {
            return cookie.substring(name.length + 1);
        }
    }
    return """"; // Return empty string if cookie not found
}

var username = getCookie(""username"");
console.log(username); // ""JohnDoe""
```

This function splits the `document.cookie` string, looks for the specified cookie name, and returns its value."		
243	BOM cookies	Change a Cookie with JavaScript	"### Changing a Cookie in JavaScript

To **change** a cookie in JavaScript, you can set the cookie again with the new value. This will **overwrite** the existing cookie with the same name.

### Example of Changing a Cookie:

```javascript
document.cookie = ""username=John Smith; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/"";
```

### How It Works:
- If a cookie with the name `username` already exists, it will be **overwritten** with the new value (`John Smith`).
- The **expiry date** and **path** can also be updated when changing the cookie.
- Make sure to include the **same path** and **expiry** if you want to update the cookie's properties.

### Important Notes:
- If you don't specify the expiry date, the cookie will become a **session cookie**, and it will be deleted once the browser is closed.
- If the `path` is not specified, the cookie will be set for the current path by default.

In summary, changing a cookie is just like creating it — simply set `document.cookie` again with the new value, and the old cookie will be replaced."		
244	BOM cookies	Delete a Cookie with JavaScript	"### Deleting a Cookie in JavaScript

To delete a cookie in JavaScript, you set its **`expires`** parameter to a date in the past. This will instruct the browser to remove the cookie.

### Example of Deleting a Cookie:

```javascript
document.cookie = ""username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/"";
```

### How It Works:
- Setting the **`expires`** date to **Thu, 01 Jan 1970 00:00:00 UTC** ensures the cookie has already expired, and the browser will remove it.
- The **`path=/`** is important because you need to specify the same path where the cookie was originally set. If the path is not specified or doesn't match the original cookie's path, the cookie may not be deleted.

### Important Notes:
- **Path:** If the cookie was set with a specific path (e.g., `path=/` or `path=/folder`), you must specify the same path when deleting the cookie. If the path does not match, the deletion may fail.
- **Domain:** If the cookie was set for a specific domain, you might also need to specify the domain when deleting the cookie.
  
### Example of Deleting a Cookie with a Specific Path:
If the cookie was set with a specific path, say `/account`, you need to specify it when deleting the cookie:

```javascript
document.cookie = ""username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/account"";
```

By doing this, you ensure that the correct cookie is deleted."		
245	BOM cookies	The Cookie String	"### Understanding `document.cookie`

The **`document.cookie`** property in JavaScript represents all cookies associated with the current document as a single text string. However, it behaves a bit differently than a standard text string:

- Even if you set a new cookie, older cookies are **not overwritten**. The new cookie is simply **added** to the cookie string.
- The **`document.cookie`** property only shows the **name-value pairs** of the cookies when you read it. It will not include any additional cookie attributes like `expires`, `path`, or `domain`.

### Example:

If you set multiple cookies, the **`document.cookie`** string will look like this:

```javascript
document.cookie = ""username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/"";
document.cookie = ""theme=dark; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/"";
```

Reading **`document.cookie`** will return:

```
""username=JohnDoe; theme=dark""
```

### Accessing a Specific Cookie Value

Since **`document.cookie`** returns all cookies as a single string, if you want to find the value of a specific cookie, you need to write a JavaScript function to search for it.

### Example Function to Get a Specific Cookie:

```javascript
function getCookie(name) {
    var cookieArray = document.cookie.split(';'); // Split cookies into an array
    for(var i = 0; i &lt; cookieArray.length; i++) {
        var cookie = cookieArray[i].trim();  // Remove leading spaces
        if (cookie.indexOf(name + ""="") === 0) {
            return cookie.substring(name.length + 1); // Return the cookie value
        }
    }
    return null; // Return null if the cookie is not found
}

var username = getCookie(""username"");  // Get the value of ""username""
console.log(username);  // Outputs: ""JohnDoe""
```

### Explanation:

- The **`getCookie()`** function splits the **`document.cookie`** string into an array of individual cookies.
- It then iterates through the array, trimming any extra spaces, and checks if the specified cookie name exists in the string.
- If found, it extracts and returns the cookie value. If not found, it returns `null`.

### Important Notes:
- **`document.cookie`** does not allow access to cookie attributes like `expires` or `path`, so you can't directly modify or read those values using **`document.cookie`**.
- To **update** an existing cookie, simply set a new cookie with the same name and desired value, as cookies are not overwritten automatically. The new cookie will replace the old one."		
246	BOM cookies	A Function to Set a Cookie	"### `setCookie()` Function – Setting Cookies with JavaScript

The **`setCookie()`** function allows you to create a cookie with a specified name, value, and expiration time (in days). Here’s how it works:

### Function Explanation:

```javascript
function setCookie(cname, cvalue, exdays) {
    var d = new Date();  // Create a new date object
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));  // Set the expiration time in milliseconds
    var expires = ""expires="" + d.toUTCString();  // Convert the expiration date to UTC string format
    document.cookie = cname + ""="" + cvalue + "";"" + expires + "";path=/"";  // Set the cookie
}
```

### Parameters:
- **`cname`**: The name of the cookie (e.g., `""username""`).
- **`cvalue`**: The value of the cookie (e.g., `""John Doe""`).
- **`exdays`**: The number of days until the cookie expires. For example, if you want the cookie to expire in 7 days, you would pass `7`.

### Steps in the Function:
1. **Create a `Date` object**: The function creates a new date object (`d`), representing the current date and time.
2. **Set the expiration time**: The expiration date is calculated by adding the desired number of days (`exdays`) to the current time, converted to milliseconds (`exdays * 24 * 60 * 60 * 1000`).
3. **Convert the expiration date to UTC string format**: The expiration date is then converted to a UTC string using the `toUTCString()` method.
4. **Set the cookie**: The cookie is set by assigning a string to `document.cookie` that combines:
   - The cookie name (`cname`)
   - The cookie value (`cvalue`)
   - The expiration date (`expires`)
   - The `path=/` (ensures the cookie is available throughout the entire website).

### Example Usage:

```javascript
setCookie(""username"", ""John Doe"", 7);  // Set a cookie with name ""username"", value ""John Doe"", and an expiration of 7 days.
```

This example will store a cookie called `""username""` with the value `""John Doe""`, and the cookie will expire in 7 days.

### Important Notes:
- **`expires`**: The cookie expiration is crucial. If no expiration date is set, the cookie will become a **session cookie** and will be deleted when the browser is closed.
- **`path=/`**: This ensures the cookie is available throughout the entire website. You can adjust the path if you want the cookie to only be accessible from a specific directory (e.g., `path=/myfolder`).
- **Date in UTC**: The expiration date must be in **UTC format** for proper cookie expiration handling."		
247	BOM cookies	A Function to Get a Cookie	"### `getCookie()` Function – Retrieve the Value of a Cookie

The **`getCookie()`** function allows you to retrieve the value of a cookie by its name. Here's the breakdown of how the function works:

### Function Explanation:

```javascript
function getCookie(cname) {
    var name = cname + ""="";  // Create the string to search for (cookie name + ""="")
    var decodedCookie = decodeURIComponent(document.cookie);  // Decode the cookie string to handle special characters
    var ca = decodedCookie.split(';');  // Split the cookie string into an array based on semicolons

    for (var i = 0; i &lt; ca.length; i++) {  // Loop through the array of cookies
        var c = ca[i];  // Get each cookie from the array
        while (c.charAt(0) == ' ') {  // Remove leading spaces
            c = c.substring(1);
        }

        if (c.indexOf(name) == 0) {  // If the cookie starts with the specified cookie name
            return c.substring(name.length, c.length);  // Return the value of the cookie
        }
    }
    return """";  // Return an empty string if the cookie is not found
}
```

### Steps in the Function:

1. **Create the search string**:
   - The function takes the cookie name (`cname`) as a parameter and creates a string (`name`) by appending an equal sign (`=`) to the cookie name. For example, if `cname = ""username""`, the search string will be `""username=""`.

2. **Decode the cookie string**:
   - The cookies retrieved from **`document.cookie`** are URL-encoded, so the function uses **`decodeURIComponent()`** to decode the string and handle special characters (like `$`, `&amp;`, etc.).

3. **Split cookies into an array**:
   - The decoded cookie string is split into individual cookies using the semicolon (`;`) as a delimiter. The result is an array of cookies (`ca`).

4. **Loop through the cookies**:
   - The function loops through the array of cookies and checks each one. It trims any leading spaces from each cookie.

5. **Check if the cookie name matches**:
   - If the cookie name matches the one we're looking for (i.e., `c.indexOf(name) == 0`), it means the cookie has been found.

6. **Return the value**:
   - If the cookie is found, the function returns the value of the cookie by extracting the substring after the `=` sign (`c.substring(name.length, c.length)`).

7. **Return an empty string if not found**:
   - If no matching cookie is found, the function returns an empty string (`""""`).

### Example Usage:

```javascript
setCookie(""username"", ""John Doe"", 7);  // Set the cookie
var user = getCookie(""username"");  // Get the value of the ""username"" cookie
console.log(user);  // Outputs: ""John Doe""
```

### Important Notes:
- **`decodeURIComponent()`**: This function is essential for handling cookies with special characters. It decodes the cookie string to ensure that characters like `%` or other URL-encoded characters are correctly interpreted.
- **Cookie String**: `document.cookie` returns all cookies in a single string, which is why this function splits the string and searches for the specified cookie.

### Summary:
- The **`getCookie()`** function searches for the cookie by its name, decodes it if necessary, and returns its value.
- If the cookie is not found, it returns an empty string. This ensures you can safely check for cookies without causing errors."		
248	BOM cookies	A Function to Check a Cookie	"### `checkCookie()` Function – Check If a Cookie Is Set and Display a Greeting

The **`checkCookie()`** function checks if a **`username`** cookie is set. If the cookie exists, it displays a greeting with the stored username. If the cookie is not set, it prompts the user to enter their name and stores it in a cookie that will expire in 365 days.

### Function Explanation:

```javascript
function checkCookie() {
    var username = getCookie(""username"");  // Get the ""username"" cookie

    if (username != """") {  // If the cookie exists and is not empty
        alert(""Welcome again "" + username);  // Display a welcome message
    } else {  // If the cookie does not exist
        username = prompt(""Please enter your name:"", """");  // Prompt the user for their name
        if (username != """" &amp;&amp; username != null) {  // If the user provided a name
            setCookie(""username"", username, 365);  // Store the name in a cookie for 365 days
        }
    }
}
```

### Steps in the Function:

1. **Check for existing cookie**:
   - The function first retrieves the **`username`** cookie using the **`getCookie()`** function. If the cookie exists and has a value (i.e., `username != """"`), it displays a welcome message using **`alert()`**.

2. **Prompt for name if cookie is not set**:
   - If the cookie does not exist or is empty (`else` block), the function prompts the user to enter their name using the **`prompt()`** method.

3. **Store the name in a cookie**:
   - If the user enters a valid name (not an empty string and not `null`), the function calls the **`setCookie()`** function to store the user's name in a cookie. The cookie will expire in 365 days.

### Example Usage:

```javascript
checkCookie();  // This will check if the ""username"" cookie is set
```

### How It Works:

1. When the **`checkCookie()`** function is called:
   - If the **`username`** cookie exists, the user will see an alert saying, ""Welcome again [username]"".
   - If the cookie does not exist, the user will be prompted to enter their name, and the entered name will be saved in a cookie for 365 days.

### Summary:
- **`checkCookie()`** checks if a **`username`** cookie exists.
- If the cookie exists, it greets the user.
- If the cookie doesn't exist, it prompts the user for their name and saves it in a cookie for future visits.
"		
249	AJAX intro	What is AJAX?	"### AJAX – Asynchronous JavaScript and XML

**AJAX** (Asynchronous JavaScript and XML) is not a programming language, but rather a combination of technologies used to create **dynamic** and **interactive** web applications. It enables web pages to **update asynchronously** by exchanging data with a web server, allowing parts of a page to be updated without reloading the entire page.

### Key Points about AJAX:

- **AJAX is not a programming language**: It is a **technique** that combines several technologies:
  - **`XMLHttpRequest`**: A browser built-in object used to request data from a web server.
  - **JavaScript**: Used to process the data and manipulate the HTML DOM.
  - **HTML DOM**: Used to update parts of the web page with the data received from the server.

- **AJAX is a misleading name**: While AJAX originally stood for **Asynchronous JavaScript and XML**, it is not limited to using XML. Modern AJAX applications often use other data formats, such as:
  - **Plain text** 
  - **JSON (JavaScript Object Notation)**

- **Asynchronous updates**: AJAX allows for **asynchronous** data exchange between the browser and the server. This means that:
  - A page can request and receive data from the server in the background.
  - The page can update parts of the content without needing a full reload.

### Example of How AJAX Works:

1. **Request Data**: JavaScript uses the **`XMLHttpRequest`** object (or **`fetch()`** in modern browsers) to request data from the server asynchronously.
2. **Receive Data**: The server processes the request and sends the data back, typically in the form of JSON or XML.
3. **Update the Page**: JavaScript updates the web page using the **HTML DOM**, inserting the received data into the page.

### Benefits of AJAX:
- **Improved User Experience**: Parts of a page can be updated without requiring a page reload, leading to a smoother and faster user experience.
- **Efficiency**: Only the necessary data is exchanged with the server, reducing the amount of data transferred.
- **Interactive Applications**: It is widely used for creating interactive applications like chat apps, real-time notifications, dynamic forms, and more.

### Example Code:
Here is a simple example of how to use **AJAX** to fetch data from a server and display it:

```javascript
// Create a new XMLHttpRequest object
var xhr = new XMLHttpRequest();

// Define what happens when the request completes
xhr.onload = function() {
    if (xhr.status == 200) {  // Check if the request was successful
        document.getElementById(""demo"").innerHTML = xhr.responseText;  // Update the page
    }
};

// Initialize the request
xhr.open(""GET"", ""data.txt"", true);

// Send the request to the server
xhr.send();
```

In this example:
- **`GET`** method is used to request the file **`data.txt`**.
- When the request completes, the response is inserted into an HTML element with the ID **`demo`**.

### Summary:
AJAX enables web applications to load or update data asynchronously without reloading the entire page. It is commonly used for creating responsive and dynamic web applications, making use of **JavaScript**, **XMLHttpRequest**, and **HTML DOM**."		
250	AJAX intro	How AJAX Works	"### AJAX Workflow Overview

The process of using **AJAX** to interact with a web server and update a webpage can be broken down into the following steps:

---

1. **An Event Occurs in a Web Page**:  
   - An event triggers an action on the web page (e.g., the page is loaded, a button is clicked, a form is submitted).
   - This event could be initiated by the user or automatically by the page itself (e.g., page load or button click).

2. **An XMLHttpRequest Object is Created by JavaScript**:  
   - JavaScript creates an instance of the **`XMLHttpRequest`** object, which is the key tool used for making asynchronous requests to the server.

   ```javascript
   var xhr = new XMLHttpRequest();
   ```

3. **The XMLHttpRequest Object Sends a Request to a Web Server**:  
   - The **`XMLHttpRequest`** object is used to send an HTTP request (e.g., GET, POST) to the server with any necessary parameters (e.g., form data).
   
   ```javascript
   xhr.open(""GET"", ""data.json"", true);
   xhr.send();
   ```

4. **The Server Processes the Request**:  
   - The web server receives the request and processes it, which could involve querying a database, performing calculations, or retrieving data from another service.

5. **The Server Sends a Response Back to the Web Page**:  
   - After processing the request, the server sends back a response. This could be data in various formats, such as **XML**, **JSON**, or plain text.
   
   Example response could be:
   ```json
   { ""status"": ""success"", ""message"": ""Data retrieved successfully"" }
   ```

6. **The Response is Read by JavaScript**:  
   - The **`XMLHttpRequest`** object receives the response and makes it available to JavaScript. This can be done using the `onload` event handler.
   
   ```javascript
   xhr.onload = function() {
       if (xhr.status == 200) {
           var response = JSON.parse(xhr.responseText); // Parse JSON response
           console.log(response.message);  // Output to console
       }
   };
   ```

7. **Proper Action (Like Page Update) is Performed by JavaScript**:  
   - Once JavaScript has received and processed the response, the web page can be updated dynamically without reloading the entire page. This can include:
     - Inserting new content into the page.
     - Updating an element's value.
     - Displaying an alert or message.

   Example: Update the content of a webpage based on the response:
   ```javascript
   document.getElementById(""message"").innerHTML = response.message;
   ```

---

### Full Example Code:

Here is a simple example of the entire AJAX process:

```javascript
// Step 1: Event triggers AJAX request (Button Click)
document.getElementById(""myButton"").addEventListener(""click"", function() {
    // Step 2: Create XMLHttpRequest object
    var xhr = new XMLHttpRequest();

    // Step 3: Send request to the server
    xhr.open(""GET"", ""data.json"", true);
    xhr.send();

    // Step 4-5: Server processes the request and sends back response
    xhr.onload = function() {
        if (xhr.status == 200) {
            // Step 6: Read the response (JSON data)
            var response = JSON.parse(xhr.responseText);

            // Step 7: Update the webpage with the response data
            document.getElementById(""message"").innerHTML = response.message;
        }
    };
});
```

In this example:
- When the user clicks the **""myButton""**, the request is sent to the server (`""data.json""`).
- Upon receiving a successful response, JavaScript updates the content of an element with the ID **`message`**.

### Summary:
The AJAX process is highly efficient for creating **dynamic, interactive web applications** by allowing parts of the page to be updated without requiring a full page reload. The process consists of triggering an event, sending a request, receiving and processing the server response, and updating the page accordingly."		
251	AJAX XMLHttp	The XMLHttpRequest Object	"### XMLHttpRequest Object in Modern Browsers

The **`XMLHttpRequest`** object is supported by all modern browsers and is a key part of **AJAX**. It allows web pages to send and receive data asynchronously from a web server behind the scenes, which enables updating parts of a webpage without needing to reload the entire page.

### Key Features:
- **Asynchronous Communication**: The **`XMLHttpRequest`** object allows data to be exchanged with a server in the background without interrupting the user's interaction with the webpage.
- **Partial Page Updates**: By using **AJAX** with **`XMLHttpRequest`**, you can update specific parts of a web page dynamically (e.g., loading new content, refreshing data) without reloading the entire page.

### Example of Using XMLHttpRequest:

```javascript
// Create a new XMLHttpRequest object
var xhr = new XMLHttpRequest();

// Define what to do when the request is complete
xhr.onload = function() {
    if (xhr.status == 200) {  // Check if the request was successful
        // Update a part of the page (for example, a div with ID ""content"")
        document.getElementById(""content"").innerHTML = xhr.responseText;
    }
};

// Send a GET request to the server
xhr.open(""GET"", ""data.txt"", true);  // The URL ""data.txt"" is just an example
xhr.send();
```

### How It Works:
1. **Create XMLHttpRequest**: The request object is created using `new XMLHttpRequest()`.
2. **Set up `onload` Event Handler**: The `onload` event handler is defined, which will be called when the server responds to the request.
3. **Send Request**: The `open()` method is used to define the request type (e.g., ""GET"" or ""POST"") and the URL to send the request to. The `send()` method is used to actually send the request.
4. **Update Page**: When the request is complete and the response is received, you can dynamically update parts of the web page with the response using the `innerHTML` property or other DOM manipulation methods.

### Benefits of `XMLHttpRequest`:
- **Improved User Experience**: Users can interact with the webpage while the request is being processed in the background.
- **Reduced Server Load**: Only specific parts of the page are updated, not the entire page, which can reduce the amount of data exchanged.
- **Faster Page Interactions**: Since the page doesn't need to reload fully, interactions become faster and more seamless.

### Summary:
The **`XMLHttpRequest`** object is a powerful tool for creating modern, dynamic web applications by allowing data to be exchanged between the browser and the server asynchronously. It enables partial page updates without the need to reload the entire page, improving both user experience and performance."		
252	AJAX XMLHttp	Create an XMLHttpRequest Object	"### XMLHttpRequest Object in Modern Browsers

All modern browsers, including **Chrome**, **Firefox**, **Internet Explorer 7+**, **Edge**, **Safari**, and **Opera**, have a built-in **`XMLHttpRequest`** object that can be used for making asynchronous requests to a web server.

### Syntax for Creating an XMLHttpRequest Object

To create a new instance of the **`XMLHttpRequest`** object, you can use the following syntax:

```javascript
var xhttp = new XMLHttpRequest();
```

### How It Works:
1. **`new XMLHttpRequest()`**: This creates a new **XMLHttpRequest** object, which allows you to interact with the server, send requests, and handle responses asynchronously.
2. **`xhttp`**: This variable is now an instance of the **`XMLHttpRequest`** object, which you can use to make requests and manage the server's responses.

### Example Usage:

Here's an example of how to use **`XMLHttpRequest`** to send an HTTP request and handle the response:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Define what to do when the request is completed
xhttp.onload = function() {
    if (xhttp.status == 200) {  // If the response status is OK (200)
        console.log(xhttp.responseText);  // Log the response from the server
    }
};

// Initialize the request: 'GET' method, request to 'data.txt' file
xhttp.open(""GET"", ""data.txt"", true);

// Send the request to the server
xhttp.send();
```

### Key Points:
- **`xhttp.open(method, url, async)`**: This initializes the request. 
   - **`method`**: The HTTP method (e.g., ""GET"", ""POST"").
   - **`url`**: The URL to send the request to.
   - **`async`**: A boolean indicating whether the request should be asynchronous (`true`) or synchronous (`false`).
   
- **`xhttp.send()`**: This sends the request to the server.

- **`xhttp.onload`**: This event handler is called when the request completes. The response can be accessed using **`xhttp.responseText`** or **`xhttp.responseXML`**.

### Summary:
The **`XMLHttpRequest`** object is supported by all modern browsers, and it is used to make HTTP requests from a web page to a server without requiring a full page reload. The syntax for creating the object is simple:

```javascript
var xhttp = new XMLHttpRequest();
``` 

Once created, you can use it to interact with servers asynchronously, which allows for smoother, faster, and more dynamic web applications."		
253	AJAX XMLHttp	Access Across Domains	"### Cross-Domain Restrictions in Modern Browsers

For **security reasons**, modern browsers enforce **same-origin policy** restrictions, which means that web pages cannot make requests to a domain other than the one from which the page was loaded. This applies to **AJAX** requests made with the **`XMLHttpRequest`** object.

### Same-Origin Policy

The **same-origin policy** ensures that:

1. **Web pages can only make requests to the same domain** from which they were served.
2. **AJAX requests** (using `XMLHttpRequest`) must be made to the **same server** and **same protocol** that the page was loaded from.

This prevents malicious websites from accessing sensitive data from another domain without permission.

### Example of Same-Origin Policy:

- If you are viewing a webpage hosted on **`http://example.com`**, you can make **AJAX requests** only to **`http://example.com`** or any subdomains of that domain (e.g., **`sub.example.com`**).

- If you try to make an **AJAX request** to a different domain, like **`http://anotherdomain.com`**, it will be blocked by the browser due to the **same-origin policy**.

### Cross-Origin Resource Sharing (CORS)

However, there are exceptions to this rule. **Cross-Origin Resource Sharing (CORS)** is a mechanism that allows a server to specify which domains are allowed to access its resources. With CORS, the server includes special headers in its response that allow cross-origin requests.

### Example of CORS:

On the server side, the server can add a CORS header to allow cross-origin requests, such as:

```http
Access-Control-Allow-Origin: *
```

This header tells the browser that any domain is allowed to access the resource. If this header is not set, the browser will block the request.

### Workaround for Local Development:

If you are working locally (e.g., your HTML file is on your computer) and trying to make AJAX requests, you may face issues due to the **same-origin policy**. One workaround is to run a local server (e.g., using Python’s simple HTTP server or Node.js) so that your page and the AJAX request come from the same origin.

For example, using Python's built-in HTTP server:

```bash
python -m http.server 8000
```

Then you can access your page via `http://localhost:8000`, and the requests to resources on the same server will work.

### Summary:

- **Same-Origin Policy**: Modern browsers restrict web pages from making requests to a different domain than the one they were loaded from for security reasons.
- **CORS (Cross-Origin Resource Sharing)**: Servers can allow cross-origin requests by setting specific headers.
- **Local Development Workaround**: Running a local server helps bypass the same-origin restriction during development.

This security feature ensures that malicious websites cannot steal data from other websites without proper authorization."		
254	AJAX XMLHttp	XMLHttpRequest Object Methods	"### XMLHttpRequest Methods and Properties

The **`XMLHttpRequest`** object provides several methods and properties for interacting with web servers asynchronously. Here's a breakdown of the key methods and properties:

---

### 1. **`new XMLHttpRequest()`**:  
This creates a new **`XMLHttpRequest`** object, which can then be used to send requests to the server and handle responses.

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object
```

---

### 2. **`abort()`**:  
This method cancels the current request if it has not been completed yet. It can be used to stop the request before it finishes.

```javascript
xhttp.abort();  // Cancel the ongoing request
```

---

### 3. **`getAllResponseHeaders()`**:  
This method returns all the response headers as a string. It can be useful when you need to inspect all headers returned by the server.

```javascript
var headers = xhttp.getAllResponseHeaders();
console.log(headers);  // Display all headers in the console
```

---

### 4. **`getResponseHeader()`**:  
This method returns a specific response header by name. It allows you to access a single header value from the server's response.

```javascript
var contentType = xhttp.getResponseHeader(""Content-Type"");
console.log(contentType);  // Log the content type of the response
```

---

### 5. **`open(method, url, async, user, psw)`**:  
This method specifies the request details, such as the type (GET, POST), the URL to send the request to, and whether the request is asynchronous.

- **method**: The request type (GET, POST, PUT, DELETE, etc.).
- **url**: The location of the resource you want to request.
- **async**: If `true`, the request is asynchronous (non-blocking). If `false`, the request is synchronous (blocking). Using asynchronous requests is recommended.
- **user** (optional): Username for authentication.
- **psw** (optional): Password for authentication.

```javascript
xhttp.open(""GET"", ""data.json"", true);  // Example of a GET request (asynchronous)
xhttp.open(""POST"", ""submit.php"", true);  // Example of a POST request
```

---

### 6. **`send()`**:  
This method sends the request to the server. It is used for GET requests without any additional data.

```javascript
xhttp.send();  // Send a GET request to the server
```

For **POST** requests, you can pass data as a string to the `send()` method:

```javascript
xhttp.send(""name=John&amp;age=30"");  // Send data in a POST request
```

---

### 7. **`setRequestHeader()`**:  
This method allows you to add custom headers to your request. It is useful for specifying content types, authentication tokens, or other metadata.

```javascript
xhttp.setRequestHeader(""Content-Type"", ""application/json"");
xhttp.setRequestHeader(""Authorization"", ""Bearer your_token_here"");
```

---

### Full Example:

Here's a full example of making a **GET** request to fetch JSON data and handling the response:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Set up the request (GET method, file location, asynchronous)
xhttp.open(""GET"", ""data.json"", true);

// Define what to do when the request is successful
xhttp.onload = function() {
    if (xhttp.status == 200) {  // If the request was successful (status 200)
        var response = JSON.parse(xhttp.responseText);  // Parse the response (assuming it's JSON)
        console.log(response);  // Display the response in the console
    } else {
        console.error(""Request failed with status "" + xhttp.status);  // Log error if status is not 200
    }
};

// Send the request
xhttp.send();
```

### Summary of Methods and Properties:
- **`new XMLHttpRequest()`**: Creates a new request object.
- **`abort()`**: Cancels an ongoing request.
- **`getAllResponseHeaders()`**: Returns all headers from the response.
- **`getResponseHeader()`**: Returns a specific header from the response.
- **`open(method, url, async, user, psw)`**: Initializes a new request.
- **`send()`**: Sends the request (for GET requests).
- **`send(string)`**: Sends data with the request (for POST requests).
- **`setRequestHeader()`**: Sets custom headers for the request.

These methods and properties provide full control over making asynchronous requests to a server, handling responses, and managing headers for web applications."		
255	AJAX XMLHttp	XMLHttpRequest Object Properties	"### XMLHttpRequest Properties for Handling Requests and Responses

The **`XMLHttpRequest`** object has several important properties that allow you to handle requests, responses, and monitor the status of the request. Here’s an overview of the key properties:

---

### 1. **`onreadystatechange`**:
- **Purpose**: Defines a function to be executed whenever the **`readyState`** property changes.
- **Usage**: This event is triggered every time the state of the **`XMLHttpRequest`** object changes, allowing you to check the **`readyState`** and act based on the request's progress.

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) {  // When request is complete and successful
        console.log(xhttp.responseText);  // Process the response (text)
    }
};
```

---

### 2. **`readyState`**:
- **Purpose**: Holds the status of the **`XMLHttpRequest`** object.
- **Values**:
  - `0`: Request not initialized (not yet called `open()`).
  - `1`: Server connection established (called `open()`, but not sent).
  - `2`: Request received (headers are received).
  - `3`: Processing request (request is being processed by the server).
  - `4`: Request finished and response is ready (response is available).

```javascript
if (xhttp.readyState == 4) {
    console.log(""Request is complete!"");
}
```

---

### 3. **`responseText`**:
- **Purpose**: Returns the response data as a string.
- **Usage**: This property is used to retrieve the content of the server's response (if the response is text-based, such as HTML or plain text).
  
```javascript
var responseText = xhttp.responseText;
console.log(responseText);  // Output the text-based response
```

---

### 4. **`responseXML`**:
- **Purpose**: Returns the response data as **XML** data.
- **Usage**: This property is used when the server returns XML data (e.g., `application/xml` or `text/xml` content types). The response will be returned as an XML DOM object.

```javascript
var responseXML = xhttp.responseXML;
var xmlDoc = responseXML.getElementsByTagName(""name"")[0];
console.log(xmlDoc.childNodes[0].nodeValue);  // Get the value of the ""name"" element in the XML response
```

---

### 5. **`status`**:
- **Purpose**: Returns the status code of the request (indicating the result of the HTTP request).
- **Common Status Codes**:
  - `200`: ""OK"" (Request was successful).
  - `403`: ""Forbidden"" (Access is denied).
  - `404`: ""Not Found"" (Requested resource could not be found).
  - **For a complete list of HTTP status codes**, check the [HTTP Status Code Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).

```javascript
if (xhttp.status == 200) {
    console.log(""Request was successful!"");
} else {
    console.log(""Error with request. Status: "" + xhttp.status);
}
```

---

### 6. **`statusText`**:
- **Purpose**: Returns the status text (e.g., ""OK"" for a successful request or ""Not Found"" for a 404 error).
- **Usage**: This property provides a human-readable status message associated with the HTTP status code.
  
```javascript
console.log(""Status Code: "" + xhttp.status);  // e.g., 200
console.log(""Status Text: "" + xhttp.statusText);  // e.g., ""OK""
```

---

### Example of Using XMLHttpRequest with These Properties:

Here’s an example that demonstrates how to use the **`onreadystatechange`**, **`readyState`**, **`responseText`**, **`status`**, and **`statusText`** properties:

```javascript
var xhttp = new XMLHttpRequest();

// Set up the request
xhttp.onreadystatechange = function() {
    if (xhttp.readyState == 4) {  // Request is complete
        if (xhttp.status == 200) {  // Request was successful
            console.log(""Response Text: "" + xhttp.responseText);  // Log the response text
        } else {
            console.log(""Error: "" + xhttp.status + "" - "" + xhttp.statusText);  // Log error status and text
        }
    }
};

// Make a GET request to ""data.json""
xhttp.open(""GET"", ""data.json"", true);
xhttp.send();
```

In this example:
- The `onreadystatechange` function is triggered every time the request's state changes.
- The **`readyState == 4`** condition checks if the request is completed.
- **`status == 200`** checks if the request was successful.
- The response is processed using **`responseText`** (for text responses).

### Summary of Key Properties:
- **`onreadystatechange`**: Defines a function to be called when `readyState` changes.
- **`readyState`**: Indicates the current state of the request.
- **`responseText`**: Returns the response data as text.
- **`responseXML`**: Returns the response data as XML (if applicable).
- **`status`**: Returns the HTTP status code of the request (e.g., `200`, `404`).
- **`statusText`**: Provides the status text related to the status code (e.g., `""OK""`, `""Not Found""`).

These properties give you full control over sending and handling asynchronous HTTP requests using the **`XMLHttpRequest`** object."		
256	AJAX request	Send a Request To a Server	"### Using the `XMLHttpRequest` Object to Send Requests

The **`XMLHttpRequest`** object is used to send requests to a server and handle responses asynchronously. You can send both **GET** and **POST** requests using the `open()` and `send()` methods.

### Key Methods:

---

### 1. **`open(method, url, async)`**:

- **Purpose**: The `open()` method initializes a new request by specifying the type of request, the server URL, and whether the request should be asynchronous.
- **Parameters**:
  - **`method`**: The HTTP request method (e.g., `""GET""`, `""POST""`).
  - **`url`**: The URL or file path to send the request to (e.g., `""ajax_info.txt""`).
  - **`async`**: A boolean value (`true` or `false`) that determines if the request should be asynchronous. If `true`, the request is asynchronous (non-blocking). If `false`, the request is synchronous (blocking).

**Syntax**:
```javascript
xhttp.open(""GET"", ""ajax_info.txt"", true);
```

In this example:
- `""GET""`: The type of request.
- `""ajax_info.txt""`: The file being requested.
- `true`: The request will be asynchronous.

---

### 2. **`send()`**:

- **Purpose**: The `send()` method sends the request to the server.
  - **Used for GET**: The `send()` method is called without any data when the request type is **GET**.
  - **Used for POST**: The `send(string)` method is called with data when the request type is **POST**.

**Syntax for GET Request**:
```javascript
xhttp.send();  // Send a GET request to the server
```

**Syntax for POST Request**:
```javascript
xhttp.send(""name=John&amp;age=30"");  // Send a POST request with data
```

---

### Example of Sending a GET Request:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Set up the request: GET method, file location ""ajax_info.txt"", asynchronous request
xhttp.open(""GET"", ""ajax_info.txt"", true);

// Define what to do when the request is complete
xhttp.onload = function() {
    if (xhttp.status == 200) {  // Check if the request was successful (status 200)
        console.log(xhttp.responseText);  // Log the response from the server
    }
};

// Send the GET request
xhttp.send();
```

In this example:
1. The request is initialized with **GET** method and the URL **`ajax_info.txt`**.
2. The request is sent asynchronously (as `true` is passed for the `async` parameter).
3. The **`onload`** event handler is used to process the response once the request is completed.

---

### Example of Sending a POST Request:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Set up the request: POST method, file location ""submit_form.php"", asynchronous request
xhttp.open(""POST"", ""submit_form.php"", true);

// Set the request header for sending form data (e.g., application/x-www-form-urlencoded)
xhttp.setRequestHeader(""Content-Type"", ""application/x-www-form-urlencoded"");

// Define what to do when the request is complete
xhttp.onload = function() {
    if (xhttp.status == 200) {  // Check if the request was successful (status 200)
        console.log(xhttp.responseText);  // Log the response from the server
    }
};

// Send the POST request with form data (name=John&amp;age=30)
xhttp.send(""name=John&amp;age=30"");
```

In this example:
1. The request is initialized with **POST** method and the URL **`submit_form.php`**.
2. The `setRequestHeader()` method is used to set the **Content-Type** header to **`application/x-www-form-urlencoded`**, which is commonly used for sending form data.
3. The **`send()`** method sends the data (in the format `name=John&amp;age=30`) to the server.

---

### Summary of Key Methods:
- **`open(method, url, async)`**: Initializes a request with a specified HTTP method (`GET`, `POST`), a URL, and the asynchronous flag (`true` for asynchronous, `false` for synchronous).
- **`send()`**: Sends the request to the server (use without data for **GET**).
- **`send(string)`**: Sends the request with data (use for **POST**).

These methods give you the flexibility to make both **GET** and **POST** requests asynchronously, allowing you to create dynamic and responsive web applications."		
257	AJAX request	GET or POST?	"### When to Use GET vs POST in HTTP Requests

While **GET** requests are often simpler and faster, **POST** requests are necessary in certain scenarios due to their greater flexibility and security. Here's a breakdown of when to use each request method:

### **GET** Method:
- **Simpler and Faster**: Since GET requests send data as part of the URL (in the query string), they are typically quicker and easier to implement.
- **Caching**: GET requests can be cached by the browser, making them suitable for retrieving data that doesn’t change often (e.g., getting information from a public API, or retrieving a page).
- **Data Size Limitations**: GET requests have limitations on the amount of data that can be sent, as the data is passed in the URL. This can cause issues when dealing with large amounts of data.
- **URL Visibility**: GET requests append the data to the URL, which means that the data is visible in the browser’s address bar, and can be bookmarked or shared. This is not always desirable for sensitive information.

### **When to Use POST Requests**:

Although GET is suitable for most cases, **POST** requests should be used in the following situations:

---

### 1. **When Caching Is Not an Option**:
   - **Use POST when you need to update data on the server**, such as when submitting a form or updating a database.
   - **GET** should not be used for actions that modify data, as these can be cached by the browser or indexed by search engines. **POST** ensures that the request is not cached, which is essential for operations like form submissions or updating records.

   **Example**: Updating user information in a database or saving data to a server:
   ```javascript
   xhttp.open(""POST"", ""update_user.php"", true);
   xhttp.send(""username=JohnDoe&amp;email=john.doe@example.com"");
   ```

---

### 2. **When Sending a Large Amount of Data**:
   - **POST** is more suitable for sending large amounts of data to the server, as there are no size limitations like there are with **GET** requests.
   - **GET** requests append data to the URL in the form of query parameters, and this method is constrained by the browser's URL length limit (which can be as low as 2000 characters depending on the browser).
   - **POST** allows you to send large bodies of data (such as file uploads, form data, JSON, etc.) without worrying about exceeding size limits.

   **Example**: Sending a large file or long form data:
   ```javascript
   xhttp.open(""POST"", ""upload_file.php"", true);
   var formData = new FormData();
   formData.append(""file"", fileInput.files[0]);  // File input element
   xhttp.send(formData);
   ```

---

### 3. **When Sending User Input (Especially Sensitive Data)**:
   - **POST** requests are more secure than **GET** requests, as the data is sent in the request body, not in the URL. This means that **POST** requests do not expose sensitive information, such as passwords or credit card details, in the browser's address bar.
   - **GET** is not suitable for sending sensitive or private information, as it could be stored in browser history or logged by web servers and proxies.
   - **POST** provides a more **robust** mechanism for sending potentially large or complex data, including form data with special characters or files.

   **Example**: Sending a password or other sensitive information:
   ```javascript
   xhttp.open(""POST"", ""login.php"", true);
   xhttp.setRequestHeader(""Content-Type"", ""application/x-www-form-urlencoded"");
   xhttp.send(""username=johndoe&amp;password=securepassword123"");
   ```

---

### Summary of When to Use POST:
- **POST** should always be used when:
  - You need to **update a file or database** on the server (GET should only be used for retrieving data, not modifying it).
  - **Sending a large amount of data** to the server (GET has size limitations on the data).
  - You are sending **sensitive user input** (e.g., passwords, payment details), as **POST** does not expose the data in the URL, unlike GET.

In general, **GET** is for **retrieving data** or requesting resources (when the action does not alter data), while **POST** is for **submitting data** or performing actions that change data on the server. Always consider the data size, security, and the type of operation when deciding whether to use GET or POST."		
258	AJAX request	GET Requests	"### Simple GET Request and Techniques to Prevent Caching

The **GET** request is used to retrieve data from the server. Here’s a basic breakdown of how to perform a **GET** request using **`XMLHttpRequest`**, and some common techniques to handle caching and sending data along with the request.

### Basic GET Request Example:

```javascript
xhttp.open(""GET"", ""demo_get.asp"", true);  // Initialize the GET request
xhttp.send();  // Send the request to the server
```

In this example, the **GET** request is made to **`demo_get.asp`**, and since it is an asynchronous request (`true` for `async`), it will not block the rest of the page while waiting for the response.

---

### Preventing Caching of GET Requests:

Browsers often cache GET requests to optimize performance. However, if you want to avoid retrieving a cached response (e.g., you want fresh data each time), you can add a **unique query parameter** to the URL. One common approach is to append a random value or timestamp as a query parameter, which ensures the URL is always unique.

```javascript
xhttp.open(""GET"", ""demo_get.asp?t="" + Math.random(), true);  // Add a random query parameter
xhttp.send();  // Send the request
```

In this example:
- **`Math.random()`** generates a random number that gets appended as a query parameter (`t=xxxxxxx`), ensuring that each request has a unique URL, preventing the browser from using a cached version.

---

### Sending Information with a GET Request:

To send data with a **GET** request, you can append the data as query parameters in the URL. For example, if you want to send a first name and last name to the server:

```javascript
xhttp.open(""GET"", ""demo_get2.asp?fname=Henry&amp;lname=Ford"", true);  // Add data to the URL
xhttp.send();  // Send the request with the data
```

In this example:
- The **GET** request is made to **`demo_get2.asp`** with two query parameters:
  - `fname=Henry`
  - `lname=Ford`
- The server will receive these parameters in the URL and can process them accordingly.

### Notes:
- **GET requests** should generally be used for **retrieving data**. Data sent with a GET request is appended in the URL, which makes it **visible** in the address bar.
- **Data size limitations**: GET requests have limitations on the amount of data you can send since the data is part of the URL. This can lead to issues if you try to send too much data.

---

### Example Summary:

1. **Basic GET Request** (without data):
   ```javascript
   xhttp.open(""GET"", ""demo_get.asp"", true);
   xhttp.send();
   ```

2. **Prevent Caching** (adding a random query parameter):
   ```javascript
   xhttp.open(""GET"", ""demo_get.asp?t="" + Math.random(), true);
   xhttp.send();
   ```

3. **Send Data with GET** (sending parameters):
   ```javascript
   xhttp.open(""GET"", ""demo_get2.asp?fname=Henry&amp;lname=Ford"", true);
   xhttp.send();
   ```

Using these methods, you can make **GET requests**, prevent caching, and send data to the server, making your web application more dynamic and efficient."		
259	AJAX request	POST Requests	"### Sending a POST Request with XMLHttpRequest

The **POST** request is used to send data to a server, usually when submitting form data or sending large amounts of information. Unlike **GET** requests, the data in a **POST** request is sent in the request body, not the URL.

### Basic POST Request Example:

Here’s a simple example of how to send a **POST** request:

```javascript
xhttp.open(""POST"", ""demo_post.asp"", true);
xhttp.send();
```

In this example:
- `""POST""` specifies that the request is a **POST** request.
- `""demo_post.asp""` is the target URL or resource on the server where the request will be sent.
- The request is asynchronous (`true`), meaning it won't block other code while waiting for a response.

However, when sending data with a **POST** request, you need to specify the appropriate HTTP header and the data to be sent in the request body.

---

### Sending Data with a POST Request:

When you want to send data (e.g., form data) with a **POST** request, you need to:

1. Set the **`Content-Type`** header to indicate the type of data you're sending (typically `application/x-www-form-urlencoded` for form data).
2. Specify the data you want to send in the **`send()`** method.

Here’s how to send data with a **POST** request:

```javascript
xhttp.open(""POST"", ""ajax_test.asp"", true);  // Open the POST request

// Add the Content-Type header to specify the type of data
xhttp.setRequestHeader(""Content-type"", ""application/x-www-form-urlencoded"");

// Send the data (formatted as a URL-encoded string)
xhttp.send(""fname=Henry&amp;lname=Ford"");
```

### How It Works:
1. **`xhttp.open(""POST"", ""ajax_test.asp"", true)`**: Initializes a **POST** request to **`ajax_test.asp`**.
2. **`xhttp.setRequestHeader(""Content-type"", ""application/x-www-form-urlencoded"")`**: Sets the request header to inform the server that the data being sent is in URL-encoded format (commonly used for form submissions).
3. **`xhttp.send(""fname=Henry&amp;lname=Ford"")`**: Sends the form data in the **POST** request body as a URL-encoded string (`""fname=Henry&amp;lname=Ford""`).

### Important Notes:
- **Data Format**: The data in a **POST** request is sent in the request body, unlike **GET** requests where data is sent in the URL. The **`Content-type`** header specifies the format of the data. For simple form submissions, `application/x-www-form-urlencoded` is the most common format.
- **Sending Form Data**: If you're sending multiple values from an HTML form, you can build the URL-encoded string dynamically using JavaScript. Alternatively, you can use **FormData** to send form data with files (e.g., for uploading files).

---

### Adding HTTP Headers with `setRequestHeader()`:

The **`setRequestHeader()`** method allows you to add custom headers to the request. These headers are useful when you need to specify the type of data you're sending, authentication tokens, or custom headers required by the server.

**Syntax**:
```javascript
xhttp.setRequestHeader(header, value);
```
- **`header`**: The name of the header (e.g., `""Content-type""`, `""Authorization""`).
- **`value`**: The value of the header (e.g., `""application/x-www-form-urlencoded""` for form data).

### Example of Setting Custom Headers:
```javascript
xhttp.open(""POST"", ""submit_form.php"", true);
xhttp.setRequestHeader(""Content-type"", ""application/x-www-form-urlencoded"");
xhttp.setRequestHeader(""Authorization"", ""Bearer your_token_here"");
xhttp.send(""name=JohnDoe&amp;email=john.doe@example.com"");
```

In this example:
- The **`Content-type`** header is set to `application/x-www-form-urlencoded`, indicating the data format.
- The **`Authorization`** header is set to a bearer token for authentication.

### Summary:
- **POST requests** are used to send data to the server (e.g., submitting form data).
- Use **`setRequestHeader()`** to specify the **Content-type** (e.g., `application/x-www-form-urlencoded` for form data).
- Use **`send()`** to send the data in the request body, either as a URL-encoded string or other formats.
- You can also set additional headers like **`Authorization`** for security purposes.

By using these techniques, you can send data securely and efficiently to the server using **POST** requests."		
260	AJAX request	The url - A File On a Server	"### The `url` Parameter in the `open()` Method

In the **`XMLHttpRequest.open()`** method, the **`url`** parameter specifies the location of the resource (file or server-side script) that the request is being sent to. The **`url`** can point to any type of file hosted on a web server.

### Types of Files for the `url` Parameter:

1. **Static Files**:
   - **Text Files** (`.txt`): Simple text files containing data that can be read by JavaScript.
   - **XML Files** (`.xml`): XML files can be used to return structured data that JavaScript can parse and process.
   - **JSON Files** (`.json`): JSON files are commonly used for sending and receiving structured data in a more compact and easily parsed format.
   
   Example:
   ```javascript
   xhttp.open(""GET"", ""data.txt"", true);  // Request a .txt file
   xhttp.send();
   ```

2. **Dynamic Files** (Server-Side Scripting Files):
   - **ASP Files** (`.asp`): **Active Server Pages** are server-side scripts that are processed by the server before the data is sent back to the client.
   - **PHP Files** (`.php`): **PHP** scripts are executed on the server and can perform tasks like interacting with databases before returning the response.

   Example:
   ```javascript
   xhttp.open(""GET"", ""ajax_test.asp"", true);  // Request a server-side ASP file
   xhttp.send();
   ```

   - **Node.js Files** (`.js`): JavaScript files on the server can handle requests and responses dynamically.
   - **Other Scripting Files**: Files like `.cgi` (Common Gateway Interface) and `.pl` (Perl scripts) can also be used in the same way to process server-side logic before responding.

### Example of Using `open()` with Different File Types:

1. **Requesting a Text File (.txt)**:
   ```javascript
   xhttp.open(""GET"", ""data.txt"", true);  // Request a plain text file
   xhttp.send();
   ```

2. **Requesting an XML File (.xml)**:
   ```javascript
   xhttp.open(""GET"", ""data.xml"", true);  // Request an XML file
   xhttp.send();
   ```

3. **Requesting a Server-Side Script (e.g., PHP)**:
   ```javascript
   xhttp.open(""GET"", ""process_data.php?user=JohnDoe"", true);  // Request a PHP file that processes data
   xhttp.send();
   ```

4. **Requesting an ASP File**:
   ```javascript
   xhttp.open(""GET"", ""get_user_info.asp?id=123"", true);  // Request an ASP file with parameters
   xhttp.send();
   ```

### Server-Side Processing:
- For dynamic server-side scripting files like **ASP** or **PHP**, the server processes the script (e.g., interacting with a database, performing calculations) before sending back the result.
- **AJAX** allows you to send data to these server-side scripts (via the URL or request body), which can then return a processed response to be used in the web page (e.g., displaying user-specific data).

### Example of Dynamic Data Handling:
- A **PHP** file (`process_data.php`) might interact with a database, retrieve user information, and return the result in a format (like JSON or plain text) that JavaScript can process.
  
  ```php
  <!--?php
    // process_data.php
    $name = $_GET['name'];  // Get name from the query string
    echo ""Hello, "" . htmlspecialchars($name) . ""!"";
  ?-->
  ```

- JavaScript (AJAX) can send a request to this PHP script:

  ```javascript
  var xhttp = new XMLHttpRequest();
  xhttp.open(""GET"", ""process_data.php?name=John"", true);  // Send the name as a query parameter
  xhttp.onload = function() {
      if (xhttp.status == 200) {
          console.log(xhttp.responseText);  // Output the response from the PHP file
      }
  };
  xhttp.send();
  ```

### Summary:
The **`url`** parameter in the **`XMLHttpRequest.open()`** method specifies the location of the file on the server:
- It can point to static files like `.txt`, `.xml`, or `.json`.
- It can also point to dynamic files like `.asp`, `.php`, or other server-side scripts that process data before sending the response back to the client.

This flexibility allows you to use **AJAX** to interact with both static and dynamic resources, enabling web applications to load and send data without refreshing the entire page."		
261	AJAX request	Asynchronous - True or False?	"### Sending Asynchronous Requests with `XMLHttpRequest`

When making server requests using the **`XMLHttpRequest`** object, it's typically best to send the requests asynchronously. This allows the webpage to continue executing other tasks while waiting for the server's response, resulting in a smoother user experience and improved performance.

### Asynchronous Requests

In **asynchronous mode**, the JavaScript does not block the rest of the page while it waits for the server response. The browser is free to perform other tasks (like rendering updates, executing other scripts, etc.) while waiting for the response.

### Setting `async` to `true`

To send an asynchronous request, the **`async`** parameter in the **`open()`** method should be set to `true`:

```javascript
xhttp.open(""GET"", ""ajax_test.asp"", true);
```

### How It Works:

1. **`open(""GET"", ""ajax_test.asp"", true)`**:
   - **`GET`** specifies the type of HTTP request (GET in this case).
   - **`""ajax_test.asp""`** is the URL to which the request is being sent.
   - **`true`** sets the request to be asynchronous. The JavaScript does not wait for the server’s response before moving on to the next task.

2. **Asynchronous Execution**:
   - After the request is made, JavaScript can continue executing other tasks.
   - Once the server responds, the **`onload`** or **`onreadystatechange`** event handler is triggered, allowing the JavaScript to handle the response when it's ready.

---

### Example of Asynchronous GET Request:

Here’s an example of an **asynchronous** **GET** request:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Define the function to handle the response when it's ready
xhttp.onload = function() {
    if (xhttp.status == 200) {
        console.log(""Response: "" + xhttp.responseText);  // Process the response text
    }
};

// Open the request (GET method, asynchronous, target file)
xhttp.open(""GET"", ""ajax_test.asp"", true);

// Send the request
xhttp.send();

// Continue executing other tasks while waiting for the response
console.log(""Request sent, but other tasks can execute."");
```

### Breakdown:
1. The **GET** request is sent asynchronously (since `true` is passed for the **`async`** parameter).
2. **JavaScript does not wait for the response** and continues executing other code. In this example, the message `""Request sent, but other tasks can execute.""` will be logged immediately after sending the request.
3. When the server responds and the **`onload`** event is triggered, the response is processed.

### Advantages of Asynchronous Requests:
- **Non-blocking**: Asynchronous requests allow the browser to continue processing other scripts, updates, or animations without being blocked by waiting for the server’s response.
- **Improved User Experience**: Since the user can interact with the page while the request is being processed, it makes the application feel faster and more responsive.
- **Better Performance**: While the browser is waiting for a response from the server, it can continue executing other tasks (like rendering new content or handling user input).

### Example Use Case:
If you were building a dynamic search feature that queries a database every time the user types a letter, using asynchronous requests would allow the page to continue processing while waiting for the query to return the results. The user can keep typing, and once the results are ready, they are displayed.

### Conclusion:
Setting **`async` to `true`** allows you to send asynchronous requests with **`XMLHttpRequest`**, meaning that JavaScript can continue executing other tasks while waiting for the server’s response. This is crucial for creating fast and responsive web applications."		
262	AJAX request	The onreadystatechange Property	"### Handling Responses with the `onreadystatechange` Property in `XMLHttpRequest`

The **`onreadystatechange`** property of the **`XMLHttpRequest`** object is used to define a function that will be executed whenever the **`readyState`** property of the request changes. This allows you to track the progress of the request and handle the response once it's fully received.

### Key Concepts:

1. **`readyState`**: The state of the request. It can take one of the following values:
   - `0`: Request not initialized.
   - `1`: Server connection established.
   - `2`: Request received.
   - `3`: Processing request.
   - `4`: Request finished and response is ready (this is when the data is available).

2. **`status`**: The HTTP status code of the response, such as `200` for a successful request, `404` for ""Not Found,"" etc.

### Example Code:

Here is how to use **`onreadystatechange`** to define a function that is called when the request receives a response:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Define the function to handle the request's state changes
xhttp.onreadystatechange = function() {
    // Check if the request is complete (readyState == 4) and successful (status == 200)
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Update the content of the HTML element with the ID ""demo""
        document.getElementById(""demo"").innerHTML = this.responseText;
    }
};

// Open the GET request to ""ajax_info.txt"" and set it to be asynchronous (true)
xhttp.open(""GET"", ""ajax_info.txt"", true);

// Send the request
xhttp.send();
```

### Breakdown of the Example:

1. **Creating the `XMLHttpRequest` Object**:
   - `var xhttp = new XMLHttpRequest();` creates a new request object.

2. **Setting `onreadystatechange` Handler**:
   - **`xhttp.onreadystatechange = function() {}`** defines the function that will be executed every time the `readyState` property of the request changes.
   - **`this.readyState == 4`** checks if the request has completed.
   - **`this.status == 200`** checks if the request was successful (status code `200` means ""OK"").
   - **`this.responseText`** contains the response from the server, which is placed inside the HTML element with the ID `""demo""` using **`innerHTML`**.

3. **Opening the Request**:
   - **`xhttp.open(""GET"", ""ajax_info.txt"", true);`** initializes the **GET** request to the file `""ajax_info.txt""` and sets it to be asynchronous (`true`).

4. **Sending the Request**:
   - **`xhttp.send();`** sends the request to the server.

---

### When Does the `onreadystatechange` Handler Execute?

The **`onreadystatechange`** function is called multiple times as the **`readyState`** changes. Here’s the order of events:
1. **`readyState == 0`**: The request has not been initialized.
2. **`readyState == 1`**: The connection to the server has been established.
3. **`readyState == 2`**: The server has received the request.
4. **`readyState == 3`**: The server is processing the request (data is still being received).
5. **`readyState == 4`**: The request has been completed, and the response is ready.

To avoid unnecessary function calls, the **`if (this.readyState == 4 &amp;&amp; this.status == 200)`** condition ensures that the function only runs once the request is complete and successful.

---

### Advantages of Using `onreadystatechange`:

- **Asynchronous Handling**: By using `onreadystatechange`, you allow the browser to continue executing other tasks while waiting for the server response, ensuring a responsive user experience.
- **State Monitoring**: You can track the request’s progress through different states (e.g., while the server is processing), and take action accordingly.

### Example Use Case:

Imagine an interactive webpage where you want to load new data (such as user comments, blog posts, etc.) without refreshing the page. The `onreadystatechange` method can help handle these requests smoothly:

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        document.getElementById(""commentsSection"").innerHTML = this.responseText;
    }
};
xhttp.open(""GET"", ""load_comments.php"", true);
xhttp.send();
```

In this case, the function will be executed when the request completes, and the **responseText** (the new comments) will be inserted into the **`commentsSection`** of the webpage without needing a page reload.

---

### Summary:
- The **`onreadystatechange`** property allows you to define a function that is triggered whenever the **`readyState`** of an **`XMLHttpRequest`** changes.
- It is used to handle responses asynchronously, allowing you to update parts of a page based on the server's response.
- The **`readyState == 4`** and **`status == 200`** conditions ensure that the function is executed only when the request is completed successfully."		
263	AJAX request	Synchronous Request	"### Synchronous XMLHttpRequest

In **synchronous requests**, JavaScript will wait for the server response before continuing to execute any further code. While this behavior can be useful in certain situations (e.g., testing or small scripts), **synchronous XMLHttpRequest** is generally not recommended in modern web development due to the potential for performance issues.

### Syntax for Synchronous Request:
To execute a **synchronous** request, you need to set the third parameter of the **`open()`** method to **`false`**.

```javascript
xhttp.open(""GET"", ""ajax_info.txt"", false);  // Synchronous request (async = false)
xhttp.send();
document.getElementById(""demo"").innerHTML = xhttp.responseText;  // Display the response
```

### Explanation:
1. **`xhttp.open(""GET"", ""ajax_info.txt"", false);`**: This sends a **GET** request to the `ajax_info.txt` file. The `false` parameter sets the request to be **synchronous**.
2. **`xhttp.send();`**: This sends the request to the server. Since the request is synchronous, JavaScript will **wait** until the server responds.
3. **`document.getElementById(""demo"").innerHTML = xhttp.responseText;`**: Once the server responds, the content of the **`demo`** element is updated with the response text.

---

### Why Synchronous XMLHttpRequest is Not Recommended:
While synchronous requests might seem straightforward, they can lead to several problems, especially in modern web applications.

1. **Blocking the Main Thread**:
   - When a synchronous request is made, **JavaScript stops executing** and waits for the server's response. During this time, the browser's UI (User Interface) is **frozen**.
   - This means that the user cannot interact with the webpage (e.g., clicking buttons, scrolling, etc.) while the request is being processed. This can lead to a poor user experience, especially if the server is slow or busy.

2. **Performance and Responsiveness**:
   - Synchronous requests can make your application feel sluggish, especially if the server takes time to respond.
   - If the server is experiencing heavy load or latency issues, the user might face long delays or even **hang** the application.

3. **Not Future-Proof**:
   - **Synchronous XMLHttpRequest** is being phased out as it is considered a bad practice. Modern browsers may issue warnings or throw exceptions (e.g., **`InvalidAccessError`**) when synchronous requests are used.

4. **Modern Development Tools Warnings**:
   - Many modern developer tools (like those in Chrome or Firefox) now warn developers when synchronous XMLHttpRequest is being used, and they may throw errors when trying to run synchronous requests in certain situations.

---

### Example of Problem with Synchronous Request:
Imagine you are trying to fetch data from a server, and the server is slow. With synchronous requests, the entire page will **freeze** until the server responds, causing a poor user experience:

```javascript
xhttp.open(""GET"", ""ajax_info.txt"", false);  // Synchronous request
xhttp.send();  // JavaScript execution is paused here until the server responds
document.getElementById(""demo"").innerHTML = xhttp.responseText;
```

If the server is slow, the user cannot interact with the page during that time, leading to frustration.

---

### Best Practice: Use Asynchronous Requests (async = true)

Modern web development encourages the use of **asynchronous requests**, where the code doesn't block while waiting for the server's response. This allows the browser to continue processing user interactions and updating the page while the request is in progress.

```javascript
xhttp.open(""GET"", ""ajax_info.txt"", true);  // Asynchronous request (async = true)
xhttp.send();
xhttp.onload = function() {
    if (xhttp.status == 200) {
        document.getElementById(""demo"").innerHTML = xhttp.responseText;
    }
};
```

### Advantages of Asynchronous Requests:
1. **Non-blocking**: The page remains interactive while waiting for the server's response.
2. **Improved User Experience**: Users can continue using the application without interruptions.
3. **Better Performance**: Asynchronous requests don't block the main thread, resulting in smoother and faster applications.

---

### Conclusion:
- **Synchronous XMLHttpRequest** (using `async = false`) is **not recommended** for modern web applications due to its blocking nature.
- It should only be used in **specific cases** (e.g., quick testing or when synchronous behavior is absolutely required).
- Developers should use **asynchronous requests** (`async = true`) for better performance, responsiveness, and user experience.

As **synchronous XMLHttpRequest** is being phased out, modern browsers and development tools are encouraging developers to adopt asynchronous methods to improve web application performance and interactivity."		
264	AJAX response	The onreadystatechange Property	"### Understanding the `XMLHttpRequest` Properties and Methods

The **`XMLHttpRequest`** object provides several properties to track the state of a request and handle responses. Two of the most important properties are **`readyState`** and **`onreadystatechange`**, which work together to allow you to monitor and act on the request’s state changes.

---

### Key Properties of `XMLHttpRequest`:

1. **`onreadystatechange`**:  
   This property defines a function that will be called whenever the **`readyState`** property changes. This function allows you to track the state of the request and handle the response once it's fully received.

   Example:
   ```javascript
   xhttp.onreadystatechange = function() {
       if (this.readyState == 4 &amp;&amp; this.status == 200) {
           // Handle the response here
           console.log(this.responseText);
       }
   };
   ```

2. **`readyState`**:  
   The **`readyState`** property holds the current state of the **`XMLHttpRequest`**. The state transitions through the following values:
   - **0**: Request not initialized.
   - **1**: Server connection established.
   - **2**: Request received.
   - **3**: Processing request (e.g., receiving data from the server).
   - **4**: Request finished, and the response is ready.

   Example:
   ```javascript
   if (xhttp.readyState == 4) {
       console.log(""Request completed!"");
   }
   ```

3. **`status`**:  
   The **`status`** property contains the HTTP status code of the response. This property is important for determining whether the request was successful or failed.
   - **200**: ""OK"" (Request was successful).
   - **404**: ""Not Found"" (Requested resource does not exist).
   - **403**: ""Forbidden"" (Access to the resource is denied).

   Example:
   ```javascript
   if (xhttp.status == 200) {
       console.log(""Request was successful."");
   } else {
       console.log(""Error: "" + xhttp.status);
   }
   ```

4. **`statusText`**:  
   The **`statusText`** property holds a string representing the status message returned by the server, such as `""OK""` for a successful request or `""Not Found""` for a 404 error.

   Example:
   ```javascript
   console.log(""Status: "" + xhttp.statusText);  // e.g., ""OK""
   ```

---

### Example of Using `onreadystatechange` and `readyState`:

Here’s an example that demonstrates the usage of **`onreadystatechange`**, **`readyState`**, **`status`**, and **`statusText`** to handle an asynchronous **GET** request:

```javascript
function loadDoc() {
    var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

    // Define the function to handle changes in readyState
    xhttp.onreadystatechange = function() {
        // Check if the request is complete (readyState == 4) and successful (status == 200)
        if (this.readyState == 4 &amp;&amp; this.status == 200) {
            // Update the HTML element with ID ""demo"" with the response
            document.getElementById(""demo"").innerHTML = this.responseText;
        }
    };

    // Open the request (GET method, asynchronous, target file ""ajax_info.txt"")
    xhttp.open(""GET"", ""ajax_info.txt"", true);

    // Send the request to the server
    xhttp.send();
}
```

### Breakdown:
1. **Create an `XMLHttpRequest` object**: 
   - `var xhttp = new XMLHttpRequest();`
2. **Set up the `onreadystatechange` event handler**: 
   - Every time the **`readyState`** changes, this function is executed.
3. **Check if the request is complete and successful**:
   - `if (this.readyState == 4 &amp;&amp; this.status == 200)` ensures the request is fully completed and was successful.
4. **Update the page with the server response**:
   - `document.getElementById(""demo"").innerHTML = this.responseText;` updates the content of the HTML element with the response from the server.
5. **Send the GET request**:
   - `xhttp.open(""GET"", ""ajax_info.txt"", true)` initializes the request.
   - `xhttp.send()` sends the request to the server.

### `readyState` Changes:

The **`onreadystatechange`** function is triggered whenever the **`readyState`** changes. It can trigger four times, once for each change in **`readyState`**:

1. **`readyState == 0`**: The request has not been initialized (not yet called `open()`).
2. **`readyState == 1`**: The request has been set up (called `open()`, but not sent).
3. **`readyState == 2`**: The request has been sent, and the server has received it (headers are received).
4. **`readyState == 3`**: The request is being processed (data is being downloaded or sent).
5. **`readyState == 4`**: The request is complete, and the response is available.

### Why Use `readyState` and `onreadystatechange`?

- **Asynchronous Communication**: By checking **`readyState`** and handling the **`onreadystatechange`** event, you can monitor the progress of the request and handle it once the response is ready without blocking the user interface.
- **Error Handling**: You can handle cases where the server is slow or returns an error by checking both **`readyState`** and **`status`**.

---

### Summary:

- **`onreadystatechange`**: Defines a function to be executed when **`readyState`** changes.
- **`readyState`**: Indicates the state of the **`XMLHttpRequest`** (from initialization to completed request).
- **`status`**: HTTP status code returned by the server (e.g., `200` for success, `404` for ""Not Found"").
- **`statusText`**: The status text that corresponds to the status code (e.g., `""OK""` for `200`).

By monitoring **`readyState`** and using **`onreadystatechange`**, you can create responsive, asynchronous web applications that update parts of the page without requiring a full reload."		
265	AJAX response	Using a Callback Function	"### Using Callback Functions with AJAX Requests

A **callback function** is a function passed as an argument to another function, which is executed once the parent function finishes its task. In the context of **AJAX requests**, callback functions are particularly useful because they allow you to specify different actions for each AJAX request, while using the same function to execute the request itself.

### Benefits:
- **Code Reusability**: By using a generic function like `loadDoc()`, you can perform multiple AJAX tasks without duplicating code.
- **Flexible Action Handling**: You can specify different actions for each request by passing different callback functions.

### Example Explanation:

Here’s how to structure a system where multiple AJAX requests can be made, and each request has its own callback function.

---

### `loadDoc` Function with Callback:

```javascript
function loadDoc(url, cFunction) {
    var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

    // Define the onreadystatechange handler
    xhttp.onreadystatechange = function() {
        if (this.readyState == 4 &amp;&amp; this.status == 200) {
            cFunction(this);  // Call the provided callback function when the request is done
        }
    };

    // Initialize and send the GET request
    xhttp.open(""GET"", url, true);
    xhttp.send();
}
```

### Explanation:
- **`url`**: The URL of the resource to request.
- **`cFunction`**: The callback function that will be executed once the response is ready (when `readyState` is `4` and `status` is `200`).
- **`xhttp.onreadystatechange`**: This function checks the status of the request. When the request is finished (readyState 4) and successful (status 200), it invokes the callback function (`cFunction`), passing the **`XMLHttpRequest`** object (`this`) as an argument.
  
---

### Example Callback Functions:

1. **Callback Function 1:**

```javascript
function myFunction1(xhttp) {
    // Action to perform when the response from ""url-1"" is received
    document.getElementById(""demo1"").innerHTML = xhttp.responseText;
}
```

2. **Callback Function 2:**

```javascript
function myFunction2(xhttp) {
    // Action to perform when the response from ""url-2"" is received
    document.getElementById(""demo2"").innerHTML = xhttp.responseText;
}
```

### Example of Calling `loadDoc` with Different URLs and Callbacks:

Now, you can use the `loadDoc` function to send AJAX requests to different URLs and perform different actions (callback functions) for each one:

```javascript
loadDoc(""url-1"", myFunction1);  // Load data from ""url-1"" and pass it to myFunction1
loadDoc(""url-2"", myFunction2);  // Load data from ""url-2"" and pass it to myFunction2
```

### How it Works:
1. **`loadDoc(""url-1"", myFunction1)`**:
   - The `loadDoc` function sends a **GET** request to `""url-1""`.
   - Once the response is received, **`myFunction1`** is called with the **`XMLHttpRequest`** object (`xhttp`), and it will update the content of the HTML element with the ID `""demo1""`.

2. **`loadDoc(""url-2"", myFunction2)`**:
   - Similarly, `loadDoc` sends a **GET** request to `""url-2""`.
   - Once the response is received, **`myFunction2`** is called with the **`XMLHttpRequest`** object (`xhttp`), and it will update the content of the HTML element with the ID `""demo2""`.

### Advantages of Using Callback Functions:

- **Code Reusability**: You can reuse the `loadDoc` function to handle different AJAX requests by passing different callback functions.
- **Separation of Concerns**: The request handling logic is separated from the action to be taken with the response, making your code cleaner and easier to maintain.
- **Asynchronous Handling**: This setup allows you to make multiple asynchronous AJAX requests simultaneously without blocking the execution of other code.

### Example Use Case:

Imagine you want to make two AJAX requests on the same page, one to fetch the current weather data and another to fetch the latest news. You can use the same `loadDoc` function for both, but use different callback functions for processing the responses:

```javascript
loadDoc(""weather_api_url"", displayWeather);  // Callback for weather data
loadDoc(""news_api_url"", displayNews);        // Callback for news data

function displayWeather(xhttp) {
    var weatherData = JSON.parse(xhttp.responseText);  // Assuming JSON response
    document.getElementById(""weather"").innerHTML = ""Temperature: "" + weatherData.temp + ""°C"";
}

function displayNews(xhttp) {
    var newsData = JSON.parse(xhttp.responseText);  // Assuming JSON response
    document.getElementById(""news"").innerHTML = ""Latest news: "" + newsData.headline;
}
```

### Summary:

- **`loadDoc(url, cFunction)`** sends an AJAX request to the specified URL and calls the given callback function once the response is ready.
- The callback function can be customized for each request, allowing for flexible handling of different server responses.
- This approach helps keep the code organized and reusable, especially when handling multiple asynchronous tasks on the same page."		
266	AJAX response	Server Response Properties	"### Server Response Properties in `XMLHttpRequest`

When an **`XMLHttpRequest`** object is used to send a request to the server, there are two key properties to access the server’s response:

1. **`responseText`**: This property provides the response from the server as a **string**.
2. **`responseXML`**: This property provides the response from the server as **XML** data.

These properties allow you to handle the server’s response in different formats, depending on the type of data returned by the server.

---

### 1. **`responseText`**:
- **Purpose**: The **`responseText`** property is used to get the response data as a **plain text string**. This is commonly used when the server returns text-based data (e.g., HTML, plain text, JSON).
- **When to use**: Use **`responseText`** when the server response is in a string format, like HTML content or textual data.

#### Example:
```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Using responseText to handle a text-based response
        document.getElementById(""demo"").innerHTML = this.responseText;  // Display the response
    }
};
xhttp.open(""GET"", ""ajax_info.txt"", true);
xhttp.send();
```

In this example, the response from the server (`ajax_info.txt`) is treated as plain text, and it's inserted into the HTML element with the ID `""demo""`.

---

### 2. **`responseXML`**:
- **Purpose**: The **`responseXML`** property is used to get the response data as **XML** data. This allows you to interact with the response as an **XML document**, making it easier to parse and manipulate structured XML data.
- **When to use**: Use **`responseXML`** when the server returns an **XML** response (e.g., when working with XML APIs or XML-based data).

#### Example:
```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Using responseXML to handle an XML response
        var xmlDoc = this.responseXML;
        var title = xmlDoc.getElementsByTagName(""title"")[0].childNodes[0].nodeValue;
        document.getElementById(""demo"").innerHTML = title;  // Display the extracted data
    }
};
xhttp.open(""GET"", ""ajax_info.xml"", true);
xhttp.send();
```

In this example:
- The response is expected to be **XML** (`ajax_info.xml`).
- The **`getElementsByTagName(""title"")`** method is used to retrieve the content inside the `<title>` tag of the XML.
- The `nodeValue` property is used to get the text content inside the XML tag.

### Differences Between `responseText` and `responseXML`:
- **`responseText`**: Returns the server's response as a **string** (often used for plain text, HTML, JSON).
- **`responseXML`**: Returns the server's response as an **XML document**, which can be queried using methods like **`getElementsByTagName`**, **`getAttribute`**, or **`childNodes`**.

### Choosing Between `responseText` and `responseXML`:
- If you expect the server to return **text** data (e.g., HTML, JSON, plain text), use **`responseText`**.
- If you expect the server to return **structured XML data**, use **`responseXML`**.

---

### Summary:
- **`responseText`**: Use when the server response is a string (e.g., HTML, JSON).
- **`responseXML`**: Use when the server response is in **XML** format, allowing you to parse the response using XML methods.

These two properties are essential for working with different types of server responses and enable you to handle and manipulate the data accordingly in your JavaScript applications.&lt;/body&gt;&lt;/html&gt;</title>"		
267	AJAX response	Server Response Methods	"### Server Response Methods in `XMLHttpRequest`

When making requests to the server using the **`XMLHttpRequest`** object, you can also retrieve information about the response headers. This can be useful for accessing metadata about the response, such as the content type, server type, or custom headers that may be returned by the server.

There are two key methods for retrieving server response headers:

1. **`getResponseHeader()`**: Retrieves a specific header from the server response.
2. **`getAllResponseHeaders()`**: Retrieves all the headers from the server response.

---

### 1. **`getResponseHeader(headerName)`**:
- **Purpose**: The **`getResponseHeader()`** method allows you to retrieve a specific response header by name.
- **Parameters**:
  - **`headerName`**: The name of the header you want to retrieve (e.g., `""Content-Type""`, `""Authorization""`, etc.).
- **Returns**: The value of the specified header or `null` if the header is not present in the response.

#### Example:

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Retrieve a specific header, such as Content-Type
        var contentType = xhttp.getResponseHeader(""Content-Type"");
        console.log(""Response Content-Type: "" + contentType);  // Logs the Content-Type header
    }
};
xhttp.open(""GET"", ""ajax_info.txt"", true);
xhttp.send();
```

In this example:
- The **`getResponseHeader(""Content-Type"")`** method retrieves the **`Content-Type`** header from the response. The **`Content-Type`** header tells you what type of data the server is sending (e.g., `""text/html""`, `""application/json""`, etc.).

#### Common Headers You Might Retrieve:
- **`Content-Type`**: The type of content being returned (e.g., `""application/json""`).
- **`Content-Length`**: The size of the response body in bytes.
- **`Authorization`**: Used in authenticated requests, returning authentication data (e.g., a token).

---

### 2. **`getAllResponseHeaders()`**:
- **Purpose**: The **`getAllResponseHeaders()`** method retrieves all the headers of the response as a string. The headers are returned as a single string, with each header separated by a newline character (`\r\n`).
- **Returns**: A string containing all headers, with each header separated by a newline (`\r\n`).

#### Example:

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Retrieve all headers
        var allHeaders = xhttp.getAllResponseHeaders();
        console.log(""All Response Headers: "" + allHeaders);  // Logs all headers
    }
};
xhttp.open(""GET"", ""ajax_info.txt"", true);
xhttp.send();
```

In this example:
- The **`getAllResponseHeaders()`** method retrieves all the headers from the server's response as a single string. You can then log or process these headers.

#### Example Output (from the server response headers):
```
Content-Type: text/plain
Content-Length: 1024
Date: Thu, 01 Jan 2025 12:00:00 GMT
Server: Apache/2.4.41 (Ubuntu)
```

You can then parse this string or look for specific headers if needed.

---

### Key Differences:
- **`getResponseHeader(headerName)`**: Allows you to get the value of a specific header by its name.
  - Use this when you only need one specific piece of header information.
- **`getAllResponseHeaders()`**: Returns all headers as a single string.
  - Use this when you want to inspect or process all the headers from the server response.

---

### Practical Use Case Example:
You may want to send an **AJAX** request and handle response headers for various purposes, such as:
- **Checking the content type** of the response to determine how to process it.
- **Reading authentication tokens** from the headers for subsequent requests.
- **Handling caching** by checking the cache control headers.

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Get the Content-Type header
        var contentType = xhttp.getResponseHeader(""Content-Type"");

        if (contentType.includes(""application/json"")) {
            // Parse and process JSON response
            var jsonResponse = JSON.parse(this.responseText);
            console.log(jsonResponse);
        } else {
            // Handle other content types (e.g., HTML, XML, etc.)
            console.log(this.responseText);
        }

        // Check the server's cache control header
        var cacheControl = xhttp.getResponseHeader(""Cache-Control"");
        console.log(""Cache-Control: "" + cacheControl);
    }
};
xhttp.open(""GET"", ""data.json"", true);
xhttp.send();
```

In this case:
- The **`Content-Type`** header helps decide if the response is JSON and should be parsed.
- The **`Cache-Control`** header tells you how the response should be cached.

---

### Summary:
- **`getResponseHeader(headerName)`**: Retrieves a specific response header by name.
- **`getAllResponseHeaders()`**: Retrieves all response headers as a single string.
  
These methods allow you to interact with and process the headers of the server's response, which is crucial for handling things like content type, authentication, caching, and more in your web applications."		
268	AJAX response	The responseText Property	"### Using `responseText` to Handle Server Response

The **`responseText`** property of the **`XMLHttpRequest`** object returns the server’s response as a **JavaScript string**. This string can be anything from plain text, HTML, JSON, or any other textual data returned by the server. You can then use this string in various ways, such as updating HTML content, parsing the string, or logging it for debugging purposes.

### Example: Displaying the Server Response in HTML

If the server returns plain text or HTML content, you can use **`responseText`** to update the page content dynamically.

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Define the function to handle the request's state changes
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // When the request is complete and successful
        document.getElementById(""demo"").innerHTML = this.responseText;  // Update the content of the ""demo"" element
    }
};

// Open the request (GET method, URL ""ajax_info.txt"", asynchronous)
xhttp.open(""GET"", ""ajax_info.txt"", true);

// Send the request to the server
xhttp.send();
```

### Breakdown:
1. **Create the `XMLHttpRequest` Object**: 
   - `var xhttp = new XMLHttpRequest();` creates a new **`XMLHttpRequest`** object.
   
2. **Set the `onreadystatechange` Handler**:
   - **`xhttp.onreadystatechange`** is the event handler that checks when the request's **`readyState`** changes. The function inside is executed whenever the state of the request changes.
   - **`if (this.readyState == 4 &amp;&amp; this.status == 200)`** checks if the request has been completed and was successful (`status 200` means ""OK"").

3. **Update HTML Content**:
   - **`document.getElementById(""demo"").innerHTML = this.responseText;`**: Once the request is complete, the **`responseText`** property (which contains the server's response) is assigned to the **`innerHTML`** of the element with the ID `""demo""`. This dynamically updates the content of the webpage based on the server's response.

4. **Send the GET Request**:
   - **`xhttp.open(""GET"", ""ajax_info.txt"", true);`** initializes the request to fetch the file **`ajax_info.txt`**.
   - **`xhttp.send();`** sends the request to the server.

---

### Example with JSON Data:

If the server responds with **JSON data**, you can parse the response using `JSON.parse()` and then use it accordingly:

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Parse the JSON response
        var jsonResponse = JSON.parse(this.responseText);

        // Use the parsed data
        document.getElementById(""demo"").innerHTML = jsonResponse.message;
    }
};

xhttp.open(""GET"", ""data.json"", true);
xhttp.send();
```

In this example:
- The server returns JSON data (e.g., `{""message"": ""Hello, World!""}`).
- **`JSON.parse(this.responseText)`** is used to convert the response string into a JavaScript object.
- The parsed data is used to update the **`innerHTML`** of the **`demo`** element with the value of the **`message`** property from the JSON response.

---

### Summary:
- **`responseText`** gives you the server response as a **string**.
- You can use this string to update the content of HTML elements, parse the data (for JSON responses), or handle the response data in other ways.

Example use cases:
- **Display text** or **HTML content** returned from the server.
- **Parse and display JSON data**.
- Handle **server responses** dynamically without reloading the page."		
269	AJAX response	The responseXML Property	"### Using `responseXML` to Handle XML Data in `XMLHttpRequest`

The **`responseXML`** property of the **`XMLHttpRequest`** object is used to retrieve the server's response as an **XML DOM object**. This property allows you to work with XML data returned by the server, enabling you to navigate, manipulate, and extract specific information from the XML response using DOM methods.

### Key Concept: **XML DOM**

The **XML DOM** (Document Object Model) provides a structured representation of the XML document. It allows you to traverse and manipulate the XML structure using methods such as **`getElementsByTagName()`**, **`getAttribute()`**, and **`childNodes`**.

### Example: Handling XML Data with `responseXML`

Here’s an example of how to send a request to the server, get the response as an XML document, and parse it using the **`responseXML`** property:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Define the function to handle the request's state changes
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Get the XML response as an XML DOM object
        var xmlDoc = this.responseXML;

        // Parse the XML document using DOM methods
        var elements = xmlDoc.getElementsByTagName(""name"");  // Get all elements with the tag ""name""
        
        // Display the content of the first ""name"" element
        document.getElementById(""demo"").innerHTML = elements[0].childNodes[0].nodeValue;
    }
};

// Open the request (GET method, asynchronous)
xhttp.open(""GET"", ""ajax_info.xml"", true);

// Send the request to the server
xhttp.send();
```

### Explanation:

1. **Create the `XMLHttpRequest` Object**:
   - `var xhttp = new XMLHttpRequest();` creates a new **`XMLHttpRequest`** object.

2. **Define the `onreadystatechange` Event Handler**:
   - The function inside **`xhttp.onreadystatechange`** is executed whenever the **`readyState`** of the request changes.
   - **`if (this.readyState == 4 &amp;&amp; this.status == 200)`** ensures that the function is called only when the request is complete and successful.

3. **Accessing `responseXML`**:
   - **`var xmlDoc = this.responseXML;`** retrieves the server response as an **XML DOM object**.

4. **Parsing the XML**:
   - **`xmlDoc.getElementsByTagName(""name"")`** is used to get all elements with the tag name `<name>` in the XML response.
   - **`elements[0].childNodes[0].nodeValue`** accesses the value inside the first `<name>` tag and extracts it.

5. **Displaying the XML Data**:
   - **`document.getElementById(""demo"").innerHTML = elements[0].childNodes[0].nodeValue;`** updates the content of the HTML element with the ID `""demo""` with the extracted value from the XML.

---

### Example XML File (`ajax_info.xml`):

The XML response might look like this:

```xml
<employees>
    <employee>
        <name>John Doe</name>
        <position>Manager</position>
    </employee>
    <employee>
        <name>Jane Smith</name>
        <position>Developer</position>
    </employee>
</employees>
```

- In this example, **`getElementsByTagName(""name"")`** would retrieve all the `<name>` elements from the XML.
- **`elements[0].childNodes[0].nodeValue`** would extract `""John Doe""`, which is the content of the first `<name>` tag.

---

### Why Use `responseXML`?

- **Structured Data**: If the server returns data in XML format, **`responseXML`** allows you to easily parse and interact with the response as an XML document using standard DOM methods.
- **Traversing XML**: With **`responseXML`**, you can traverse the XML structure to retrieve specific elements, attributes, or data from the server response.
- **Data Manipulation**: You can manipulate the XML data and update the DOM with the parsed information.

---

### Summary:
- **`responseXML`** allows you to retrieve the server's response as an XML DOM object.
- You can then use DOM methods (like **`getElementsByTagName()`**, **`getAttribute()`**, and **`childNodes`**) to navigate and manipulate the XML structure.
- This makes it easier to work with structured XML data returned from the server, especially when dealing with APIs or data feeds that use XML.

### Example Use Cases:
- **Retrieving data from an XML API**: Using **`responseXML`** to fetch and display structured data from XML-based APIs.
- **Displaying dynamic content**: Extracting and displaying specific content from an XML response on your webpage.
</name></name></name></name>"		
270	AJAX response	The getAllResponseHeaders() Method	"### Using `getAllResponseHeaders()` to Retrieve Server Headers

The **`getAllResponseHeaders()`** method of the **`XMLHttpRequest`** object is used to retrieve all headers from the server response as a single string. The headers are returned with each header separated by a newline (`\r\n`). This can be useful if you need to inspect all the headers returned by the server in a single request.

### Syntax:
```javascript
var headers = xhttp.getAllResponseHeaders();
```

### Example:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Define the function to handle the request's state changes
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Retrieve all response headers
        var headers = this.getAllResponseHeaders();
        
        // Display the headers in an HTML element with the ID ""demo""
        document.getElementById(""demo"").innerHTML = headers;
    }
};

// Open the request (GET method, asynchronous)
xhttp.open(""GET"", ""ajax_info.txt"", true);

// Send the request to the server
xhttp.send();
```

### Breakdown:
1. **Creating the `XMLHttpRequest` Object**:
   - `var xhttp = new XMLHttpRequest();` creates a new instance of the **`XMLHttpRequest`** object to interact with the server.

2. **Setting the `onreadystatechange` Event Handler**:
   - **`xhttp.onreadystatechange`** defines a function that is triggered whenever the **`readyState`** of the request changes.
   - **`if (this.readyState == 4 &amp;&amp; this.status == 200)`** checks if the request is complete (`readyState == 4`) and successful (`status == 200`).

3. **Using `getAllResponseHeaders()`**:
   - **`this.getAllResponseHeaders()`** retrieves all the response headers as a single string, with each header separated by a newline character (`\r\n`).
   
4. **Displaying the Headers**:
   - **`document.getElementById(""demo"").innerHTML = headers;`** updates the HTML content of the element with ID `""demo""` with the headers string returned by `getAllResponseHeaders()`.

### Example Output:
The headers might look like this:
```
Content-Type: text/plain
Content-Length: 1024
Date: Thu, 01 Jan 2025 12:00:00 GMT
Server: Apache/2.4.41 (Ubuntu)
```

Each header is separated by a newline (`\r\n`), and you can process or display them as needed.

### Use Cases for `getAllResponseHeaders()`:
- **Debugging**: You can use this method to inspect the response headers during development, which can help identify issues like content types or caching behavior.
- **Extracting Specific Headers**: Although **`getAllResponseHeaders()`** returns all headers, you can use **`getResponseHeader()`** to retrieve specific headers (e.g., `Content-Type`, `Authorization`).
- **Caching and Authentication**: Many headers, such as **`Cache-Control`**, **`Authorization`**, and **`Set-Cookie`**, are important for controlling caching or handling session/authentication.

### Example: Extracting a Specific Header from All Headers:
While **`getAllResponseHeaders()`** returns all headers, you can extract specific headers by splitting the string and searching for the desired header.

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Get all response headers
        var headers = this.getAllResponseHeaders();

        // Parse the headers string into an array
        var headerArray = headers.split(""\r\n"");

        // Extract the Content-Type header
        var contentType = headerArray.find(header =&gt; header.startsWith(""Content-Type""));
        
        // Display the Content-Type header
        document.getElementById(""demo"").innerHTML = contentType;
    }
};
xhttp.open(""GET"", ""ajax_info.txt"", true);
xhttp.send();
```

In this example:
- The **`getAllResponseHeaders()`** method returns all headers.
- **`split(""\r\n"")`** splits the header string into an array.
- **`find(header =&gt; header.startsWith(""Content-Type""))`** extracts the `Content-Type` header.

### Conclusion:
- **`getAllResponseHeaders()`** allows you to retrieve and inspect all the headers from the server response.
- It returns the headers as a string, with each header separated by a newline (`\r\n`).
- You can use this method to debug, check for specific headers, or process server response metadata (e.g., content type, length, or authentication headers)."		
271	AJAX response	The getResponseHeader() Method	"### Using `getResponseHeader()` to Retrieve Specific Header Information

The **`getResponseHeader()`** method allows you to retrieve a specific header from the server's response. This is useful when you need to access particular header information, such as the **`Content-Type`**, **`Last-Modified`**, **`Authorization`**, or any other custom headers returned by the server.

### Syntax:
```javascript
xhttp.getResponseHeader(headerName);
```
- **`headerName`**: The name of the header you want to retrieve (e.g., `""Last-Modified""`, `""Content-Type""`).

### Example: Retrieving a Specific Header (`Last-Modified`)

The following example demonstrates how to retrieve the **`Last-Modified`** header from the server's response:

```javascript
var xhttp = new XMLHttpRequest();  // Create a new XMLHttpRequest object

// Define the function to handle the request's state changes
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Retrieve the ""Last-Modified"" header from the response
        var lastModified = this.getResponseHeader(""Last-Modified"");
        
        // Display the ""Last-Modified"" header in the HTML element with ID ""demo""
        document.getElementById(""demo"").innerHTML = ""Last Modified: "" + lastModified;
    }
};

// Open the GET request (asynchronous)
xhttp.open(""GET"", ""ajax_info.txt"", true);

// Send the request to the server
xhttp.send();
```

### Breakdown:
1. **Create the `XMLHttpRequest` Object**:
   - `var xhttp = new XMLHttpRequest();` creates a new **`XMLHttpRequest`** object.
   
2. **Set Up the `onreadystatechange` Event Handler**:
   - **`xhttp.onreadystatechange`** is triggered whenever the **`readyState`** changes.
   - **`if (this.readyState == 4 &amp;&amp; this.status == 200)`** ensures the function only runs once the request is complete and successful.

3. **Get the Specific Header**:
   - **`this.getResponseHeader(""Last-Modified"")`** retrieves the **`Last-Modified`** header from the server's response.
   - This header typically tells you when the resource was last modified on the server.

4. **Display the Header**:
   - **`document.getElementById(""demo"").innerHTML = ""Last Modified: "" + lastModified;`** updates the content of the **`demo`** HTML element with the **`Last-Modified`** value.

### Example of `Last-Modified` Header in Response:
The server may return a response with the **`Last-Modified`** header, like this:

```
Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT
```

The **`getResponseHeader(""Last-Modified"")`** method will extract this header's value and display it.

---

### Common Use Cases for `getResponseHeader()`:
- **Caching**: You can use the **`Last-Modified`** header to determine if the resource has been updated, so you can decide whether to fetch a new version or use the cached version.
- **Content Type**: The **`Content-Type`** header tells you what type of data is returned (e.g., `application/json`, `text/html`), so you can process it accordingly.
- **Authentication**: If the server uses authentication tokens, the **`Authorization`** header may be important to extract.
  
### Example: Using `getResponseHeader()` for `Content-Type`:
```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 200) {
        // Get the Content-Type header
        var contentType = this.getResponseHeader(""Content-Type"");
        console.log(""Response Content-Type: "" + contentType);  // Log the Content-Type
    }
};
xhttp.open(""GET"", ""ajax_info.txt"", true);
xhttp.send();
```

In this case, the **`Content-Type`** header might be something like `""text/html""` or `""application/json""`, which tells you what format the server's response is in.

---

### Summary:
- **`getResponseHeader(headerName)`** is used to retrieve a specific header from the server response.
- It allows you to access information like **`Last-Modified`**, **`Content-Type`**, or any custom headers sent by the server.
- It is useful when you need specific details about the response, such as the content type or when a resource was last modified."		
272	Modules	What are JS modules?	"### Introduction to JavaScript Modules (ES Modules)

JavaScript Modules, often referred to as **ES Modules** or **ECMAScript Modules**, are a standardized way to organize and share code across different files in JavaScript. With the introduction of ES6 (ECMAScript 2015), JavaScript added a native **module system** to the language, which allows developers to **import** and **export** code between files, making it easier to manage and structure large applications.

Before ES Modules were introduced, developers relied on userland module systems like **CommonJS** (used in Node.js) or **AMD** (Asynchronous Module Definition). These systems provided ways to split code into separate files, but they were not part of the JavaScript language specification. ES Modules aim to standardize this behavior directly in JavaScript.

### Key Features of ES Modules:
1. **Standardized Syntax**: ES Modules use the `import` and `export` keywords, which are now part of the language specification.
2. **Static Structure**: Unlike older systems like CommonJS, which allow dynamic imports, ES Modules are static, meaning imports and exports are determined at compile time, which allows for better optimizations like tree-shaking (removing unused code).
3. **Native Browser Support**: Modern browsers support ES Modules natively, allowing developers to use them directly in the browser without the need for transpilers (like Babel).
4. **Asynchronous Loading**: ES Modules are loaded asynchronously, which is beneficial for performance.

### Exporting in JavaScript Modules

In an ES module, you can export variables, functions, or classes from one file so that they can be used in another. This is done using the **`export`** keyword.

#### 1. **Named Exports**

Named exports allow you to export multiple things from a module. Each item you want to export is prefixed with `export`.

##### Example:
```javascript
// math.js
export const PI = 3.14159;
export function add(x, y) {
    return x + y;
}
export function multiply(x, y) {
    return x * y;
}
```

Here, we are exporting:
- A **constant** `PI`.
- A **function** `add()`.
- Another **function** `multiply()`.

These exports can be imported in other modules.

#### 2. **Default Exports**

A module can have a **default export** to export a single value or function. This is useful when you want to export one primary thing from a module.

##### Example:
```javascript
// greet.js
export default function greet(name) {
    return `Hello, ${name}!`;
}
```

In this case, we are exporting a **default function**. A module can have **only one default export**.

---

### Importing in JavaScript Modules

Once you've exported your code from one module, you can **import** it into other modules using the **`import`** keyword.

#### 1. **Importing Named Exports**

To import specific named exports from a module, you use curly braces `{}` around the items you want to import.

##### Example:
```javascript
// app.js
import { PI, add, multiply } from './math.js';

console.log(PI);          // 3.14159
console.log(add(2, 3));   // 5
console.log(multiply(2, 3));  // 6
```

Here, we imported:
- **`PI`**, **`add`**, and **`multiply`** from the **`math.js`** module.

#### 2. **Importing Default Exports**

To import a default export, you don’t use curly braces. Instead, you can give it any name you want.

##### Example:
```javascript
// app.js
import greet from './greet.js';

console.log(greet('Alice'));  // ""Hello, Alice!""
```

Here, we imported the **default export** from **`greet.js`** and renamed it as `greet` in **`app.js`**.

#### 3. **Renaming Imports**

You can also rename imports using the `as` keyword if the name in the module conflicts with something else or if you want to provide a more meaningful name.

##### Example:
```javascript
// app.js
import { add as addition, multiply as product } from './math.js';

console.log(addition(2, 3));  // 5
console.log(product(2, 3));   // 6
```

Here, we renamed the imported `add` to `addition` and `multiply` to `product`.

#### 4. **Importing Everything from a Module**

You can also import all exports from a module as a single object using `* as`.

##### Example:
```javascript
// app.js
import * as math from './math.js';

console.log(math.PI);          // 3.14159
console.log(math.add(2, 3));   // 5
console.log(math.multiply(2, 3));  // 6
```

In this example, we imported all exports from the **`math.js`** module under the **`math`** object.

---

### Summary of `export` and `import`:

#### Export:
- **Named Exports**: Export multiple items with specific names using `export`.
- **Default Export**: Export a single item as the default export using `export default`.

#### Import:
- **Named Imports**: Use `{}` to import specific named exports.
- **Default Import**: Import the default export without `{}`.
- **Renaming Imports**: Use the `as` keyword to rename imports.
- **Import Everything**: Use `* as` to import all exports from a module.

---

### Example: Combining Named and Default Exports

You can use both **default** and **named** exports in a single module.

##### Example:
```javascript
// utilities.js
export const version = '1.0.0';
export function add(x, y) {
    return x + y;
}
export default function subtract(x, y) {
    return x - y;
}
```

##### Importing:
```javascript
// app.js
import subtract, { version, add } from './utilities.js';

console.log(version);           // '1.0.0'
console.log(add(2, 3));         // 5
console.log(subtract(5, 3));    // 2
```

Here, `subtract` is the **default export**, and `version` and `add` are **named exports**.

---

### Conclusion:
ES Modules provide a powerful and standardized way to organize and manage code in JavaScript applications. With **`export`** and **`import`** statements, you can modularize your code and share functionality across different files. This makes large applications more maintainable and helps avoid code duplication."		
273	Modules	Syntax	"### Working with ES Modules and Default Exports

In this example, we are exploring how to export and import both **named exports** and **default exports** in JavaScript modules, and how to use them in other modules.

### 1. **Named Exports**:

In the **`lib.mjs`** module, we define two named exports: `repeat` and `shout`.

#### `lib.mjs` (Named Exports Example):
```javascript
// lib.mjs

// Named export of a function that repeats the string
export const repeat = (string) =&gt; `${string} ${string}`;

// Named export of a function that converts the string to uppercase with a ""!"" at the end
export function shout(string) {
    return `${string.toUpperCase()}!`;
}
```

Here:
- The **`repeat`** function takes a string and returns it repeated with a space between them.
- The **`shout`** function takes a string, converts it to uppercase, and appends a `!`.

Now, you can import these named exports into another module (e.g., **`main.mjs`**) using the **`import`** statement.

#### `main.mjs` (Importing Named Exports):
```javascript
// main.mjs

import { repeat, shout } from './lib.mjs';  // Import named exports

console.log(repeat('hello'));  // Output: 'hello hello'
console.log(shout('Modules in action'));  // Output: 'MODULES IN ACTION!'
```

- **`import { repeat, shout } from './lib.mjs'`** imports the named functions **`repeat`** and **`shout`** from the `lib.mjs` module.
- You can then call **`repeat()`** and **`shout()`** in the **`main.mjs`** module.

---

### 2. **Default Exports**:

You can also export a single value (function, object, etc.) as the **default export** of a module. In this case, we are exporting a function that converts the string to uppercase with an exclamation mark at the end.

#### `lib.mjs` (Default Export Example):
```javascript
// lib.mjs

// Default export of a function that converts string to uppercase with ""!""
export default function(string) {
    return `${string.toUpperCase()}!`;
}
```

In this module, we are exporting **one default function**, which takes a string, converts it to uppercase, and appends a `!`.

To import the default export, you do not need to use curly braces. You can use any name to import the default export.

#### `main.mjs` (Importing Default Export):
```javascript
// main.mjs

import shout from './lib.mjs';  // Import the default export and rename it as 'shout'

console.log(shout('Modules in action'));  // Output: 'MODULES IN ACTION!'
```

- **`import shout from './lib.mjs';`** imports the **default export** from the `lib.mjs` module and renames it as `shout` (you can choose any name here).
- The **`shout()`** function is then called in **`main.mjs`** to produce the desired output.

### Key Points:
- **Named Exports**: Allow you to export multiple elements (variables, functions, etc.) by name, and they must be imported using their exact names in the target module.
- **Default Export**: Allows you to export a single value or function as the default, and it can be imported using any name.
  
### Example of Mixing Named and Default Exports:

You can combine both named and default exports in the same module. Here's an example:

#### `lib.mjs` (Mixing Named and Default Exports):
```javascript
// lib.mjs

// Named export
export const repeat = (string) =&gt; `${string} ${string}`;

// Default export
export default function(string) {
    return `${string.toUpperCase()}!`;
}
```

#### `main.mjs` (Importing Named and Default Exports Together):
```javascript
// main.mjs

// Import named and default exports
import shout, { repeat } from './lib.mjs';  

console.log(repeat('hello'));  // Output: 'hello hello'
console.log(shout('Modules in action'));  // Output: 'MODULES IN ACTION!'
```

- **`import shout, { repeat } from './lib.mjs';`**: This imports both the **default export** (`shout`) and the **named export** (`repeat`) from `lib.mjs`.

---

### Conclusion:

- **Named Exports**: Use when you want to export multiple elements by their specific names, and they must be imported using the same names.
- **Default Exports**: Use when you want to export a single value or function, and it can be imported using any name.

Using **`export`** and **`import`** in this way helps in organizing your JavaScript code into reusable modules, making it easier to manage and maintain large applications."		
274	Modules	Modules are a little different from classic scripts	"### Understanding the Key Differences Between Modules and Classic Scripts in JavaScript

JavaScript **modules** (ES Modules) introduce several new behaviors that differentiate them from **classic scripts**. While modules provide a more structured and reusable way to organize code, they also come with certain restrictions and features that don't exist in traditional scripts. Here's an overview of the differences between modules and classic scripts, along with the consequences of these differences.

---

### Key Differences Between Modules and Classic Scripts:

#### 1. **Strict Mode is Enabled by Default**

- **Modules**: JavaScript modules are always in **strict mode** by default. This means:
  - You cannot use undeclared variables.
  - Assignment to non-writable properties will throw an error.
  - `delete` operations on non-configurable properties will throw an error.
  - Some other strict mode restrictions are enforced, improving security and code clarity.
  
- **Classic Scripts**: Classic scripts do not run in strict mode unless you explicitly declare `""use strict"";` at the top of the script.

#### Example of Strict Mode:
```javascript
// In a module, this will throw an error because ""foo"" is not declared
foo = 42;  // Error in modules, but works in classic scripts without strict mode
```

#### 2. **Global Variables Do Not Leak in Modules**

- **Modules**: Variables defined in a module **do not** become global by default. They are scoped to the module. This means that defining a variable inside a module will not create a global variable (such as `window.foo` in the browser environment).
  
  ```javascript
  // In a module
  var foo = 42;
  console.log(window.foo);  // Undefined, because foo is scoped to the module
  ```

- **Classic Scripts**: Variables declared using `var` in a classic script are added to the **global scope**. In a browser, this means they become properties of the `window` object.
  
  ```javascript
  // In a classic script
  var foo = 42;
  console.log(window.foo);  // 42, because foo is a global variable
  ```

#### 3. **`this` Behavior in Modules**

- **Modules**: Inside modules, the value of `this` is **undefined**. This is because the module is executed in strict mode, and in strict mode, `this` does not refer to the global object (`window` in browsers or `global` in Node.js).
  
  ```javascript
  // Inside a module
  console.log(this);  // undefined
  ```

- **Classic Scripts**: In non-module scripts, `this` refers to the **global object** (`window` in browsers or `global` in Node.js).
  
  ```javascript
  // In a classic script
  console.log(this);  // In a browser, this logs the global object: window
  ```

- **Accessing Global Object**: If you need access to the global object within a module, you can use the **`globalThis`** keyword, which is available in both modules and classic scripts.
  
  ```javascript
  // In a module, to access the global object
  console.log(globalThis);  // This will log the global object (window in browsers, global in Node.js)
  ```

#### 4. **Module Syntax: Import and Export**

- **Modules**: The **`import`** and **`export`** keywords are **only available** in modules. These features allow you to share functions, objects, and values between different JavaScript files in a standardized way.

  ```javascript
  // In a module file (example.js)
  export function greet() {
      return ""Hello, World!"";
  }

  // In another module file (app.js)
  import { greet } from './example.js';
  console.log(greet());  // Outputs ""Hello, World!""
  ```

- **Classic Scripts**: **`import`** and **`export`** are **not available** in classic scripts. To include one script in another, you would typically use `` in HTML or `require()` in Node.js.

#### 5. **HTML-Style Comment Syntax Is Not Supported in Modules**

- **Modules**: Modules do **not** support **HTML-style comments** (`<!-- -->`) that are typically used in HTML files. Instead, you should use standard JavaScript comments (`//` for single-line or `/* ... */` for multi-line comments).
  
  ```javascript
  // In a module
  // This is a comment
  ```

- **Classic Scripts**: HTML-style comments work fine in classic scripts when embedded in an HTML document.

  ```html
  <!-- This is an HTML comment in a classic script -->
  
  ```

#### 6. **Modules Have Lexical Top-Level Scope**

- **Modules**: The scope inside modules is **lexical**, meaning that the variables, functions, and other elements are scoped to the module itself. They do not automatically get added to the global object (like `window` or `global`), unlike variables in classic scripts.
  
- **Classic Scripts**: Variables declared with `var` in classic scripts are globally scoped, meaning they are accessible globally across all scripts loaded on the page.

#### 7. **Modules Require Explicit Identification**

- **Modules**: In order to use JavaScript modules, the browser or JavaScript environment needs to know that the file is a module. This is typically done by setting the `
  ```

- **Classic Scripts**: Classic scripts do not require the `type=""module""` declaration and are simply referenced by ``.

---

### Summary of Differences:

| **Feature**                           | **Modules**                                    | **Classic Scripts**                               |
|---------------------------------------|------------------------------------------------|--------------------------------------------------|
| **Strict Mode**                       | Enabled by default                             | Not in strict mode by default                    |
| **Global Scope**                      | Variables do not automatically become global   | Variables declared with `var` become global      |
| **`this` Behavior**                   | `this` is `undefined`                          | `this` refers to the global object (e.g., `window`) |
| **`import` and `export` Syntax**      | Supported                                      | Not supported                                    |
| **Comment Syntax**                    | Only JavaScript comments (`//` and `/*...*/`)   | HTML-style comments (`<!-- -->`) supported in HTML |
| **Top-Level Scope**                   | Lexical scope (no global leak)                 | Global scope (variables leak globally)           |
| **Identification**                    | Needs `type=""module""` or `.mjs` extension      | No special identification needed                 |

### Conclusion:

JavaScript **modules** offer more predictable and manageable code by enforcing strict mode, isolating variables to the module scope, and supporting import/export functionality. However, they have some key differences compared to classic scripts, such as the behavior of **`this`**, scope management, and the need for explicit identification as a module. Understanding these differences is essential when transitioning between classic scripts and ES modules in modern JavaScript development."		
275	Modules	Using JS modules in the browser	"### Using ` <!-- Module script -->
 <!-- Fallback for browsers that do not support modules -->
```

### Explanation:

1. **`
    
    <!-- Load a fallback script for browsers that do not support modules -->
    



```

### In this example:
- **`main.mjs`** is your modern ES module script that will run in browsers supporting modules.
- **`fallback.js`** is the fallback script that will run in older browsers that don't support ES Modules.

### Summary:
- **`"		
276	Modules	Javascript modules vs Angular modules	"### ES6 Modules vs Angular Modules

Both **ES6 Modules** and **Angular Modules** are important constructs in their respective ecosystems, but they serve different purposes and operate in different contexts. Let's explore each of them and compare their roles.

---

### **ES6 Modules** (JavaScript Modules)

#### Overview:
- **ES6 Modules** (also known as **JS Modules**, **JavaScript Modules**, or **ECMAScript Modules**) are part of the **JavaScript language** specification and provide a standardized way to organize and share code.
- Each **ES6 module** is stored in its own **file**. There's exactly one module per file, and each file can export code (functions, variables, classes, etc.) that can then be **imported** by other modules.
- **ES6 Modules** are designed to promote modular programming, allowing code to be encapsulated, reusable, and easily maintained.

#### Key Features:
1. **Exporting Code**: 
   - You can **export** variables, functions, classes, and objects from a module.
   - You can use either **named exports** or a **default export**.
   
   Example of **named export**:
   ```javascript
   // math.js
   export const add = (a, b) =&gt; a + b;
   export const subtract = (a, b) =&gt; a - b;
   ```

   Example of **default export**:
   ```javascript
   // greet.js
   export default function greet(name) {
       return `Hello, ${name}!`;
   }
   ```

2. **Importing Code**:
   - Code that is exported from one module can be **imported** into another module using the `import` statement.
   
   Example:
   ```javascript
   // main.js
   import { add, subtract } from './math.js'; // Importing named exports
   import greet from './greet.js';            // Importing the default export
   
   console.log(add(2, 3));  // Outputs: 5
   console.log(greet(""Alice""));  // Outputs: Hello, Alice!
   ```

3. **Encapsulation**: 
   - ES6 modules allow for encapsulation by keeping code **private** to the module, meaning it doesn’t pollute the global namespace. Variables or functions that are not explicitly exported cannot be accessed outside the module.

4. **Static Imports**:
   - **ES6 Modules** are **static**, meaning imports are determined at compile time. This enables **optimizations** like **tree-shaking**, where unused code can be eliminated during bundling.

#### Purpose of ES6 Modules:
- **Avoid global namespace pollution**: By exporting and importing specific parts of code, ES6 modules prevent unnecessary global variables from being created.
- **Encapsulation**: Code inside a module is private unless explicitly exported, helping to hide internal implementation details.
- **Reusability**: Modules promote reusability by enabling specific functionalities to be shared across different parts of an application.

---

### **Angular Modules** (NgModules)

#### Overview:
- **Angular Modules** (also known as **NgModules**) are an Angular-specific concept used to organize an Angular application into cohesive blocks.
- They provide metadata to the Angular compiler using the `@NgModule` decorator and help group related Angular artifacts (such as components, services, directives, pipes, etc.) into logical units.
- Angular modules facilitate the organization of the application structure and the **Separation of Concerns**.

#### Key Features:
1. **@NgModule Decorator**:
   - Angular modules are defined using the **`@NgModule`** decorator. The decorator provides the **metadata** that defines how the module should behave and how the different parts of the application are organized.
   
   Example of an **Angular Module**:
   ```typescript
   // app.module.ts
   import { NgModule } from '@angular/core';
   import { BrowserModule } from '@angular/platform-browser';
   import { AppComponent } from './app.component';
   
   @NgModule({
     declarations: [AppComponent],  // Components, directives, and pipes that belong to this module
     imports: [BrowserModule],      // External modules needed by this module
     providers: [],                 // Services or providers that will be used in this module
     bootstrap: [AppComponent]      // The main component that should be bootstrapped when the app starts
   })
   export class AppModule { }
   ```

2. **Components, Directives, and Pipes**:
   - Angular modules help organize **components**, **directives**, and **pipes** into logical groupings. Each **component** typically belongs to one module.

3. **Services**:
   - Angular modules also manage **services** (often provided via the `providers` array). Services provide logic that can be shared across multiple components, and they can be injected into components using Angular’s **dependency injection**.

4. **Lazy Loading**:
   - Angular supports **lazy loading** of modules, meaning that certain parts of the application (like feature modules) can be loaded only when needed, improving performance.

#### Purpose of Angular Modules:
- **Organize Angular artifacts**: Angular modules group related components, services, pipes, and directives together, making it easier to manage and scale large applications.
- **Maintain separation of concerns**: By logically grouping related parts of the application, Angular modules help ensure that code is well-structured and that concerns like UI, business logic, and services are kept separate.
- **Improve performance with lazy loading**: Angular modules support lazy loading, which allows only parts of the application to be loaded on demand.

---

### Comparison: ES6 Modules vs Angular Modules

| **Feature**                  | **ES6 Modules**                                           | **Angular Modules** (NgModules)                                 |
|------------------------------|-----------------------------------------------------------|-----------------------------------------------------------------|
| **Context**                  | Standard JavaScript language feature                      | Angular-specific framework feature                              |
| **Purpose**                   | To organize code into reusable, encapsulated units       | To organize Angular components, services, and other artifacts  |
| **Used For**                  | Encapsulation and code reusability across JavaScript apps | Structuring Angular apps and providing metadata to Angular's compiler |
| **Syntax**                    | `import` / `export`                                       | `@NgModule` decorator                                           |
| **Encapsulation**             | Modules help prevent polluting the global namespace       | NgModules help encapsulate and organize Angular features       |
| **Code Organization**         | Organize small units of JavaScript code                   | Group Angular components, directives, pipes, and services      |
| **Scope**                     | Module-scoped variables are not global                    | Modules help with grouping Angular artifacts into cohesive blocks |
| **Lazy Loading**              | Not directly related to modules but can be achieved with dynamic imports | Native support for lazy loading of feature modules             |

---

### Conclusion:

While **ES6 Modules** and **Angular Modules** share the concept of code organization, they serve different purposes in their respective ecosystems.

- **ES6 Modules** provide a way to structure and share JavaScript code in a reusable manner, focusing on encapsulation and preventing global scope pollution.
- **Angular Modules (NgModules)** are an Angular-specific construct that organizes various Angular features like components, services, pipes, etc., and helps structure the application, making it easier to manage large-scale Angular applications with optimizations like lazy loading.

Both types of modules help achieve code organization, maintainability, and reusability but are used in different contexts. ES6 Modules are standard JavaScript modules, while Angular Modules are part of Angular's framework for organizing Angular-specific artifacts."		
277	Promises	Terminology	"**Terminology**

- **Pending:**  
  The initial state of a promise before the asynchronous operation completes.

- **Fulfilled:**  
  Indicates that the asynchronous operation completed successfully and a resulting value is available.

- **Rejected:**  
  Indicates that the asynchronous operation failed, along with an associated error reason.

- **Settled:**  
  Refers to a promise that is no longer pending because it has been either fulfilled or rejected.

- **Thenable:**  
  An object that has a `then` method, meaning it behaves similarly to a promise."		
278	Promises	Syntax	"**Creating a Promise**

```javascript
var promise = new Promise(function(resolve, reject) {
    // Execute an operation, which might be asynchronous.
    if (/* operation successful */) {
        resolve(""Stuff worked!"");
    } else {
        reject(Error(""It broke""));
    }
});
```

- The Promise constructor receives a function with two parameters: `resolve` and `reject`.
- Within this function, perform your operation.  
- Call `resolve(value)` if the operation is successful, or `reject(error)` if it fails.

**Using the Promise**

```javascript
promise.then(
    function(result) {
        console.log(result); // Logs: ""Stuff worked!""
    },
    function(err) {
        console.log(err); // Logs: Error: ""It broke""
    }
);
```

- The `then()` method accepts two optional callbacks:
  - The first handles a successful resolution.
  - The second handles a rejection (error case)."		
279	Promises	Promise.all syntax	"```javascript
// Single promise usage:
request1.ready().then(
    function() {
        // This runs when request1 loads successfully.
    },
    function() {
        // This runs when request1 fails.
    }
);

// Combining multiple promises:
Promise.all([request1.ready(), request2.ready()]).then(
    function() {
        // This runs when both request1 and request2 load successfully.
    },
    function() {
        // This runs if at least one request fails.
    }
);
```

- The first example attaches success and failure callbacks to a single promise.
- The second example uses `Promise.all()` to wait for an array of promises. The success callback runs only when every promise is fulfilled, while the failure callback runs if any promise is rejected."		
280	Promises	Chaining	"Chaining with `.then()` lets you perform sequential transformations or additional asynchronous actions. Each call to `.then()` returns a new promise, and the value you return from one callback is automatically passed as the input to the next.

```javascript
var promise = new Promise(function(resolve, reject) {
    resolve(1); // The promise resolves with the value 1.
});

promise.then(function(val) {
    console.log(val); // Logs 1.
    return val + 2;   // Returns 3 for the next .then() in the chain.
}).then(function(val) {
    console.log(val); // Logs 3.
});
```"		
281	Promises	Queuing asynchronous actions	"**Chaining Async Actions with `.then()`**

- Returning a simple value in a `.then()` callback passes that value immediately to the next `.then()`.
- Returning a promise (or thenable) makes the chain wait until that promise settles before proceeding.

```javascript
getJSON('story.json').then(function(story) {
    // Return a promise that loads the first chapter.
    return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
    // This runs after the chapter promise settles.
    console.log(""Got chapter 1!"", chapter1);
});
```"		
282	Promises	Promisifying XMLHttpRequest	"**Promisifying XMLHttpRequest**

This example wraps an XMLHttpRequest in a Promise, allowing you to handle asynchronous HTTP requests using the Promise API.

```javascript
function get(url) {
    // Return a new promise that will be fulfilled or rejected based on the XHR result.
    return new Promise(function(resolve, reject) {
        var req = new XMLHttpRequest();
        req.open('GET', url);
        
        req.onload = function() {
            // onload is called even for error statuses (like 404), so check the status code.
            if (req.status == 200) {
                // Resolve the promise with the response text when successful.
                resolve(req.response);
            } else {
                // Reject the promise with an error message if the status indicates failure.
                reject(Error(req.statusText));
            }
        };
        
        // Handle network errors by rejecting the promise.
        req.onerror = function() {
            reject(Error(""Network Error""));
        };
        
        // Send the HTTP request.
        req.send();
    });
}
```

**Usage Example**

```javascript
get('story.json').then(
    function(response) {
        console.log(""Success!"", response);
    },
    function(error) {
        console.error(""Failed!"", error);
    }
);
```

- The `get` function returns a promise that resolves with the response text if the HTTP status is 200.
- If the status is not 200, or if there’s a network error, the promise is rejected with an appropriate error.
- The usage example shows how to handle both success and failure using the `.then()` method."		
283	Promises	Chaining	"**Chaining Promises and Transforming Values**

- **Sequential Operations:**  
  Chaining `.then()` lets you execute asynchronous actions in sequence. The output of one `.then()` is passed as input to the next.

- **Value Transformation:**  
  If you return a simple value from a `.then()` callback, that value is passed directly to the next callback.  
  If you return a promise (or a thenable), the chain will wait for it to settle before proceeding.

**Example 1: Transforming Values**

```javascript
var promise = new Promise(function(resolve, reject) {
    resolve(1);
});

promise.then(function(val) {
    console.log(val); // Logs 1
    return val + 2;   // Passes 3 to the next .then()
}).then(function(val) {
    console.log(val); // Logs 3
});
```

**Example 2: Chaining Async Actions**

Imagine you have a `get` function that fetches data as plain text. You can chain `.then()` to parse JSON and work with the resulting object:

```javascript
get('story.json')
    .then(function(response) {
        // Convert the plain text response into a JSON object.
        return JSON.parse(response);
    })
    .then(function(data) {
        console.log(""Yey JSON!"", data);
    });
```

Since `JSON.parse` accepts one argument and returns a value, you can simplify the code by passing it directly to `.then()`:

```javascript
get('story.json')
    .then(JSON.parse)
    .then(function(data) {
        console.log(""Yey JSON!"", data);
    });
```

**Creating a Convenience Function**

You can further encapsulate this pattern by creating a `getJSON` function:

```javascript
function getJSON(url) {
    return get(url).then(JSON.parse);
}

getJSON('story.json').then(function(data) {
    console.log(""Yey JSON!"", data);
});
```

- **Summary:**  
  Chaining with `.then()` allows you to transform values and sequence asynchronous actions. When you return a promise from a `.then()` callback, the next step waits for that promise to settle before it runs."		
284	Promises	Error handling	"**Error Handling in Promises**

- **Using then(success, failure):**
  - You pass two callbacks to handle success and failure.
  - Only one of the callbacks is executed—either the fulfillment callback or the rejection callback.

  ```javascript
  get('story.json').then(
      function(response) {
          console.log(""Success!"", response);
      },
      function(error) {
          console.log(""Failed!"", error);
      }
  );
  ```

- **Using then().catch():**
  - You attach a success callback with then(), then handle errors with catch().
  - catch() is just shorthand for then(undefined, errorHandler) and is often more readable.
  - Errors that occur in the success callback are also caught by catch().

  ```javascript
  get('story.json')
      .then(function(response) {
          console.log(""Success!"", response);
      })
      .catch(function(error) {
          console.log(""Failed!"", error);
      });
  ```

- **Key Difference:**
  - With `then(success, failure)`, only one callback will be called based on the original promise outcome.
  - With `then(success).catch(failure)`, the catch() will handle both a rejection from the initial promise and any errors thrown in the preceding then() callback."		
285	Promises	Promise.all	"Promise.all takes an array of promises and returns a new promise that:

- Resolves when every promise in the array resolves.
- Yields an array of results, where each result corresponds to the resolved value of each promise, in the same order as they were passed in.
- Rejects immediately if any promise in the array rejects, using that rejection reason.

```javascript
Promise.all(arrayOfPromises)
    .then(function(arrayOfResults) {
        // This runs when every promise has successfully resolved.
        // arrayOfResults is an array of values from the promises, in the same order.
    })
    .catch(function(error) {
        // This runs if any of the promises rejects.
    });
```"		
286	Promises	Promises and generators	"**Generators**

- Generators are special functions in ES6 that can pause their execution and resume later.  
- They are defined with a star (`*`) before the function name and use the `yield` keyword as a pause point.

```javascript
function* addGenerator() {
    let i = 0;
    while (true) {
        // Pause execution and yield the current value of i.
        // When resumed, the value passed to next() will be added to i.
        i += yield i;
    }
}
```

- **Usage Example:**

```javascript
const adder = addGenerator();
console.log(adder.next().value); // Outputs: 0 (initial yield)
console.log(adder.next(5).value); // Outputs: 5 (0 + 5)
console.log(adder.next(5).value); // Outputs: 10 (5 + 5)
console.log(adder.next(5).value); // Outputs: 15 (10 + 5)
console.log(adder.next(50).value); // Outputs: 65 (15 + 50)
```

**Using Generators for Asynchronous Code**

- By leveraging generators, you can write asynchronous code that looks like synchronous code.
- The `yield` keyword can be used to pause execution until a promise settles (resolves or rejects), allowing you to wait for asynchronous actions to complete.

**The spawn() Helper Function**

- The `spawn` function allows you to use generators to manage asynchronous operations with promises.
- It runs a generator function and automatically resumes it when the yielded promises settle.
- If a yielded promise resolves, its value is sent back into the generator; if it rejects, the error is thrown into the generator.

```javascript
function spawn(generatorFunc) {
    function continuer(verb, arg) {
        let result;
        try {
            result = generator[verb](arg);
        } catch (err) {
            return Promise.reject(err);
        }
        if (result.done) {
            // When the generator is finished, return the final value.
            return result.value;
        } else {
            // Wait for the yielded promise to settle before continuing.
            return Promise.resolve(result.value).then(onFulfilled, onRejected);
        }
    }
    const generator = generatorFunc();
    const onFulfilled = continuer.bind(continuer, ""next"");
    const onRejected = continuer.bind(continuer, ""throw"");
    return onFulfilled();
}
```

- **How It Works:**
  - **Start:** `spawn` invokes the generator function to create a generator instance.
  - **Continue:** The helper function `continuer` resumes the generator using either `next` or `throw`, based on whether the promise resolves or rejects.
  - **Chain:** If the generator yields a promise, `spawn` waits until that promise is resolved before calling the next iteration of the generator.
  - **Completion:** When the generator is done (`result.done` is true), its final value is returned.

This approach makes it easier to manage asynchronous code by writing it in a linear, synchronous style while still handling promise-based asynchronous operations."		
287	Promises	Promises API reference	"**Promise Static Methods**

- **`Promise.resolve(value)`**
  - **If value is a promise:** Returns the same promise (provided its constructor is `Promise`).
  - **If value is thenable:** Returns a new promise that follows the state of the thenable (an object with a `then()` method).
  - **Otherwise:** Returns a promise that fulfills with the given value.

- **`Promise.reject(error)`**
  - Returns a promise that immediately rejects with the provided error.
  - For consistency and better debugging (e.g., proper stack traces), it’s recommended that `error` is an instance of `Error`.

- **`Promise.all(array)`**
  - Accepts an array of promises (or values, which are wrapped via `Promise.resolve`).
  - Returns a new promise that fulfills only when every promise in the array fulfills.
  - The fulfillment value is an array of resolved values in the same order as the input.
  - If any promise rejects, the returned promise rejects immediately with that rejection reason.

- **`Promise.race(array)`**
  - Accepts an array of promises (or values).
  - Returns a promise that settles (fulfills or rejects) as soon as one of the input promises settles.
  - *Note:* Some developers find `Promise.race` less useful since it doesn't wait for all promises, unlike `Promise.all`.

---

**Promise Constructor**

- **`new Promise(executor)`**
  - Creates a new promise.
  - The `executor` function receives two functions: `resolve` and `reject`.
    - **`resolve(thenableOrValue)`**
      - If passed a thenable, the promise adopts its eventual state.
      - Otherwise, the promise fulfills with the given value.
    - **`reject(error)`**
      - Rejects the promise with the provided error.
      - Errors thrown within the executor are automatically caught and passed to `reject`.

---

**Instance Methods**

- **`promise.then(onFulfilled, onRejected)`**
  - Attaches callbacks for both fulfillment and rejection:
    - **`onFulfilled(value)`**: Called when the promise resolves.
    - **`onRejected(reason)`**: Called when the promise rejects.
  - Both callbacks are optional; if omitted, the next handler in the chain is used.
  - Returns a new promise that resolves to the value returned by the called callback (after being processed by `Promise.resolve`).
  - If a callback throws an error, the new promise is rejected with that error.

- **`promise.catch(onRejected)`**
  - Shorthand for `promise.then(undefined, onRejected)`.
  - Catches any rejection from the promise or from any previous `.then()` in the chain."		
288	Async/await	Introduction	"**Async Functions**

- **Definition:**  
  Mark a function with the `async` keyword to enable the use of `await` within it.

- **Using `await`:**  
  - When you `await` a promise, the function pauses (without blocking the main thread) until the promise settles.
  - If the promise fulfills, the fulfilled value is returned.
  - If the promise rejects, an error is thrown.

- **Error Handling:**  
  Use `try/catch` blocks to handle errors, just as you would in synchronous code.

```javascript
async function myFirstAsyncFunction() {
    try {
        const fulfilledValue = await somePromise();
        // Use fulfilledValue after the promise resolves.
    } catch (error) {
        // Handle the error if the promise rejects.
    }
}
```

- **Benefits:**  
  Async/await makes asynchronous code easier to write and read, transforming promise-based code into a style that looks synchronous without blocking execution."		
289	Async/await	Arrow functions	"**Arrow Functions with Async/Await**

Using an async arrow function within Array.map allows you to create promises for each element in an array. In the example below, each URL is mapped to a promise that fetches the URL and returns the parsed JSON:

```javascript
const jsonPromises = urls.map(async url =&gt; {
    const response = await fetch(url);
    return response.json();
});
```

- The async arrow function automatically returns a promise.
- The `await` keyword pauses the function until `fetch(url)` resolves, then `response.json()` is returned.
- Array.map collects these promises into an array without waiting for one to complete before starting the next."		
290	Async/await	Object methods	"**Object Methods with Async/Await**

You can define asynchronous methods within objects using the `async` keyword. In the example below, the `storage` object has an async method `getAvatar` that performs asynchronous operations using `await`:

```javascript
const storage = {
    async getAvatar(name) {
        // Open the 'avatars' cache asynchronously.
        const cache = await caches.open('avatars');
        // Return a promise that resolves with the matching avatar image.
        return cache.match(`/avatars/${name}.jpg`);
    }
};

// Call the async method and handle the resulting promise.
storage.getAvatar('jaffathecake').then(avatar =&gt; {
    // Use the avatar image here.
});
```

- The `async` keyword allows you to use `await` inside the method.
- The method always returns a promise, so you can chain `.then()` to process the resolved value.
- The asynchronous operations (like opening the cache) are handled seamlessly with `await`."		
291	Async/await	Class methods	"```javascript
class Storage {
    constructor() {
        // Start opening the 'avatars' cache immediately and store the promise.
        this.cachePromise = caches.open('avatars');
    }
    
    async getAvatar(name) {
        // Wait for the cache to open, then find and return the matching avatar.
        const cache = await this.cachePromise;
        return cache.match(`/avatars/${name}.jpg`);
    }
}

const storage = new Storage();
storage.getAvatar('jaffathecake').then(avatar =&gt; {
    // Process the avatar image here.
});
```

- **Async Class Method:**  
  The `getAvatar` method is marked with `async`, allowing you to use `await` inside it. This method always returns a promise.

- **Constructor Setup:**  
  The constructor initializes `this.cachePromise` with the promise returned by `caches.open('avatars')`, so the cache starts loading immediately when an instance is created.

- **Using await:**  
  Inside `getAvatar`, the `await` keyword pauses execution until `this.cachePromise` resolves, ensuring the cache is available before calling `cache.match`.

- **Promise Chaining:**  
  Since `getAvatar` returns a promise, you can use `.then()` to handle its resolved value.

- **Limitations:**  
  Note that class constructors and getters/setters cannot be async."		
292	Async/await	Working in parallel	"**Running Async Operations in Parallel**

Even though async/await makes asynchronous code look synchronous, you can still run tasks in parallel by starting them before awaiting.

**Sequential Execution (Series):**

```javascript
async function series() {
    await wait(500); // Waits 500ms.
    await wait(500); // Then waits another 500ms.
    return ""done!"";
}
```

- Total time: Approximately 1000ms, because each wait occurs one after the other.

**Parallel Execution:**

```javascript
async function parallel() {
    const wait1 = wait(500); // Starts the first 500ms timer.
    const wait2 = wait(500); // Starts the second 500ms timer concurrently.
    await wait1;             // Waits for the first timer.
    await wait2;             // Waits for the second timer, which is already complete.
    return ""done!"";
}
```

- Total time: Approximately 500ms, as both timers run concurrently.

This approach lets you perform independent asynchronous actions in parallel, reducing total execution time."		
293	JS 2020	The Nullish Coalescing Operator (??)	"**Nullish Coalescing Operator**

The nullish coalescing operator (`??`) provides a concise way to return a fallback value when dealing with potentially null or undefined variables. It only considers `null` or `undefined` as “nullish,” meaning that if a variable holds a falsy value like `0` or `''`, those values are preserved.

---

**Basic Syntax**

```javascript
leftOperand ?? rightOperand
```

- If `leftOperand` is neither `null` nor `undefined`, the expression returns `leftOperand`.
- Otherwise, it returns `rightOperand`.

---

**Examples**

- **Default Value for Null or Undefined:**

  ```javascript
  let value = null;
  let result = value ?? 'default';
  console.log(result); // Outputs: 'default'
  ```

- **Preserving Falsy Values:**

  ```javascript
  let value = 0;
  let result = value ?? 42;
  console.log(result); // Outputs: 0 (because 0 is not null or undefined)
  ```

---

**Comparison with Logical OR (`||`)**

- **Logical OR (`||`):**
  - Returns the right-hand operand if the left-hand operand is falsy (i.e., `null`, `undefined`, `0`, `false`, `''`).
- **Nullish Coalescing (`??`):**
  - Returns the right-hand operand only if the left-hand operand is `null` or `undefined`.

  ```javascript
  let value = 0;
  console.log(value || 42);  // Outputs: 42 (0 is falsy)
  console.log(value ?? 42);  // Outputs: 0  (0 is not nullish)
  ```

---

**Operator Precedence and Parentheses**

The `??` operator has lower precedence than many other operators, so when combined with logical operators like `||` or `&amp;&amp;`, it's often necessary to use parentheses to avoid syntax errors and ensure correct evaluation.

```javascript
let a = null;
let b = 'fallback';
// Use parentheses to ensure the nullish coalescing is evaluated first.
let result = (a ?? b) || 'default';
```

---

**Practical Use Cases**

- **Providing Default Values:**

  Use `??` to ensure that default values are applied only when variables are truly `null` or `undefined`.

  ```javascript
  function greet(name) {
      const finalName = name ?? 'Guest';
      console.log(`Hello, ${finalName}!`);
  }
  ```

- **Working with Function Parameters:**

  When parameters might not be provided, `??` allows for a fallback without overwriting falsy, but valid, values.

- **Destructuring with Defaults:**

  In object destructuring, `??` can help ensure that only `null` or `undefined` trigger a default value, not values like `0` or `''`.

  ```javascript
  const options = { timeout: 0 };
  const { timeout, retries = 3 } = options;
  const effectiveTimeout = timeout ?? 1000; // Uses 0 from options instead of 1000.
  ```

---

**Summary**

The nullish coalescing operator (`??`) is a powerful tool to simplify the handling of default values. Unlike the logical OR operator, it only treats `null` and `undefined` as needing a fallback, thereby preserving other falsy values. Remember to use parentheses when combining it with other logical operators to maintain clarity and correctness."		
294	JS 2020	The Optional Chaining Operator (?.)	"**Optional Chaining Operator (?.)**

The Optional Chaining Operator (`?.`) enables safe access to nested object properties or methods without having to explicitly check if each reference in the chain exists. If any part of the chain is `null` or `undefined`, the expression short-circuits and returns `undefined` instead of throwing an error.

---

**Basic Syntax**

```javascript
// Accessing a property:
obj?.prop

// Accessing an array element:
obj?.[index]

// Calling a function:
obj?.method()
```

- The operator stops evaluation if the value before `?.` is `null` or `undefined`.

---

**Examples**

- **Safe Property Access:**

  ```javascript
  const user = { name: 'Alice', address: { city: 'Wonderland' } };
  console.log(user.address?.city); // Outputs: 'Wonderland'
  console.log(user.contact?.phone); // Outputs: undefined (no error thrown)
  ```

- **Safe Function Calls:**

  ```javascript
  const user = {
      name: 'Alice',
      getAddress: function() {
          return 'Wonderland';
      }
  };
  console.log(user.getAddress?.()); // Outputs: 'Wonderland'
  console.log(user.getPhone?.());   // Outputs: undefined (no error thrown)
  ```

- **Safe Array Access:**

  ```javascript
  const users = [{ name: 'Alice' }, { name: 'Bob' }];
  console.log(users?.[0]?.name); // Outputs: 'Alice'
  console.log(users?.[2]?.name); // Outputs: undefined
  ```

---

**Practical Use Cases**

- **Deeply Nested Objects:**  
  Avoid repetitive checks when accessing properties several layers deep:
  ```javascript
  const city = user.profile?.address?.city;
  ```

- **Dynamic Data:**  
  When dealing with data from external sources where some fields might be missing, optional chaining prevents runtime errors.

- **Combined with Nullish Coalescing:**  
  Provide default values if the accessed property is missing:
  ```javascript
  const phone = user.contact?.phone ?? 'No phone provided';
  ```

---

**Summary**

The Optional Chaining Operator (`?.`) simplifies code by allowing you to access properties, call functions, or access array elements safely on potentially `null` or `undefined` objects. It prevents runtime errors and reduces the need for verbose conditional checks, making your code more concise and robust."		
295	JS 2020	Assignment operators	"**Logical Assignment Operators**

JavaScript provides three logical assignment operators that combine logical operations with assignment. They simplify common patterns where you conditionally update a variable.

---

**Logical AND Assignment (&amp;&amp;=)**

- **Usage:**  
  `x &amp;&amp;= y` assigns the result of `y` to `x` only if `x` is truthy.
  
- **Equivalent To:**  
  ```javascript
  if (x) {
      x = y;
  }
  ```

- **Example:**
  ```javascript
  let a = 10;
  a &amp;&amp;= 5; // Since a is truthy, a becomes 5.
  
  let flag = false;
  flag &amp;&amp;= true; // flag remains false because it's not truthy.
  ```

---

**Logical OR Assignment (||=)**

- **Usage:**  
  `x ||= y` assigns `y` to `x` only if `x` is falsy.
  
- **Equivalent To:**  
  ```javascript
  if (!x) {
      x = y;
  }
  ```

- **Example:**
  ```javascript
  let b = 0;
  b ||= 42; // Since 0 is falsy, b becomes 42.
  
  let name = ""Alice"";
  name ||= ""Guest""; // name remains ""Alice"" because it's truthy.
  ```

---

**Nullish Coalescing Assignment (??=)**

- **Usage:**  
  `x ??= y` assigns `y` to `x` only if `x` is `null` or `undefined`.
  
- **Equivalent To:**  
  ```javascript
  if (x === null || x === undefined) {
      x = y;
  }
  ```

- **Example:**
  ```javascript
  let c = null;
  c ??= 42; // c becomes 42 because it was null.
  
  let d = 0;
  d ??= 100; // d remains 0 because 0 is not null or undefined.
  ```

---

**Summary**

- **`&amp;&amp;=`** updates a variable only if its current value is truthy.
- **`||=`** updates a variable only if its current value is falsy.
- **`??=`** updates a variable only if its current value is nullish (i.e., `null` or `undefined`).

These operators offer a concise way to conditionally assign values without needing explicit `if` statements."		
296	JS 2020	Promise.allSettled()	"**Promise.allSettled()**

`Promise.allSettled()` takes an array (or iterable) of promises and returns a new promise that resolves after every promise in the array has settled—that is, each promise has either fulfilled or rejected. Unlike `Promise.all()`, it never rejects, but always resolves with an array of outcome objects.

---

**How It Works**

- The returned promise resolves to an array where each element corresponds to an input promise.
- Each element is an object with:
  - **`status`**: Either `""fulfilled""` or `""rejected""`.
  - **`value`**: Present when the promise is fulfilled.
  - **`reason`**: Present when the promise is rejected.

---

**Example**

```javascript
const promises = [
  Promise.resolve(42),
  Promise.reject(""error occurred""),
  Promise.resolve(""hello"")
];

Promise.allSettled(promises).then(results =&gt; {
  results.forEach(result =&gt; {
    if (result.status === ""fulfilled"") {
      console.log(""Fulfilled with:"", result.value);
    } else {
      console.log(""Rejected with:"", result.reason);
    }
  });
});
```

- In this example, all promises are run in parallel.
- The final result is an array of outcome objects that describe the outcome of each promise, regardless of whether they fulfilled or rejected.

---

**Use Cases**

- Useful when you need to know the result of every promise, without failing the entire operation if one promise rejects.
- Ideal for scenarios where you want to perform cleanup or log errors even when some operations fail."		
297	JS 2020	Dynamic Import	"**ES2020 Dynamic Import**

Dynamic import allows you to load modules asynchronously at runtime instead of statically at the top of your file. This enables on-demand loading, code splitting, and improved performance by reducing the initial load time.

---

**Basic Syntax**

```javascript
import(moduleSpecifier)
```

- Returns a promise that resolves to the module object.
- Can be used with `.then()` or `await` in an async function.

---

**Usage Examples**

- **Using then():**

  ```javascript
  import('./module.js')
    .then(module =&gt; {
      // Use the module, e.g., call a function from it
      module.doSomething();
    })
    .catch(error =&gt; {
      console.error(""Failed to load module:"", error);
    });
  ```

- **Using async/await:**

  ```javascript
  async function loadModule() {
    try {
      const module = await import('./module.js');
      module.doSomething();
    } catch (error) {
      console.error(""Failed to load module:"", error);
    }
  }
  ```

---

**Benefits**

- **On-Demand Loading:**  
  Load modules only when needed, which can reduce initial bundle size.
  
- **Code Splitting:**  
  Improve performance by splitting your code into smaller chunks that load dynamically.
  
- **Conditional Imports:**  
  Dynamically import modules based on runtime conditions (e.g., user actions or environment).

---

Dynamic import is a powerful ES2020 feature for modern JavaScript applications, enhancing modularity and performance through lazy loading and code splitting."		
298	JS 2020	BigInt	"**BigInt**

BigInt is a new primitive type in JavaScript that allows you to represent integers with arbitrary precision. This is especially useful when working with numbers that exceed the safe integer limit for the Number type (`Number.MAX_SAFE_INTEGER`).

---

**Basic Syntax**

- **Literal Notation:**

  ```javascript
  const largeNumber = 123456789012345678901234567890n;
  ```

- **Constructor Function:**

  ```javascript
  const largeNumber = BigInt(""123456789012345678901234567890"");
  ```

---

**Key Features**

- **Arbitrary Precision:**  
  BigInt can accurately represent integers beyond the safe limit of the Number type.

- **Distinct Type:**  
  BigInt is a separate type. The `typeof` operator returns `""bigint""`.

- **Arithmetic Operations:**  
  You can perform standard arithmetic (addition, subtraction, multiplication, division, etc.) with BigInts, but you cannot mix BigInts and Numbers directly. They must be explicitly converted.

---

**Examples**

- **Basic Arithmetic:**

  ```javascript
  const a = 9007199254740991n; // Maximum safe integer as BigInt
  const b = 2n;
  console.log(a + b); // 9007199254740993n
  ```

- **Comparison with Number:**

  ```javascript
  const num = 10;
  const big = 10n;
  console.log(num == big);  // true (loose equality)
  console.log(num === big); // false (strict equality; different types)
  ```

- **Type Conversion:**

  ```javascript
  const big = 20n;
  // Convert BigInt to Number (may lose precision if too large)
  const num = Number(big);
  ```

---

**Limitations**

- **No Mixed Operations:**  
  You cannot mix BigInts and Numbers directly in arithmetic expressions without explicit conversion.

- **Limited Math Functions:**  
  Many built-in Math functions (like `Math.sqrt`) do not work with BigInts.

- **Environment Support:**  
  Although widely supported in modern browsers and Node.js, BigInt might not be available in older environments.

---

BigInt is an essential feature for applications requiring high-precision arithmetic or handling very large integers that go beyond the typical safe limits of JavaScript's Number type."		
299	JS 2020	String matchAll()	"**String matchAll()**

Introduced in ES2020, the `matchAll()` method returns an iterator over all matches of a string against a regular expression, including capturing groups. It offers a more detailed alternative to `String.match()`, especially when you need to access capturing groups for each match.

---

**Basic Syntax**

```javascript
const matchesIterator = string.matchAll(regex);
```

- **Note:** The regular expression must have the global (`g`) or sticky (`y`) flag; otherwise, a `TypeError` is thrown.

---

**What It Returns**

- An iterator that yields an array for each match.
- Each match array includes:
  - The full matched substring at index 0.
  - Captured groups (if any) at subsequent indices.
  - Additional properties:
    - **`index`**: The starting index of the match in the string.
    - **`input`**: The original string.

---

**Example**

```javascript
const str = ""test1test2"";
const regex = /test(\d)/g;

const matches = [...str.matchAll(regex)];

console.log(matches);
/*
[
  [ 'test1', '1', index: 0, input: 'test1test2', groups: undefined ],
  [ 'test2', '2', index: 5, input: 'test1test2', groups: undefined ]
]
*/
```

- **Explanation:**
  - The regular expression `/test(\d)/g` matches the word ""test"" followed by a digit.
  - Using the spread operator (`...`), the iterator is converted into an array of matches.
  - Each match array contains the full match and the captured digit, along with metadata about the match.

---

**When to Use**

- When you need to retrieve all occurrences of a pattern in a string.
- When you require access to capturing groups from each match.
- As an alternative to `String.match()`, providing more comprehensive match details.

--- 

This method simplifies complex regex operations by providing a robust way to iterate over multiple matches in a string."		
300	JS 2021	Promise.any()	"**Promise.any()**

`Promise.any()` takes an iterable (usually an array) of promises and returns a new promise that fulfills as soon as any one of the input promises fulfills. If all the input promises reject, the returned promise rejects with an `AggregateError` containing all the individual rejection reasons.

---

**How It Works**

- **Fulfillment:**  
  The promise returned by `Promise.any()` fulfills with the value of the first promise that fulfills.

- **Rejection:**  
  If every promise in the iterable rejects, `Promise.any()` rejects with an `AggregateError`. This error object contains an `errors` property, which is an array of all the rejection reasons.

- **Use Case:**  
  It's useful when you want to get the first successful result among several asynchronous operations, without failing if some of them reject.

---

**Example**

```javascript
const p1 = Promise.reject(""Error 1"");
const p2 = new Promise((resolve) =&gt; setTimeout(resolve, 100, ""Success from p2""));
const p3 = new Promise((resolve) =&gt; setTimeout(resolve, 50, ""Success from p3""));

Promise.any([p1, p2, p3])
    .then(result =&gt; {
        console.log(""First fulfilled:"", result); // Logs: ""Success from p3""
    })
    .catch(error =&gt; {
        console.error(""All promises rejected:"", error);
    });
```

- In this example, even though `p1` rejects, `Promise.any()` fulfills with the value from `p3` since it resolves first.
- If all promises were to reject, the catch block would handle an `AggregateError` containing all the rejection reasons.

---

**Summary**

- **Returns a Fulfilled Promise:**  
  As soon as one promise fulfills.
- **Returns a Rejected Promise:**  
  If every promise rejects, with an `AggregateError`.
- **Ideal for:**  
  Scenarios where you only care about the first successful outcome among multiple asynchronous operations."		
301	JS 2021	String replaceAll()	"**String replaceAll()**

`replaceAll()` is a string method introduced in ES2021 that returns a new string with all occurrences of a specified value or pattern replaced by a replacement value. It simplifies replacing every instance in a string without needing a global regular expression.

---

**Basic Syntax**

```javascript
string.replaceAll(searchValue, replaceValue)
```

- **searchValue:**  
  Can be a substring or a regular expression (if using a regex, it must have the global (`g`) flag).

- **replaceValue:**  
  Can be a string or a function that returns the replacement value.

---

**Examples**

- **Replacing a Substring:**

  ```javascript
  const text = ""Hello world, world!"";
  const newText = text.replaceAll(""world"", ""JavaScript"");
  console.log(newText); // ""Hello JavaScript, JavaScript!""
  ```

- **Using a Regular Expression:**

  ```javascript
  const text = ""abc123abc456"";
  // Replace all digits with '#'
  const newText = text.replaceAll(/\d+/g, ""#"");
  console.log(newText); // ""abc#abc#""
  ```

- **Using a Replacement Function:**

  ```javascript
  const text = ""I have 1 apple, 2 oranges, and 3 bananas."";
  const newText = text.replaceAll(/\d+/g, match =&gt; parseInt(match) * 2);
  console.log(newText); // ""I have 2 apple, 4 oranges, and 6 bananas.""
  ```

---

**Key Points**

- **Immutable:**  
  `replaceAll()` does not modify the original string; it returns a new string with the replacements.

- **Convenience:**  
  It provides a simpler alternative to using `replace()` with global regular expressions when dealing with literal substrings.

- **Global Matching:**  
  When using a regex, ensure the global flag (`g`) is included; otherwise, a `TypeError` will be thrown.

---

This method streamlines the process of replacing all instances of a pattern or substring, making your code cleaner and more intuitive."		
302	JS 2021	Numeric Separators (_)	"**ES2021 Numeric Separators**

Numeric separators, introduced in ES2021, allow you to use underscores (`_`) in numeric literals to improve readability without affecting the actual value.

---

**Basic Syntax and Usage**

- **Readable Numbers:**  
  You can insert underscores within numeric literals to separate groups of digits.

  ```javascript
  const oneMillion = 1_000_000; // Same as 1000000
  const binaryValue = 0b1010_0101; // Binary literal with a separator
  const hexValue = 0xDE_AD_BE_EF; // Hexadecimal literal with separators
  ```

- **Floating-Point Numbers:**

  ```javascript
  const pi = 3.141_592_653_589_793;
  ```

---

**Rules and Restrictions**

- **Allowed Positions:**  
  Underscores can be placed between digits to group them (e.g., thousands, millions).

- **Not Allowed:**  
  - At the beginning or end of a number.
  - Adjacent to a decimal point.
  - Next to the exponent indicator in scientific notation.

  ```javascript
  // Invalid examples:
  const badNumber1 = _1000;    // Cannot start with an underscore.
  const badNumber2 = 1000_;    // Cannot end with an underscore.
  const badNumber3 = 1_.0;     // Underscore adjacent to the decimal point.
  const badNumber4 = 1e_10;    // Underscore adjacent to the exponent indicator.
  ```

---

**Benefits**

- **Enhanced Readability:**  
  Improves clarity in large numeric literals by visually separating digit groups.
- **No Impact on Performance:**  
  The underscores are removed during compilation, so they do not affect runtime performance or precision.

Numeric separators are a helpful addition for making your code more maintainable and easier to read, especially when working with large numbers or various numeral systems."		
303	JS 2022	Array at()	"**Array at()**

The `at()` method, introduced in ES2022, provides a cleaner and more expressive way to access elements in an array by index, supporting both positive and negative values.

---

**Basic Syntax**

```javascript
array.at(index)
```

- **Positive Index:**  
  Works like traditional indexing; for example, `array.at(0)` returns the first element.

- **Negative Index:**  
  Counts from the end of the array; for example, `array.at(-1)` returns the last element.

---

**Examples**

- **Using a Positive Index:**

  ```javascript
  const arr = [10, 20, 30, 40];
  console.log(arr.at(1)); // Outputs: 20
  ```

- **Using a Negative Index:**

  ```javascript
  const arr = [10, 20, 30, 40];
  console.log(arr.at(-1)); // Outputs: 40
  ```

- **Out-of-Bounds Index:**

  ```javascript
  const arr = [10, 20, 30, 40];
  console.log(arr.at(10)); // Outputs: undefined
  console.log(arr.at(-10)); // Outputs: undefined
  ```

---

**Benefits**

- **Readability:**  
  Using negative indices with `at()` makes code more readable compared to manually calculating positions (e.g., `array[array.length - 1]`).

- **Clarity:**  
  It clearly expresses the intention to access elements from the end of the array when using negative indices.

---

The `at()` method is a simple yet powerful addition that improves code readability and expressiveness when working with arrays."		
304	JS 2022	String at()	"**String at()**

The `at()` method for strings, introduced in ES2022, allows you to access a character at a specific index using both positive and negative numbers.

---

**Basic Syntax**

```javascript
string.at(index)
```

- **Positive Index:**  
  Retrieves the character at the specified position.
  
- **Negative Index:**  
  Retrieves the character counting from the end of the string.

---

**Examples**

- **Using a Positive Index:**

  ```javascript
  const str = ""hello"";
  console.log(str.at(1)); // Outputs: ""e""
  ```

- **Using a Negative Index:**

  ```javascript
  const str = ""hello"";
  console.log(str.at(-1)); // Outputs: ""o""
  ```

- **Out-of-Bounds:**

  ```javascript
  const str = ""hello"";
  console.log(str.at(10));  // Outputs: undefined
  console.log(str.at(-10)); // Outputs: undefined
  ```

---

**Benefits**

- **Improved Readability:**  
  Accessing characters with negative indices (e.g., `str.at(-1)`) is more intuitive than calculating positions manually.
  
- **Consistency:**  
  Similar to `Array.at()`, providing a uniform approach for accessing elements or characters.

---

`String at()` enhances code clarity by allowing direct access to string characters from both the beginning and the end of the string."		
305	JS 2022	Object.hasOwn()	"**Object.hasOwn()**

`Object.hasOwn()` is a static method introduced in ES2022 that provides a reliable way to check if an object has a specified property as its own (not inherited) property.

---

**Basic Syntax**

```javascript
Object.hasOwn(object, propertyKey)
```

- **object:**  
  The object to test.
- **propertyKey:**  
  The property key to check, which can be a string or a symbol.

---

**Key Points**

- **Returns a Boolean:**  
  Returns `true` if the object has the property as its own property; otherwise, it returns `false`.
  
- **Alternative to `hasOwnProperty`:**  
  Unlike `Object.prototype.hasOwnProperty`, `Object.hasOwn()` does not require calling the method on the object, avoiding issues when the object might have a property named `hasOwnProperty`.

- **Reliable:**  
  It safely checks for own properties without being affected by properties inherited from the prototype chain.

---

**Example**

```javascript
const user = { name: 'Alice' };

console.log(Object.hasOwn(user, 'name')); // true
console.log(Object.hasOwn(user, 'toString')); // false (inherited from Object.prototype)
```

---

`Object.hasOwn()` offers a clear and concise way to verify an object's own properties in modern JavaScript."		
306	JS 2022	error.cause	"**Error.cause**

`error.cause` is a property introduced in ES2022 that allows you to attach an underlying error (or ""cause"") to a newly created error. This enables more informative error handling and debugging by preserving the original error context.

---

**Usage**

- When constructing an error, you can pass an options object with a `cause` property.
- The attached cause can then be accessed via the `cause` property of the error instance.

---

**Example**

```javascript
try {
  // Simulate an underlying error.
  throw new Error(""Original error"");
} catch (originalError) {
  // Create a new error that wraps the original error.
  throw new Error(""Wrapper error"", { cause: originalError });
}

try {
  // Example to show how to access the cause.
  // This block simulates catching the wrapped error.
  throw new Error(""Wrapper error"", { cause: new Error(""Original error"") });
} catch (error) {
  console.error(error.message);       // ""Wrapper error""
  console.error(error.cause.message); // ""Original error""
}
```

---

**Benefits**

- **Improved Debugging:**  
  Maintains a chain of error information, making it easier to track down the root cause.
- **Clear Error Propagation:**  
  Provides structured error information without losing the context of the original issue.
- **Standardized Approach:**  
  Offers a standardized way to pass error causes, replacing ad-hoc solutions.

---

`error.cause` enhances error handling by linking errors in a meaningful chain, ultimately improving the clarity and traceability of exceptions in your applications."		
307	JS 2022	await import	"**Await Import**

Using `await` with `import()` allows you to dynamically load modules asynchronously within an async function, making your code more modular and efficient. This syntax enables you to load modules on demand, which can improve performance by reducing initial load times.

---

**Basic Syntax**

```javascript
async function loadModule() {
    try {
        const module = await import('./module.js');
        // Use the imported module, e.g. module.doSomething();
    } catch (error) {
        console.error(""Failed to load module:"", error);
    }
}
```

- **Dynamic Import:**  
  The `import()` function returns a promise that resolves to the module object.
  
- **Using await:**  
  The `await` keyword pauses execution until the module is loaded, allowing you to work with its exports directly.

---

**Key Points**

- **On-Demand Loading:**  
  Modules are loaded only when needed, which can help with code splitting and reduce the initial bundle size.
  
- **Error Handling:**  
  Wrap the await import in a try/catch block to handle potential errors during module loading.

- **Asynchronous Execution:**  
  Since `import()` returns a promise, you must use it inside an async function or within the top-level of an ES module (with top-level await support).

---

This approach makes it straightforward to conditionally load modules, keeping your codebase efficient and responsive."		
308	JS 2022	Class field declarations	"**Class Field Declarations**

Class field declarations allow you to declare properties directly within a class body, outside of the constructor. This feature simplifies the syntax for initializing instance and static properties, making the code more concise and easier to read.

---

**Basic Syntax**

- **Instance Fields:**

  ```javascript
  class MyClass {
      // Instance field with an initial value
      instanceField = ""default value"";
  }
  ```

- **Static Fields:**

  ```javascript
  class MyClass {
      // Static field declared with the static keyword
      static staticField = 42;
  }
  ```

- **Private Fields:**

  ```javascript
  class MyClass {
      // Private field starts with a #
      #privateField = ""secret"";

      getPrivate() {
          return this.#privateField;
      }
  }
  ```

---

**Key Points**

- **Simplified Initialization:**  
  You no longer need to assign properties within the constructor. Class fields are automatically set on the instance when it is created.

- **Readability:**  
  Declaring fields at the top of the class provides a clear overview of the properties that each instance will have.

- **Static and Private Support:**  
  Both static fields (shared across all instances) and private fields (accessible only within the class) are supported.

- **No Hoisting:**  
  Class field declarations are evaluated in the order they appear, similar to how properties are initialized in the constructor.

---

**Example**

```javascript
class User {
    // Instance field
    name = ""Guest"";

    // Static field
    static defaultRole = ""user"";

    // Private field
    #password = """";

    constructor(name, password) {
        if (name) this.name = name;
        if (password) this.#password = password;
    }

    // Method to validate the password
    validatePassword(input) {
        return input === this.#password;
    }
}

const user = new User(""Alice"", ""secret123"");
console.log(user.name);           // Outputs: ""Alice""
console.log(User.defaultRole);    // Outputs: ""user""
console.log(user.validatePassword(""secret123"")); // Outputs: true
```

---

Class field declarations provide a cleaner and more intuitive way to set up properties in your classes, reducing boilerplate and enhancing code clarity."		
309	JS 2022	Private methods and fields	"**Private Methods and Fields**

Private methods and fields are features in JavaScript that allow you to define class properties and methods that cannot be accessed or modified outside the class. They help encapsulate implementation details and protect the internal state of an object.

---

**Syntax**

- **Private Fields:**  
  Declared with a `#` prefix.

  ```javascript
  class Example {
      // Private field declaration
      #privateField = 'secret';

      getPrivate() {
          return this.#privateField;
      }
  }

  const obj = new Example();
  console.log(obj.getPrivate()); // 'secret'
  // console.log(obj.#privateField); // SyntaxError: Private field '#privateField' must be declared in an enclosing class
  ```

- **Private Methods:**  
  Also prefixed with a `#` and defined similarly to regular methods.

  ```javascript
  class Example {
      // Private field
      #privateField = 42;

      // Private method declaration
      #privateMethod() {
          return this.#privateField;
      }

      publicMethod() {
          // Call private method from within the class
          return this.#privateMethod();
      }
  }

  const obj = new Example();
  console.log(obj.publicMethod()); // 42
  // obj.#privateMethod(); // SyntaxError: Private method '#privateMethod' is not accessible outside class
  ```

---

**Key Points**

- **Encapsulation:**  
  Private fields and methods can only be accessed from within the class. This provides true encapsulation, preventing external code from directly interacting with internal implementation details.

- **Syntax Enforcement:**  
  Attempting to access or modify a private field or method from outside the class results in a syntax error, ensuring a strict boundary between public and private members.

- **Use Cases:**  
  Use private fields and methods to manage internal state or helper functions that should not be exposed as part of the class's public API.

Private methods and fields offer a robust mechanism for data encapsulation in JavaScript classes, enhancing the maintainability and reliability of your code by keeping internal details hidden from external access."		
310	JS 2023	array 2023	"**New Array Methods (ES2023)**

Modern JavaScript introduces several new array methods that offer immutable alternatives to common operations. These methods return new arrays instead of modifying the original array.

---

**Array.findLast(predicate, thisArg?)**

- **Purpose:**  
  Returns the last element in the array that satisfies the provided testing function.
- **Example:**

  ```javascript
  const arr = [5, 12, 8, 130, 44, 12];
  const lastLargeNumber = arr.findLast(element =&gt; element &gt; 10);
  console.log(lastLargeNumber); // Outputs: 12 (last element &gt; 10)
  ```

---

**Array.findLastIndex(predicate, thisArg?)**

- **Purpose:**  
  Returns the index of the last element in the array that satisfies the provided testing function.
- **Example:**

  ```javascript
  const arr = [5, 12, 8, 130, 44, 12];
  const lastIndex = arr.findLastIndex(element =&gt; element &gt; 10);
  console.log(lastIndex); // Outputs: 5 (index of the last element &gt; 10)
  ```

---

**Array.toReversed()**

- **Purpose:**  
  Returns a new array with the elements in reverse order, leaving the original array unchanged.
- **Example:**

  ```javascript
  const arr = [1, 2, 3];
  const reversedArr = arr.toReversed();
  console.log(reversedArr); // Outputs: [3, 2, 1]
  console.log(arr);         // Original remains: [1, 2, 3]
  ```

---

**Array.toSorted(compareFunction?)**

- **Purpose:**  
  Returns a new array with the elements sorted. Accepts an optional compare function and does not modify the original array.
- **Example:**

  ```javascript
  const arr = [3, 1, 2];
  const sortedArr = arr.toSorted();
  console.log(sortedArr); // Outputs: [1, 2, 3]
  console.log(arr);       // Original remains: [3, 1, 2]
  ```

---

**Array.toSpliced(start, deleteCount, ...items)**

- **Purpose:**  
  Returns a new array with modifications similar to `splice()`, but without mutating the original array.
- **Example:**

  ```javascript
  const arr = [1, 2, 3, 4, 5];
  const splicedArr = arr.toSpliced(2, 1, 99);
  console.log(splicedArr); // Outputs: [1, 2, 99, 4, 5]
  console.log(arr);        // Original remains: [1, 2, 3, 4, 5]
  ```

---

**Array.with(index, value)**

- **Purpose:**  
  Returns a new array with the element at the specified index replaced by the given value, leaving the original array intact.
- **Example:**

  ```javascript
  const arr = [1, 2, 3];
  const newArr = arr.with(1, 42);
  console.log(newArr); // Outputs: [1, 42, 3]
  console.log(arr);    // Original remains: [1, 2, 3]
  ```

---

These new array methods provide powerful, immutable ways to work with arrays, making code easier to reason about and reducing unintended side effects."		
311	JS 2023	"#! (Shebang)"	"**Shebang (#!)**

- **Definition:**  
  A shebang is a special line at the very top of a script file that starts with `#!` followed by the path to an interpreter.

- **Purpose:**  
  It tells Unix-like operating systems which interpreter to use to execute the file.

- **Usage:**  
  - Placed on the first line of a script.  
  - Common in executable scripts (e.g., Bash, Python, Node.js).
  
- **Example:**  
  ```bash
  #!/usr/bin/env node
  console.log(""Hello, world!"");
  ```
  This line instructs the OS to use the `node` interpreter to run the script.

- **Notes:**  
  - The shebang line is ignored by the interpreter if the script is executed in a different context (e.g., directly passed to Node.js).
  - Also known as a hashbang or pound-bang.
  - The example above tells the operating system to use the node program to run the script.
  - Now, you can run JavaScript code with ./fileName.js instead of node fileName.js.
  - #! is also called sharp-exclamation, hashbang, pound-bang, or hash-pling."		
312	JS 2024	Object.groupBy()	"**Object.groupBy()**

`Object.groupBy()` is a proposed static method (currently at stage 3) that groups the values of an iterable (like an array) into an object. It uses a callback function to determine the key for each element. All elements that produce the same key when passed to the callback are grouped together in an array under that key.

---

**Basic Syntax**

```javascript
const grouped = Object.groupBy(iterable, callback);
```

- **iterable:**  
  A collection (typically an array) of items to be grouped.
  
- **callback:**  
  A function invoked on each element of the iterable. The value returned by the callback is used as the grouping key (converted to a string).

---

**Return Value**

An object where:
- Each key corresponds to a group identifier produced by the callback.
- Each value is an array of elements from the iterable that share that key.

---

**Example**

```javascript
const numbers = [6.1, 4.2, 6.3];

// Group numbers by their floored value.
const grouped = Object.groupBy(numbers, Math.floor);

console.log(grouped);
// Expected output:
// {
//   ""4"": [4.2],
//   ""6"": [6.1, 6.3]
// }
```

- **Explanation:**  
  In this example, `Math.floor` is applied to each number:
  - `Math.floor(6.1)` returns `6`
  - `Math.floor(4.2)` returns `4`
  - `Math.floor(6.3)` returns `6`
  
  The result is an object grouping numbers under the keys `""4""` and `""6""`.

---

**Key Points**

- **Grouping Behavior:**  
  Items for which the callback returns the same key are collected into an array.
  
- **Key Conversion:**  
  The keys in the resulting object are strings, even if the callback returns numbers or other types.

- **Use Cases:**  
  Useful for data organization, categorization, and creating lookup objects based on specific properties.

---

*Note:* As of now, `Object.groupBy()` is still a proposal and may not be available in all environments. It aims to offer a standardized way to group values without needing third-party libraries or verbose code."		
313	JS 2024	Map.groupBy()	"**Map.groupBy()**

`Map.groupBy()` is a proposed static method that groups values from an iterable into a `Map`, based on a provided callback function. Unlike `Object.groupBy()`, which returns an object with string keys, `Map.groupBy()` preserves the original key types.

---

**Basic Syntax**

```javascript
const groupedMap = Map.groupBy(iterable, callback);
```

- **iterable:**  
  An iterable collection (e.g., an array) of items to be grouped.

- **callback:**  
  A function invoked for each element in the iterable. Its return value is used as the grouping key.

---

**Return Value**

A `Map` where:
- Each key is the value returned by the callback function.
- Each value is an array of items from the iterable that correspond to that key.

---

**Example**

```javascript
const numbers = [6.1, 4.2, 6.3];

// Group numbers by their floored value.
const grouped = Map.groupBy(numbers, Math.floor);

console.log(grouped);
// Expected output: Map(2) { 6 =&gt; [6.1, 6.3], 4 =&gt; [4.2] }
```

- **Explanation:**  
  In this example, `Math.floor` is applied to each number:
  - `Math.floor(6.1)` returns `6`
  - `Math.floor(4.2)` returns `4`
  - `Math.floor(6.3)` returns `6`
  
  The resulting `Map` groups numbers with key `6` and key `4`, preserving the numeric type of the keys.

---

**Key Points**

- **Preserved Key Types:**  
  Keys in the returned `Map` retain their original type, which can be useful for non-string group identifiers.

- **Immutability:**  
  The method groups values without modifying the original iterable.

- **Use Cases:**  
  Useful for categorizing data based on dynamic criteria, while keeping the grouping keys in their native type.

---

*Note:*  
`Map.groupBy()` is still a proposal and may not be available in all JavaScript environments. It offers a modern, type-preserving alternative for grouping data compared to older methods."		
314	JS 2024	Temporal.PlainDate()	"**Temporal API: PlainDate, PlainTime, PlainMonthDay, and PlainYearMonth**

The Temporal API introduces a set of classes that provide a more robust and precise approach to date and time handling in JavaScript. Here’s a summary of four key classes:

---

**Temporal.PlainDate**

- **Purpose:**  
  Represents a date (year, month, day) without any time-of-day or timezone information.
- **Usage:**  
  Ideal for modeling calendar dates, such as birthdays or appointments.
- **Example:**
  ```javascript
  const date = Temporal.PlainDate.from(""2023-03-01"");
  console.log(date.year);  // 2023
  console.log(date.month); // 3
  console.log(date.day);   // 1
  ```

---

**Temporal.PlainTime**

- **Purpose:**  
  Represents a time-of-day (hour, minute, second, fractional seconds) independent of any date or timezone.
- **Usage:**  
  Useful for scheduling daily activities or measuring durations within a day.
- **Example:**
  ```javascript
  const time = Temporal.PlainTime.from(""13:45:30"");
  console.log(time.hour);   // 13
  console.log(time.minute); // 45
  console.log(time.second); // 30
  ```

---

**Temporal.PlainMonthDay**

- **Purpose:**  
  Represents a month and day without a year, which is useful for recurring events such as anniversaries or birthdays.
- **Usage:**  
  Allows handling of dates that recur annually without a specific year.
- **Example:**
  ```javascript
  const monthDay = Temporal.PlainMonthDay.from(""--03-01"");
  console.log(monthDay.month); // 3
  console.log(monthDay.day);   // 1
  ```

---

**Temporal.PlainYearMonth**

- **Purpose:**  
  Represents a year and month without a specific day, useful for representing periods like billing cycles or project timelines.
- **Usage:**  
  Offers a way to work with year/month combinations without the need to specify a day.
- **Example:**
  ```javascript
  const yearMonth = Temporal.PlainYearMonth.from(""2023-03"");
  console.log(yearMonth.year);  // 2023
  console.log(yearMonth.month); // 3
  ```

---

These classes form part of the broader Temporal API, which aims to replace the existing Date API with a more intuitive, precise, and robust model for date and time handling in JavaScript."		
